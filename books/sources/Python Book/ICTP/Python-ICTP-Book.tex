\documentclass[12pt,a4paper,final,twoside,onecolumn,titlepage]{book}

\newcommand*{\plogo}{\fbox{$\mathcal{PL}$}} % Generic publisher logo

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\newcommand*{\titleGP}{\begingroup % Create the command for including the title page in the document
\centering % Center all text
\vspace*{\baselineskip} % White space at the top of the page

\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt} % Thick horizontal line
\rule{\textwidth}{0.4pt}\\[\baselineskip] % Thin horizontal line

{\LARGE Python Concepts \\ The Misunderstood Programming Language}\\[0.2\baselineskip] % Title

\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt} % Thin horizontal line
\rule{\textwidth}{1.6pt}\\[\baselineskip] % Thick horizontal line

\scshape % Small caps
Customized for Information and Communication Technology Project (ICTP) \\[\baselineskip] % Tagline(s) or further description
Egypt,  2013\par % Location and year

\vspace*{2\baselineskip} % Whitespace between location/year and editors

Collected by \\[\baselineskip]
{\Large HAITHAM A. EL-GHAREEB \par} % Editor list
{\itshape The University of Mansoura \\ Egypt\par} % Editor affiliation

\vfill % Whitespace between editor names and publisher logo

%\plogo \\[0.3\baselineskip] % Publisher logo
{\large helghareeb@mans.edu.eg \\ http://www.helghareeb.me}\par % Publisher
{\scshape 2013} \\[0.3\baselineskip] % Year published

\endgroup}

\usepackage[export]{adjustbox}

\usepackage{makeidx}
\usepackage[utf8]{inputenc} %File encoding
\usepackage[T1]{fontenc} % Use EC fonts
\usepackage{ae} % Fonts for PDF files
\usepackage{textcomp} % Text-Companion-Symbols (e. g. \texteuro)
\usepackage[english]{babel} % Language selection
\usepackage{lmodern} % Latin Modern

\usepackage{pdfpages}

%Added for Think Python as Computer Science Object Oriented Chapters
\usepackage{exercise}                        % texlive-latex-extra
\newtheorem{exercise}{Exercise}[chapter]


%New Section Added for Coding
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{multirow}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{white},
	tabsize=4,
	rulecolor=,
	language=Python,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}

%End of New Section Added for Coding

\usepackage[english]{translator}
%Load the package
\usepackage[
nonumberlist, %do not show page numbers
acronym,      %generate acronym listing
toc,          %show listings as entries in table of contents
section]      %use section level for toc entries
{glossaries}

\usepackage{hyperref}

%Added on March 20, 2013 for fitting figures within Text Boundaries
\usepackage[export]{adjustbox}
\usepackage{tabularx}

%This Package is used for Margins
\usepackage[margin=3.0cm]{geometry}

%Added on March 20, 2013 for fitting figures within Text Boundaries
\usepackage[export]{adjustbox}
\usepackage{tabularx}

%This Package is used for Margins
\usepackage[margin=3.0cm]{geometry}

%Generate a list of symboles
\newglossary[slg]{symbolslist}{syi}{syg}{List of symbols}

%Remove the dot at the end of glossary descriptions
\renewcommand*{\glspostdescription}{}

%Activate glossary commands
\makeglossaries

%These commands sort the lists
%makeindex -s filename.ist -t filename.alg -o filename.acr filename.acn
%makeindex -s filename.ist -t filename.glg -o filename.gls filename.glo
%makeindex -s filename.ist -t filename.slg -o filename.syi filename.syg

%Some entries for the list of symbols
\newglossaryentry{symb:Pi}{
name=$\pi$,
description={A mathematical constant whose value is the ratio of any circle's circumference to its diameter.},
sort=symbolpi, type=symbolslist
}


%Some acronyms
%\newacronym{AEHS}{AEHS}{Adaptive Educational Hypermedia Systems}

%An acronym with a glossary entry
%\newacronym{ADL}{ADL}{Advanced Distributed Learning\protect\glsadd{glos:ADL}}

%Some glossary terms
\newglossaryentry{glos:ADL}{name={ADL}, description = {ADL: Advanced Distributed Learning, established in 1997 to standardize and modernize training and education management and delivery. The Department of Defense (DoD) Office oversees the initiative. http://www.adlnet.gov}}


\author{Haitham A. El-Ghareeb, Ph.D. \\ \texttt{helghareeb@mans.edu.eg}}
\title{Associate Professor}
\date{\today}

\makeindex


\begin{document}
\frontmatter

%\maketitle
%\pagestyle{empty} % Removes page numbers

\thispagestyle{empty}
\titleGP % This command includes the title page


\cleardoublepage
\thispagestyle{empty}
\begin{center}
-= To my Family =- \\
\textit{Haitham A. El-Ghareeb, Ph.D.}
\end{center}

\begin{flushright}
May, 2013
\end{flushright}

\cleardoublepage
\phantomsection
\chapter{Acknowledgment}
%\addcontentsline{toc}{chapter}{Acknowledgment}
\thispagestyle{empty}
\paragraph*{
First and foremost, I thank ALLAH for giving me incentive to go on and finish this work, and every other work have been finished and giving me glimpses of heavenly hope in the darkest times.}

\paragraph*{I would like to thank Eng. Ayman Lotfy, Information Technology Institute (ITI) for the cooperation, generousity, and support.}

\paragraph*{I would like to thank Dr.Osama and Eng.ElSayeda for their cooperation in arranging this course, and giving me opportunity to present materials included inside for ICTP members allover Egyptian Universities.}

\paragraph*{My Family, you are the people whom without I could not have continued the journey to the day I witness this book alive. Thanks for always being there to support me, every single moment, with everything you can, when I was about to lose hope and trust in me being able to continue through the darkness, trying to reach the goal through long nights of mess, you were there, through long distances you were pushing me forward by your support, encouragement, guidance, and help. Thanks to ALLAH, I am really blessed with amazing family like you. I Love You all!}

\thispagestyle{empty}

\begin{flushright}
\textit{Haitham A. El-Ghareeb} \\
May, 2013
\end{flushright}

\cleardoublepage
\phantomsection
\tableofcontents

\chapter{Preface}
%\addcontentsline{toc}{chapter}{Preface}
This book contains the data I wish I have written, I wish I have learned 20 years ago, I wish I can share with everyone on earth. I am not claiming this book will be helpful for anyone, it is just a book, hopefully it is not so ordinary. What is so different about this book is this: it documents every step we take through this course, so when you come back to it, and re-read it anytime, you will feel like you are in the course room. Inchallah you will find it useful if you are new to Python community, or if you are an advanced/professional python developer. Book is organized in separate chapters, so you are welcome to start reading the book from any chapter. For any comments about the book content, please feel free to contact me.
\begin{flushright}
\textit{Haitham A. El-Ghareeb} \\
May, 2013
\end{flushright}

\mainmatter

\part{Open Source Technologies and Programming}

\chapter{Open Source: General Introduction}
\includepdf[pages={-}]{notes/foss_primer_print_covers.pdf}

\chapter{Teach yourself Programming in 10 Years}

By: Peter Norvig

\section{Why is everyone in such a rush?}

Walk into any bookstore, and you'll see how to Teach Yourself Java in 7 Days alongside endless variations offering to teach Visual Basic, Windows, the Internet, and so on in a few days or hours. I did the following power search at Amazon.com: pubdate: after 1992 and title: days and (title: learn or title: teach yourself)
and got back 248 hits. The first 78 were computer books (number 79 was Learn Bengali in 30 days). I replaced "days" with "hours" and got remarkably similar results: 253 more books, with 77 computer books followed by Teach Yourself Grammar and Style in 24 Hours at number 78. Out of the top 200 total, 96\% were computer books.
The conclusion is that either people are in a big rush to learn about computers, or that computers are somehow fabulously easier to learn than anything else. There are no books on how to learn Beethoven, or Quantum Physics, or even Dog Grooming in a few days. Felleisen et al. give a nod to this trend in their book How to Design Programs, when they say "Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.

Let's analyze what a title like Learn C++ in Three Days could mean:
\begin{itemize}
\item Learn: In 3 days you won't have time to write several significant programs, and learn from your successes and failures with them. You won't have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won't have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.
\item C++: In 3 days you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn't learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn't learn what C++ is actually good (and bad) for. So what's the point? Alan Perlis once said: "A language that doesn't affect the way you think about programming, is not worth knowing". One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Flash's Flex) because you need to interface with an existing tool to accomplish a specific task. But then you're not learning how to program; you're learning to accomplish that task.
\item in Three Days: Unfortunately, this is not enough, as the next section shows.
\end{itemize}

\section{Teach Yourself Programming in Ten Years}
Researchers (Bloom (1985), Bryan \& Harter (1899), Hayes (1989), Simmon \& Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of \#1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. Malcolm Gladwell reports that a study of students at the Berlin Academy of Music compared the top, middle, and bottom third of the class and asked them how much they had practiced:
Everyone, from all three groups, started playing at roughly the same time - around the age of five. In those first few years, everyone practised roughly the same amount - about two or three hours a week. But around the age of eight real differences started to emerge. The students who would end up as the best in their class began to practise more than everyone else: six hours a week by age nine, eight by age 12, 16 a week by age 14, and up and up, until by the age of 20 they were practising well over 30 hours a week. By the age of 20, the elite performers had all totalled 10,000 hours of practice over the course of their lives. The merely good students had totalled, by contrast, 8,000 hours, and the future music teachers just over 4,000 hours.
So it may be that 10,000 hours, not 10 years, is the magic number. (Henri Cartier-Bresson (1908-2004) said "Your first 10,000 photographs are your worst," but he shot more than one an hour.) Samuel Johnson (1709-1784) thought it took even longer: "Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price." And Chaucer (1340-1400) complained "the lyf so short, the craft so long to lerne." Hippocrates (c. 400BC) is known for the excerpt "ars longa, vita brevis", which is part of the longer quotation "Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile", which in English renders as "Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult." Although in Latin, ars can mean either art or craft, in the original Greek the word "techne" can only mean "skill", not "art".

\section{So You Want to be a Programmer}

Here's my recipe for programming success:
\begin{enumerate}
\item Get interested in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours.
\item Program. The best kind of learning is learning by doing. To put it more technically, "the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve." (p. 366) and "the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors." (p. 20-21) The book Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life is an interesting reference for this viewpoint.
\item Talk with other programmers; read other programs. This is more important than any book or training course.
\item If you want, put in four years at a college (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don't enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won't be enough. "Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter" says Eric Raymond, author of The New Hacker's Dictionary. One of the best programmers I ever hired had only a High School degree; he's produced a lot of great software, has his own news group, and made enough in stock options to buy his own nightclub.
\item Work on projects with other programmers. Be the best programmer on some projects; be the worst on some others. When you're the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you're the worst, you learn what the masters do, and you learn what they don't like to do (because they make you do it for them).
\item Work on projects after other programmers. Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you.
\item Learn at least a half dozen programming languages. Include one language that supports class abstractions (like Java or C++), one that supports functional abstraction (like Lisp or ML), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), one that supports coroutines (like Icon or Scheme), and one that supports parallelism (like Sisal).
\item Remember that there is a "computer" in "computer science". Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.)
\item Get involved in a language standardization effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so.
\item Have the good sense to get off the language standardization effort as quickly as possible.
\end{enumerate}

With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the How To books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts.
Fred Brooks, in his essay No Silver Bullet identified a three-part plan for finding great software designers:
\begin{itemize}
\item Systematically identify top designers as early as possible.
\item Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file.
\item Provide opportunities for growing designers to interact and stimulate each other.
\end{itemize}
This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. Alan Perlis put it more succinctly: "Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers". Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in Ratatouille) puts it, "anyone can cook, but only the fearless can be great." I think of it more as willingness to devote a large portion of one's life to deliberative practice. But maybe fearless is a way to summarize that. Or, as Gusteau's critic, Anton Ego, says: "Not everyone can become a great artist, but a great artist can come from anywhere."
So go ahead and buy that Java/Ruby/Javascript/PHP book; you'll probably get some use out of it. But you won't change your life, or your real overall expertise as a programmer in 24 hours, days, or even weeks. How about working hard to continually improve over 24 months? Well, now you're starting to get somewhere...

\chapter{Programming Languages Are Not The Same}
Programming languages are used for controlling the behavior of a machine (often a computer). Like natural languages, programming languages conform to rules for syntax and semantics. There are thousands of programming languages and new ones are created every year. Few languages ever become sufficiently popular that they are used by more than a few people, but professional programmers may use dozens of languages in a career. So, not to get lost between all those programming languages, there are main things we need to discuss in Programming Languages, and comparison between them.
\section{Basis for Comparing Programming Languages}
\subsection{Object Orientation}
Many languages claim to be Object-Oriented. While the exact definition of the term is highly variable, there are several qualities that most will agree an Object-Oriented language should have:
\begin{itemize}
\item Encapsulation/Information Hiding
\item Inheritance
\item Polymorphism/Dynamic Binding
\item All pre-defined types are Objects
\item All operations performed by sending messages to Objects
\item All user-defined types are Objects
\end{itemize}
A language is considered to be a "pure" Object-Oriented languages if it satisfies all of these qualities. A "hybrid" language may support some of these qualities, but not all. In particular, many languages support the first three qualities, but not the final three.

\subsection{Static vs. Dynamic Typing}
The debate between static and dynamic typing has raged in Object-Oriented circles for many years with no clear conclusion. Proponents of dynamic typing contend that it is more flexible and allows for increased productivity. Those who prefer static typing argue that it enforces safer, more reliable code, and increases efficiency of the resulting product.

Statically-typed language requires a very well-defined type system in order to remain as flexible as its dynamically-typed counterparts. Without the presence of genericity (templates) and multiple type inheritance, a static type system may severely inhibit the flexibility of a language. In addition, the presence of "casts" in a language can undermine the ability of the compiler to enforce type constraints.

A dynamic type system doesn't require variables to be declared as a specific type. Any variable can contain any value or object. In many cases this can make the software more flexible and amenable to change. However, care must be taken that variables hold the expected kind of object. Typically, if a variable contains an object of a different type than a user of the object expects, some sort of "message not understood" error is raised at run-time. Users of dynamically-typed languages claim that this type of error is infrequent in practice.

Statically-typed languages require that all variables are declared with a specific type. The compiler will then ensure that at any given time the variable contains only an object compatible with that type. (We say "compatible with that type" rather than "exactly that type" since the inheritance relationship enables subtyping, in which a class that inherits from another class is said to have an IS-A relationship with the class from which it inherits, meaning that instances of the inheriting class can be considered to be of a compatible type with instances of the inherited class.) By enforcing the type constraint on objects contained or referred to by the variable, the compiler can ensure a "message not understood" error can never occur at run-time. On the other hand, a static type system can hinder evolution of software in some circumstances. For example, if a method takes an object as a parameter, changing the type of the object requires changing the signature of the method so that it is compatible with the new type of the object being passed. If this same object is passed to many such methods, all of them must be updated accordingly, which could potentially be an arduous task. One must remember, though, that this ripple effect could occur even a dynamically-typed language. If the type of the object is not what it was originally expected to be, it may not understand the messages being sent to it. Perhaps even worse is that it could understand the message but interpret it in a way not compatible with the semantics of the calling method. A statically-typed language can flag these errors at compilation-time, pointing out the precise locations of potential errors. A user of a dynamically-typed language must rely on extensive testing to ensure that all improper uses of the object are tracked down.

\subsection{Generic Classes}
Generic classes, and more generally parametric type facilities, refer to the ability to parameterize a class with specific data types. A common example is a stack class that is parameterized by the type of elements it contains. This allows the stack to simultaneously be compile-time type safe and yet generic enough to handle any type of elements.

The primary benefit of parameterized types is that it allows statically typed languages to retain their compile-time type safety yet remain nearly as flexible as dynamically typed languages. Dynamically typed languages do not need parameterized types in order to support generic programming. Types are checked at run-time and thus dynamically typed languages support generic programming inherently.

\subsection{Inheritence}
Inheritance is the ability for a class or object to be defined as an extension or specialization of another class or object. Most object-oriented languages support class-based inheritance, while others such as SELF and JavaScript support object-based inheritance. A few languages, notably Python and Ruby, support both class- and object-based inheritance, in which a class can inherit from another class and individual objects can be extended at run time with the capabilities of other objects. 

Though there are identified and classified as many as 17 different forms of inheritance. Even so, most languages provide only a few syntactic constructs for inheritance which are general enough to allow inheritance to be used in many different ways. The most important distinction that can be made between various languages' support for inheritance is whether it supports single or multiple inheritance. Multiple inheritance is the ability for a class to inherit from more than one super (or base) class. For example, an application object called PersistentShape might inherit from both GraphicalObject and PersistentObject in order to be used as both a graphical object that can be displayed on the screen as well as a persistent object that can be stored in a database.

Multiple inheritance would appear to be an essential feature for a language to support for cases such as the above when two or more distinct hierarchies must be merged into one application domain. However, there are other issues to consider before making such an assertion.

First, we must consider that multiple inheritance introduces some complications into a programming language supporting it. Issues such as name clashes and ambiguities introduced in the object model must be resolved by the language in order for multiple inheritance and this leads to additional complexity in the language. 

Next, we must distinguish between implementation inheritance and interface/subtype inheritance. Subtype inheritance (also known loosely as interface inheritance) is the most common form of inheritance, in which a subclass is considered to be a subtype of its super class, commonly referred to as an IS-A relationship. What this means is that the language considers an object to conform to the type of its class or any of its super classes. For example, a Circle IS-A Shape, so anywhere a Shape is used in a program, a Circle may be used as well. This conformance notion is only applicable to statically typed languages since it is a feature used by the compiler to determine type correctness.

Implementation inheritance is the ability for a class to inherit part or all of its implementation from another class. For example, a Stack class that is implemented using an array might inherit from an Array class in order to define the Stack in terms of the Array. In this way, the Stack class could use any features from the Array to support its own implementation. With pure implementation inheritance, the fact that the Stack inherits its implementation from Array would not be visible to code using the Stack; the inheritance would be strictly an implementation matter. 

Returning to the issue of multiple inheritance, we can see that a language's support for multiple inheritance is not a boolean condition; a language can support one or more different forms of multiple inheritance in the same way it can support different forms of single inheritance (e.g. implementation and subtype inheritance). 

\subsection{Feature Renaming}
Feature renaming is the ability for a class or object to rename one of its features (a term used to collectively refer to attributes and methods) that it inherited from a super class. There are two important ways in which this can be put to use:
\begin{itemize}
\item Provide a feature with a more natural name for its new context
\item Resolve naming ambiguities when a name is inherited from multiple inheritance paths
\end{itemize}

\subsection{Method Overloading}
Method overloading (also referred to as parametric polymorphism) is the ability for a class, module, or other scope to have two or more methods with the same name. Calls to these methods are disambiguated by the number and/or type of arguments passed to the method at the call site. For example, a class may have multiple print methods, one for each type of thing to be printed. The alternative to overloading in this scenario is to have a different name for each print method, such as print\_string and print\_integer.

\subsection{Operator Overloading}
Operator overloading is the ability for a programmer to define an operator (such as +, or *) for user-defined types. This allows the operator to be used in infix, prefix, or postfix form, rather than the standard functional form. For example, a user-defined Matrix type might provide a * infix operator to perform matrix multiplication with the familiar notation: matrix1 * matrix2 .

Some (correctly) consider operator overloading to be mere syntactic "sugar" rather than an essential feature, while others (also correctly) point to the need for such syntactic sugar in numerical and other applications. Both points are valid, but it is clear that, when used appropriately, operator overloading can lead to much more readable programs. When abused, it can lead to cryptic, obfuscated code. Consider that in the presence of operator overloading, it may not be clear whether a given operator is built in to the language or defined by the user. For any language that supports operator overloading, two things are necessary to alleviate such obfuscation:

All operations must be messages to objects, and thus all operators are always method calls.
Operators must have an equivalent functional form, so that using the operator as a method call will behave precisely the same as using it in infix, prefix, or postfix form.

\subsection{Higher Order Functions \& Lexical Closures}
Higher order functions are, in the simplest sense, functions that can be treated as if they were data objects. In other words, they can be bound to variables (including the ability to be stored in collections), they can be passed to other functions as parameters, and they can be returned as the result of other functions. Due to this ability, higher order functions may be viewed as a form of deferred execution, wherein a function may be defined in one context, passed to another context, and then later invoked by the second context. This is different from standard functions in that higher order functions represent anonymous lambda functions, so that the invoking context need not know the name of the function being invoked.

Lexical closures (also known as static closures, or simply closures) take this one step further by bundling up the lexical (static) scope surrounding the function with the function itself, so that the function carries its surrounding environment around with it wherever it may be used. This means that the closure can access local variables or parameters, or attributes of the object in which it is defined, and will continue to have access to them even if it is passed to another module outside of its scope.

\subsection{Garbage Collection}
Garbage collection is a mechanism allowing a language implementation to free memory of unused objects on behalf of the programmer, thus relieving the burden on the programmer to do so. The alternative is for the programmer to explicitly free any memory that is no longer needed. There are several strategies for garbage collection that exist in various language implementations.
\subsubsection{Reference Counting}
Reference counting is the simplest scheme and involves the language keeping track of how many references there are to a particular object in memory, and deleting that object when that reference count becomes zero. This scheme, although it is simple and deterministic, is not without its drawbacks, the most important being its inability to handle cycles. Cycles occur when two objects reference each other, and thus there reference counts will never become zero even if neither object is referenced by any other part of the program.
\subsubsection{Mark and Sweep}
"Mark and sweep" garbage collection is another scheme that overcomes this limitation. A mark and sweep garbage collector works in a two phase process, known as the mark phase and the sweep phase. The mark phase works by first starting at the "root" objects (objects on the stack, global objects, etc.), marking them as live, and recursively marking any objects referenced from them. These marked objects are the set of live objects in program, and any objects that were not marked in this phase are unreferenced and therefore candidates for collection. In the sweep phase, any objects in memory that were not marked as live by the mark phase are deleted from memory. The primary drawback of mark and sweep collection is that it is non-deterministic, meaning that objects are deleted at an unspecified time during the execution of the program. This is the most common form of garbage collection.
\subsubsection{Generational}
Generational garbage collection works in a similar fashion to mark and sweep garbage collection, except it capitalizes on the statistical probability that objects that have been alive the longest tend to stay alive longer than objects that were newly created. Thus a generational garbage collector will divide objects into "generations" based upon how long they've been alive. This division can be used to reduce the time spent in the mark and sweep phases because the oldest generation of objects will not need to be collected as frequently. Generational garbage collectors are not as common as the other forms.

\subsection{Uniform Access}
The Uniform Access Principle, states that "All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation." It is described further with "Although it may at first appear just to address a notational issue, the Uniform Access principle is in fact a design rule which influences many aspects of object-oriented design and the supporting notation. It follows from the Continuity criterion; you may also view it as a special case of Information Hiding."

Say that \texttt{teach} is a feature of a class named \texttt{Professor}. For languages that do not support the Uniform Access Principle, the notation used to access \texttt{teach} differs depending on whether it is an attribute (storage) or a function (computation). For example, in Java we would use \texttt{Professor.teach} if it were an attribute, but we would use \texttt{Professor.teach()} if it were a function. Having this notational difference means that users of \texttt{Professor} are exposed to unnecessary implementation details and are tightly coupled to \texttt{Professor}. If \texttt{teach} is changed from attribute to method (or vice versa), then any users of \texttt{Professor} must also be changed.

The Uniform Access Principle seeks to eliminate this needless coupling. A language supporting the Uniform Access Principle does not exhibit any notational differences between accessing a feature regardless of whether it is an attribute or a function. Thus, in our earlier example, access to bar would always be in the form of foo.bar, regardless of how bar is implemented. This makes clients of Foo more resilient to change.

\subsection{Class Variables/Methods}
Class variables and methods are owned by a class, and not any particular instance of a class. This means that for however many instances of a class exist at any given point in time, only one copy of each class variable/method exists and is shared by every instance of the class.

\subsection{Reflection}
Reflection is the ability for a program to determine various pieces of information about an object at run-time. This includes the ability to determine the type of the object, its inheritance structure, and the methods it contains, including the number and types of parameters and return types. It might also include the ability for determining the names and types of attributes of the object. Most object-oriented languages support some form of reflection.

\subsection{Access Control}
Access control refers to the ability for a modules implementation to remain hidden behind its public interface. Access control is closely related to the encapsulation/information hiding principle of object-oriented languages. For example, a class \texttt{Professor} may have methods such as \texttt{name} and \texttt{email}, that return the professor's name and e-mail address respectively. How these methods work is an implementation detail that should not be available to users of the \texttt{Person} class. These methods may, for example, connect to a database to retrieve the values. The database connection code that is used to do this is not relevant to client code and should not be exposed. Language-enforced access control allows us to enforce this.
Most object-oriented languages provide at least two levels of access control: public and protected. Protected features are not available outside of the class in which they are contained, except for subclasses. Some languages, notably Java and C++, provide a third level of access control known as "private". Private features are not available outside of the class in which they are declared, even for subclasses. Note, however, that this means that objects of a particular class can access the private features of other objects of that same class. Java provides a fourth level of, known as "package private" access control which allows other classes in the same package to access such features.

\subsection{Design by Contract}
Design by Contract (DBC) is the ability to incorporate important aspects of a specification into the software that is implementing it. The most important features of DBC are:
\begin{itemize}
\item Pre-conditions, which are conditions that must be true before a method is invoked
\item Post-conditions, which are conditions guaranteed to be true after the invocation of a method
\item Invariants, which are conditions guaranteed to be true at any stable point during the lifetime of an object
\end{itemize}
There is much more to DBC than these simple facilities, including the manner in which pre-conditions, post-conditions, and invariants are inherited. However, at least these facilities must be present to support the central notions of DBC.

\subsection{Multithreading}
Multithreading is the ability for a single process to process two or more tasks concurrently. (We say concurrently rather than simultaneously because, in the absence of multiple processors, the tasks cannot run simultaneously but rather are interleaved in very small time slices and thus exhibit the appearance and semantics of concurrent execution.) The use of multithreading is becoming increasingly more common as operating system support for threads has become near ubiquitous.

\subsection{Regular Expressions}
Regular expressions are pattern matching constructs capable of recognizing the class of languages known as regular languages. They are frequently used for text processing systems as well as for general applications that must use pattern recognition for other purposes. Libraries with regular expression support exist for nearly every language, however it has become increasingly important for a language to support regular expressions natively. This allows tighter integration with the rest of the language and allows more convenient syntax for use of regular expressions. 

\subsection{Pointer Arithmetic}
Pointer arithmetic is the ability for a language to directly manipulate memory addresses and their contents. While, due to the inherent unsafety of direct memory manipulation, this ability is not often considered appropriate for high-level languages, it is essential for low-level systems applications. Thus, while object-oriented languages strive to remain at a fairly high level of abstraction, to be suitable for systems programming a language must provide such features or relegate such low-level tasks to a language with which it can interact. Most object-oriented languages have foregone support of pointer arithmetic in favor of providing integration with C. This allows low-level routines to be implemented in C while the majority of the application is written in the higher level language. C++ on the other hand provides direct support for pointer arithmetic, both for compatibility with C and to allow C++ to be used for systems programming without the need to drop down to a lower level language. This is the source both of C++'s great flexibility as well as much of its complexity.

\subsection{Language Integration}
For various reasons, including integration with existing systems, the need to interact with low level modules. It is important for a high level language (particularly interpreted languages) to be able to integrate seamlessly with other languages. Nearly every language to come along since C was first introduced provides such integration with C. This allows high level languages to remain free of the low level constructs that make C great for systems programming, but add much complexity.

\subsection{Built-In Security}
Built-in security refers to a language implementation's ability to determine whether or not a piece of code comes from a "trusted" source (such as the user's hard disk), limiting the permissions of the code if it does not. For example, Java applets are considered untrusted, and thus they are limited in the actions they can perform when executed from a user's browser. They may not, for example, read or write from or to the user's hard disk, and they may not open a network connection to anywhere but the originating host.

\section{Comparing based on Performance and Optimization}
Based on the previous basis for comparing programming languages, and because there are thousands of them, it is almost impossible to provide a comprehensive list of such features here. You, dear student, is encouraged to continue reserach in this point, and you are welcome to introduce such comparison between different programming lanuages of your choice in a report. Recent Google research \cite{Robert-Google} presents an important comparison between different programming languages. Through this important presented benchmark, differences between programming languages become clear. In this experience report, researcher encoded a well specified, compact benchmark in four programming languages, namely C++, Java, Go, and Scala. The implementations each use the languages' idiomatic container classes, looping constructs, and memory/object allocation schemes. It does not attempt to exploit specific language and run-time features to achieve maximum performance. This approach allows an almost fair comparison of language features, code complexity, compilers and compile time, binary sizes, run-times, and memory footprint. While the benchmark itself is simple and compact, it employs many language features, in particular, higher-level data structures (lists, maps, lists and arrays of sets and lists), a few algorithms (union/ find, dfs/deep recursion, and loop recognition based on Tarjan), iterations over collection types, some object oriented features, and interesting memory allocation patterns. Researcher did not explore any aspects of multi-threading, or higher level  type mechanisms, which vary greatly between the languages. The benchmark points to very large differences in all examined dimensions of the language implementations. After publication of the benchmark internally at Google, several engineers produced highly optimized versions of the benchmark. Researcher ound that in regards to performance, C++ wins out by a large margin. However, it also required the most extensive tuning efforts, many of which were done at a level of sophistication that would not be available to the average programmer. Scala concise notation and powerful language features allowed for the best optimization of code complexity. The Java version was probably the simplest to implement, but the hardest to analyze for performance. Specifically the effects around garbage collection were complicated and very hard to tune. Since Scala runs on the JVM, it has the same issues. Go offers interesting language features, which also allow for a concise and standardized notation. The compilers for this language are still immature, which reflects in both performance and binary sizes.

%\chapter{Python for Programmers}
%\includepdf[pages={-}]{notes/alex.pdf}

\part{Python Basics}

\chapter{Python Tutorial}
\includepdf[pages={-}]{notes/python_basics_notes.pdf}

\part{Advanced Python Features}
\chapter{Advanced Python}
%will include additions from my ITI Python Slides Tutorial
%Topics to be added include:
% List Comprehension, Functional Programming, etc. 
\includepdf[pages={-}]{notes/python_advanced_1.pdf}
\includepdf[pages={-}]{notes/python_advanced_2.pdf}
\includepdf[pages={-}]{notes/ITI-Python-Advanced-Features.pdf}

%\chapter{Object Oriented Python Concepts}
%\includepdf[pages={166-184}]{notes/project.pdf}

\part{Object Oriented Python}
\chapter{Classes and objects}

Code examples from this chapter are available from
\url{http://thinkpython.com/code/Point1.py}; solutions
to the exercises are available from
\url{http://thinkpython.com/code/Point1_soln.py}.


\section{User-defined types}
\label{point}
\index{user-defined type}
\index{type!user-defined}

We have used many of Python's built-in types; now we are going
to define a new type.  As an example, we will create a type
called {\tt Point} that represents a point in two-dimensional
space.
\index{point, mathematical}

In mathematical notation, points are often written in
parentheses with a comma separating the coordinates. For example,
$(0,0)$ represents the origin, and $(x,y)$ represents the
point $x$ units to the right and $y$ units up from the origin.

There are several ways we might represent points in Python:

\begin{itemize}

\item We could store the coordinates separately in two
variables, {\tt x} and {\tt y}.

\item We could store the coordinates as elements in a list
or tuple.

\item We could create a new type to represent points as
objects.

\end{itemize}
\index{representation}

Creating a new type
is (a little) more complicated than the other options, but
it has advantages that will be apparent soon.

A user-defined type is also called a {\bf class}.
A class definition looks like this:
\index{class}
\index{object}
\index{class definition}
\index{definition!class}

\begin{verbatim}
class Point(object):
    """Represents a point in 2-D space."""
\end{verbatim}
%
This header indicates that the new class is a {\tt Point},
which is a kind of {\tt object}, which is a built-in
type.
\index{Point class}
\index{class!Point}

The body is a docstring that explains what the class is for.
You can define variables and functions inside a class definition,
but we will get back to that later.
\index{docstring}

Defining a class named {\tt Point} creates a class object.

\begin{verbatim}
>>> print Point
<class '__main__.Point'>
\end{verbatim}
%
Because {\tt Point} is defined at the top level, its ``full
name'' is \verb"__main__.Point".
\index{object!class}
\index{class object}

The class object is like a factory for creating objects.  To create a
Point, you call {\tt Point} as if it were a function.

\begin{verbatim}
>>> blank = Point()
>>> print blank
<__main__.Point instance at 0xb7e9d3ac>
\end{verbatim}
%
The return value is a reference to a Point object, which we
assign to {\tt blank}.  
Creating a new object is called
{\bf instantiation}, and the object is an {\bf instance} of
the class.
\index{instance}
\index{instantiation}

When you print an instance, Python tells you what class it
belongs to and where it is stored in memory (the prefix
{\tt 0x} means that the following number is in hexadecimal).
\index{hexadecimal}


\section{Attributes}
\label{attributes}
\index{instance attribute}
\index{attribute!instance}
\index{dot notation}

You can assign values to an instance using dot notation:

\begin{verbatim}
>>> blank.x = 3.0
>>> blank.y = 4.0
\end{verbatim}
%
This syntax is similar to the syntax for selecting a variable from a
module, such as {\tt math.pi} or {\tt string.whitespace}.  In this case,
though, we are assigning values to named elements of an object.
These elements are called {\bf attributes}.

As a noun, ``AT-trib-ute'' is pronounced with emphasis on the first
syllable, as opposed to ``a-TRIB-ute,'' which is a verb.

The following diagram shows the result of these assignments.
A state diagram that shows an object and its attributes is
called an {\bf object diagram}; see Figure~\ref{fig.point}.
\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/point.pdf}}
\caption{Object diagram.}
\label{fig.point}
\end{figure}


The variable {\tt blank} refers to a Point object, which
contains two attributes.  Each attribute refers to a
floating-point number.

You can read the value of an attribute using the same syntax:

\begin{verbatim}
>>> print blank.y
4.0
>>> x = blank.x
>>> print x
3.0
\end{verbatim}
%
The expression {\tt blank.x} means, ``Go to the object {\tt blank}
refers to and get the value of {\tt x}.'' In this case, we assign that
value to a variable named {\tt x}.  There is no conflict between
the variable {\tt x} and the attribute {\tt x}.

You can use dot notation as part of any expression.  For example:

\begin{verbatim}
>>> print '(%g, %g)' % (blank.x, blank.y)
(3.0, 4.0)
>>> distance = math.sqrt(blank.x**2 + blank.y**2)
>>> print distance
5.0
\end{verbatim}
%
You can pass an instance as an argument in the usual way.
For example:
\index{instance!as argument}

\begin{verbatim}
def print_point(p):
    print '(%g, %g)' % (p.x, p.y)
\end{verbatim}
%
\verb"print_point" takes a point as an argument and displays it in
mathematical notation.  To invoke it, you can pass {\tt blank} as
an argument:

\begin{verbatim}
>>> print_point(blank)
(3.0, 4.0)
\end{verbatim}
%
Inside the function, {\tt p} is an alias for {\tt blank}, so if
the function modifies {\tt p}, {\tt blank} changes.
\index{aliasing}


\begin{exercise}

Write a function called \verb"distance_between_points" that takes two
Points as arguments and returns the distance between them.

\end{exercise}



\section{Rectangles}
\label{rectangles}

Sometimes it is obvious what the attributes of an object should be,
but other times you have to make decisions.  For example, imagine you
are designing a class to represent rectangles.  What attributes would
you use to specify the location and size of a rectangle?  You can
ignore angle; to keep things simple, assume that the rectangle is
either vertical or horizontal.
\index{representation}

There are at least two possibilities: 

\begin{itemize}

\item You could specify one corner of the rectangle
(or the center), the width, and the height.

\item You could specify two opposing corners.

\end{itemize}

At this point it is hard to say whether either is better than
the other, so we'll implement the first one, just as an example.
\index{Rectangle class}
\index{class!Rectangle}

Here is the class definition:

\begin{verbatim}
class Rectangle(object):
    """Represents a rectangle. 

    attributes: width, height, corner.
    """
\end{verbatim}
%
The docstring lists the attributes:  {\tt width} and
{\tt height} are numbers; {\tt corner} is a Point object that
specifies the lower-left corner.

To represent a rectangle, you have to instantiate a Rectangle
object and assign values to the attributes:

\begin{verbatim}
box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
\end{verbatim}
%
The expression {\tt box.corner.x} means,
``Go to the object {\tt box} refers to and select the attribute named
{\tt corner}; then go to that object and select the attribute named
{\tt x}.''

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/rectangle.pdf}}
\caption{Object diagram.}
\label{fig.rectangle}
\end{figure}


Figure~\ref{fig.rectangle} shows the state of this object.
\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}
An object that is an attribute of another object is {\bf embedded}.
\index{embedded object}
\index{object!embedded}


\section{Instances as return values}
\index{instance!as return value}
\index{return value}

Functions can return instances.  For example, \verb"find_center"
takes a {\tt Rectangle} as an argument and returns a {\tt Point}
that contains the coordinates of the center of the {\tt Rectangle}:

\begin{verbatim}
def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2.0
    p.y = rect.corner.y + rect.height/2.0
    return p
\end{verbatim}
%
Here is an example that passes {\tt box} as an argument and assigns
the resulting Point to {\tt center}:

\begin{verbatim}
>>> center = find_center(box)
>>> print_point(center)
(50.0, 100.0)
\end{verbatim}
%

\section{Objects are mutable}
\index{object!mutable}
\index{mutability}

You can change the state of an object by making an assignment to one of
its attributes.  For example, to change the size of a rectangle
without changing its position, you can modify the values of {\tt
width} and {\tt height}:

\begin{verbatim}
box.width = box.width + 50
box.height = box.width + 100
\end{verbatim}
%
You can also write functions that modify objects.  For example,
\verb"grow_rectangle" takes a Rectangle object and two numbers,
{\tt dwidth} and {\tt dheight}, and adds the numbers to the
width and height of the rectangle:

\begin{verbatim}
def grow_rectangle(rect, dwidth, dheight):
    rect.width += dwidth
    rect.height += dheight
\end{verbatim}
%
Here is an example that demonstrates the effect:

\begin{verbatim}
>>> print box.width
100.0
>>> print box.height
200.0
>>> grow_rectangle(box, 50, 100)
>>> print box.width
150.0
>>> print box.height
300.0
\end{verbatim}
%
Inside the function, {\tt rect} is an
alias for {\tt box}, so if the function modifies {\tt rect}, 
{\tt box} changes.

\begin{exercise}

Write a function named \verb"move_rectangle" that takes
a Rectangle and two numbers named {\tt dx} and {\tt dy}.  It
should change the location of the rectangle by adding {\tt dx}
to the {\tt x} coordinate of {\tt corner} and adding {\tt dy}
to the {\tt y} coordinate of {\tt corner}.

\end{exercise}


\section{Copying}
\label{copying}
\index{aliasing}

Aliasing can make a program difficult to read because changes
in one place might have unexpected effects in another place.
It is hard to keep track of all the variables that might refer
to a given object.
\index{copying objects}
\index{object!copying}
\index{copy module}
\index{module!copy}

Copying an object is often an alternative to aliasing.
The {\tt copy} module contains a function called {\tt copy} that
can duplicate any object:

\begin{verbatim}
>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0

>>> import copy
>>> p2 = copy.copy(p1)
\end{verbatim}
%
{\tt p1} and {\tt p2} contain the same data, but they are
not the same Point.

\begin{verbatim}
>>> print_point(p1)
(3.0, 4.0)
>>> print_point(p2)
(3.0, 4.0)
>>> p1 is p2
False
>>> p1 == p2
False
\end{verbatim}
%
The {\tt is} operator indicates that {\tt p1} and {\tt p2} are not the
same object, which is what we expected.  But you might have expected
{\tt ==} to yield {\tt True} because these points contain the same
data.  In that case, you will be disappointed to learn that for
instances, the default behavior of the {\tt ==} operator is the same
as the {\tt is} operator; it checks object identity, not object
equivalence.  This behavior can be changed---we'll see how later.
\index{is operator}
\index{operator!is}

If you use {\tt copy.copy} to duplicate a Rectangle, you will find
that it copies the Rectangle object but not the embedded Point.
\index{embedded object!copying}

\begin{verbatim}
>>> box2 = copy.copy(box)
>>> box2 is box
False
>>> box2.corner is box.corner
True
\end{verbatim}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/rectangle2.pdf}}
\caption{Object diagram.}
\label{fig.rectangle2}
\end{figure}

Figure~\ref{fig.rectangle2} shows what the object diagram looks like.
\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}
This operation is called a {\bf shallow copy} because it copies the
object and any references it contains, but not the embedded objects.
\index{shallow copy}
\index{copy!shallow}

For most applications, this is not what you want.  In this example,
invoking \verb"grow_rectangle" on one of the Rectangles would not
affect the other, but invoking \verb"move_rectangle" on either would
affect both!  This behavior is confusing and error-prone.
\index{deep copy}
\index{copy!deep}

Fortunately, the {\tt copy} module contains a method named {\tt
deepcopy} that copies not only the object but also 
the objects it refers to, and the objects {\em they} refer to,
and so on.
You will not be surprised to learn that this operation is
called a {\bf deep copy}.
\index{deepcopy function}
\index{function!deepcopy}

\begin{verbatim}
>>> box3 = copy.deepcopy(box)
>>> box3 is box
False
>>> box3.corner is box.corner
False
\end{verbatim}
%
{\tt box3} and {\tt box} are completely separate objects.


\begin{exercise}

Write a version of \verb"move_rectangle" that creates and
returns a new Rectangle instead of modifying the old one.

\end{exercise}


\section{Debugging}
\label{hasattr}
\index{debugging}

When you start working with objects, you are likely to encounter
some new exceptions.  If you try to access an attribute
that doesn't exist, you get an {\tt AttributeError}:
\index{exception!AttributeError}
\index{AttributeError}

\begin{verbatim}
>>> p = Point()
>>> print p.z
AttributeError: Point instance has no attribute 'z'
\end{verbatim}
%
If you are not sure what type an object is, you can ask:
\index{type function}
\index{function!type}

\begin{verbatim}
>>> type(p)
<type '__main__.Point'>
\end{verbatim}
%
If you are not sure whether an object has a particular attribute,
you can use the built-in function {\tt hasattr}:
\index{hasattr function}
\index{function!hasattr}

\begin{verbatim}
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
\end{verbatim}
%
The first argument can be any object; the second argument is a {\em
string} that contains the name of the attribute.


\section{Glossary}

\begin{description}

\item[class:] A user-defined type.  A class definition creates a new
class object.
\index{class}

\item[class object:] An object that contains information about a
user-defined type.  The class object can be used to create instances
of the type.
\index{class object}
\index{object!class}

\item[instance:] An object that belongs to a class.
\index{instance}

\item[attribute:] One of the named values associated with an object.
\index{attribute!instance}
\index{instance attribute}

\item[embedded (object):] An object that is stored as an attribute
of another object.
\index{embedded object}
\index{object!embedded}

\item[shallow copy:] To copy the contents of an object, including
any references to embedded objects;
implemented by the {\tt copy} function in the {\tt copy} module.
\index{shallow copy}

\item[deep copy:] To copy the contents of an object as well as any
embedded objects, and any objects embedded in them, and so on;
implemented by the {\tt deepcopy} function in the {\tt copy} module.
\index{deep copy}

\item[object diagram:] A diagram that shows objects, their
attributes, and the values of the attributes.
\index{object diagram}
\index{diagram!object}

\end{description}


\section{Exercises}

\begin{exercise}
\label{canvas}
\index{Swampy}
\index{World module}
\index{module!World}

Swampy (see Chapter~\ref{turtlechap}) provides a module named {\tt
  World}, which defines a user-defined type also called {\tt World}.
You can import it like this:

\begin{verbatim}
from swampy.World import World
\end{verbatim}

Or, depending on how you installed Swampy, like this:

\begin{verbatim}
from World import World
\end{verbatim}

The following code creates a World object and calls
the {\tt mainloop} method, which
waits for the user.

\begin{verbatim}
world = World()
world.mainloop()
\end{verbatim}

A window should appear with a title bar and an empty square.
We will use this window to draw Points,
Rectangles and other shapes.  
Add the following lines before calling
\verb"mainloop" and run the program again.
\index{Canvas object}
\index{object!Canvas}

\begin{verbatim}
canvas = world.ca(width=500, height=500, background='white')
bbox = [[-150,-100], [150, 100]]
canvas.rectangle(bbox, outline='black', width=2, fill='green4')
\end{verbatim}

You should see a green rectangle with a black outline.
The first line creates a Canvas, which appears in the window
as a white square.  The Canvas object provides methods like
{\tt rectangle} for drawing various shapes.
\index{bounding box}

{\tt bbox} is a list of lists that represents the ``bounding box''
of the rectangle.  The first pair of coordinates is the lower-left
corner of the rectangle; the second pair is the upper-right corner.

You can draw a circle like this:

\begin{verbatim}
canvas.circle([-25,0], 70, outline=None, fill='red')
\end{verbatim}

The first parameter is the coordinate pair for the center of the
circle; the second parameter is the radius.

If you add this line to the program, 
the result should resemble the national flag of Bangladesh
(see \url{http://en.wikipedia.org/wiki/Gallery_of_sovereign-state_flags}).
\index{Bangladesh, national flag}

\begin{enumerate}

\item Write a function called \verb"draw_rectangle" that takes a
  Canvas and a Rectangle as arguments and draws a
  representation of the Rectangle on the Canvas.

\item Add an attribute named {\tt color} to your Rectangle objects and
  modify \verb"draw_rectangle" so that it uses the color attribute as
  the fill color.

\item Write a function called \verb"draw_point" that takes a
  Canvas and a Point as arguments and draws a
  representation of the Point on the Canvas.

\item Define a new class called Circle with appropriate attributes and
  instantiate a few Circle objects.  Write a function called
  \verb"draw_circle" that draws circles on the canvas.
\index{Czech Republic, national flag}

\item Write a program that draws the national flag of the Czech Republic.
Hint: you can draw a polygon like this:

\begin{verbatim}
points = [[-150,-100], [150, 100], [150, -100]]
canvas.polygon(points, fill='blue')
\end{verbatim}

\end{enumerate}
\index{color list}
\index{available colors}

I have written a small program that lists the available colors;
you can download it from \url{http://thinkpython.com/code/color_list.py}.

\end{exercise}


\chapter{Classes and functions}
\label{time}

Code examples from this chapter are available from
\url{http://thinkpython.com/code/Time1.py}.

\section{Time}
\label{time.object}

As another example of a user-defined type, we'll define a class called
{\tt Time} that records the time of day.  The class definition looks
like this:
\index{user-defined type}
\index{type!user-defined}
\index{Time class}
\index{class!Time}

\begin{verbatim}
class Time(object):
    """Represents the time of day.
       
    attributes: hour, minute, second
    """
\end{verbatim}
%
We can create a new {\tt Time} object and assign
attributes for hours, minutes, and seconds:

\begin{verbatim}
time = Time()
time.hour = 11
time.minute = 59
time.second = 30
\end{verbatim}
%
The state diagram for the {\tt Time} object looks like Figure~\ref{fig.time}.
\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}

\begin{exercise}
\label{ex.printtime}

Write a function called \verb"print_time" that takes a 
Time object and prints it in the form {\tt hour:minute:second}.
Hint: the format sequence \verb"'%.2d'" prints an integer using
at least two digits, including a leading zero if necessary.

\end{exercise}

\begin{exercise}
\label{isafter}
\index{boolean function}

Write a boolean function called \verb"is_after" that
takes two Time objects, {\tt t1} and {\tt t2}, and
returns {\tt True} if {\tt t1} follows {\tt t2} chronologically and
{\tt False} otherwise.  Challenge: don't use an {\tt if} statement.
\end{exercise}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/time.pdf}}
\caption{Object diagram.}
\label{fig.time}
\end{figure}


\section{Pure functions}
\index{prototype and patch}
\index{development plan!prototype and patch}

In the next few sections, we'll write two functions that add time
values.  They demonstrate two kinds of functions: pure functions and
modifiers.  They also demonstrate a development plan I'll call {\bf
  prototype and patch}, which is a way of tackling a complex problem
by starting with a simple prototype and incrementally dealing with the
complications.

Here is a simple prototype of \verb"add_time":

\begin{verbatim}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    return sum
\end{verbatim}
%
The function creates a new {\tt Time} object, initializes its
attributes, and returns a reference to the new object.  This is called
a {\bf pure function} because it does not modify any of the objects
passed to it as arguments and it has no effect,
like displaying a value or getting user input, 
other than returning a value.
\index{pure function}
\index{function type!pure}

To test this function, I'll create two Time objects: {\tt start}
contains the start time of a movie, like {\em Monty Python and the
Holy Grail}, and {\tt duration} contains the run time of the movie,
which is one hour 35 minutes.
\index{Monty Python and the Holy Grail}

\verb"add_time" figures out when the movie will be done.

\begin{verbatim}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second =  0

>>> duration = Time()
>>> duration.hour = 1
>>> duration.minute = 35
>>> duration.second = 0

>>> done = add_time(start, duration)
>>> print_time(done)
10:80:00
\end{verbatim}
%
The result, {\tt 10:80:00} might not be what you were hoping
for.  The problem is that this function does not deal with cases where the
number of seconds or minutes adds up to more than sixty.  When that
happens, we have to ``carry'' the extra seconds into the minute column
or the extra minutes into the hour column.
\index{carrying, addition with}

Here's an improved version:

\begin{verbatim}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second

    if sum.second >= 60:
        sum.second -= 60
        sum.minute += 1

    if sum.minute >= 60:
        sum.minute -= 60
        sum.hour += 1

    return sum
\end{verbatim}
%
Although this function is correct, it is starting to get big.
We will see a shorter alternative later.


\section{Modifiers}
\label{increment}
\index{modifier}
\index{function type!modifier}

Sometimes it is useful for a function to modify the objects it gets as
parameters.  In that case, the changes are visible to the caller.
Functions that work this way are called {\bf modifiers}.
\index{increment}

{\tt increment}, which adds a given number of seconds to a {\tt Time}
object, can be written naturally as a
modifier.  Here is a rough draft:

\begin{verbatim}
def increment(time, seconds):
    time.second += seconds

    if time.second >= 60:
        time.second -= 60
        time.minute += 1

    if time.minute >= 60:
        time.minute -= 60
        time.hour += 1
\end{verbatim}
%
The first line performs the basic operation; the remainder deals
with the special cases we saw before.
\index{special case}

Is this function correct?  What happens if the parameter {\tt seconds}
is much greater than sixty?  

In that case, it is not enough to carry
once; we have to keep doing it until {\tt time.second} is less than sixty.
One solution is to replace the {\tt if} statements with {\tt while}
statements.  That would make the function correct, but not
very efficient.

\begin{exercise}

Write a correct version of {\tt increment} that
doesn't contain any loops.

\end{exercise}

Anything that can be done with modifiers can also be done with pure
functions.  In fact, some programming languages only allow pure
functions.  There is some evidence that programs that use pure
functions are faster to develop and less error-prone than programs
that use modifiers.  But modifiers are convenient at times,
and functional programs tend to be less efficient.

In general, I recommend that you write pure functions whenever it is
reasonable and resort to modifiers only if there is a compelling
advantage.  This approach might be called a {\bf functional
programming style}.
\index{functional programming style}


\begin{exercise}

Write a ``pure'' version of {\tt increment} that creates and returns
a new Time object rather than modifying the parameter.

\end{exercise}


\section{Prototyping versus planning}
\label{prototype}
\index{prototype and patch}
\index{development plan!prototype and patch}
\index{planned development}
\index{development plan!planned}

The development plan I am demonstrating is called ``prototype and
patch.''  For each function, I wrote a prototype that performed the
basic calculation and then tested it, patching errors along the
way.

This approach can be effective, especially if you don't yet have a
deep understanding of the problem.  But incremental corrections can
generate code that is unnecessarily complicated---since it deals with
many special cases---and unreliable---since it is hard to know if you
have found all the errors.

An alternative is {\bf planned development}, in which high-level
insight into the problem can make the programming much easier.  In
this case, the insight is that a Time object is really a three-digit
number in base 60 (see \url{http://en.wikipedia.org/wiki/Sexagesimal}.)!  The
{\tt second} attribute is the ``ones column,'' the {\tt minute}
attribute is the ``sixties column,'' and the {\tt hour} attribute is
the ``thirty-six hundreds column.''
\index{sexagesimal}

When we wrote \verb"add_time" and {\tt increment}, we were effectively
doing addition in base 60, which is why we had to carry from one
column to the next.
\index{carrying, addition with}

This observation suggests another approach to the whole problem---we
can convert Time objects to integers and take advantage of the fact
that the computer knows how to do integer arithmetic.  

Here is a function that converts Times to integers:

\begin{verbatim}
def time_to_int(time):
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
    return seconds
\end{verbatim}
%
And here is the function that converts integers to Times
(recall that {\tt divmod} divides the first argument by the second
and returns the quotient and remainder as a tuple).
\index{divmod}

\begin{verbatim}
def int_to_time(seconds):
    time = Time()
    minutes, time.second = divmod(seconds, 60)
    time.hour, time.minute = divmod(minutes, 60)
    return time
\end{verbatim}
%
You might have to think a bit, and run some tests, to convince
yourself that these functions are correct.  One way to test them is to
check that \verb"time_to_int(int_to_time(x)) == x" for many values of
{\tt x}.  This is an example of a consistency check.
\index{consistency check}

Once you are convinced they are correct, you can use them to 
rewrite \verb"add_time":

\begin{verbatim}
def add_time(t1, t2):
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
%
This version is shorter than the original, and easier to verify.

\begin{exercise}

Rewrite {\tt increment} using \verb"time_to_int" and \verb"int_to_time".

\end{exercise}

In some ways, converting from base 60 to base 10 and back is harder
than just dealing with times.  Base conversion is more abstract; our
intuition for dealing with time values is better.

But if we have the insight to treat times as base 60 numbers and make
the investment of writing the conversion functions (\verb"time_to_int"
and \verb"int_to_time"), we get a program that is shorter, easier to
read and debug, and more reliable.

It is also easier to add features later.  For example, imagine
subtracting two Times to find the duration between them.  The
naive approach would be to implement subtraction with borrowing.
Using the conversion functions would be easier and more likely to be
correct.
\index{subtraction with borrowing}
\index{borrowing, subtraction with}
\index{generalization}

Ironically, sometimes making a problem harder (or more general) makes it
easier (because there are fewer special cases and fewer opportunities
for error).


\section{Debugging}
\index{debugging}

A Time object is well-formed if the values of {\tt minute} and {\tt
second} are between 0 and 60 (including 0 but not 60) and if 
{\tt hour} is positive.  {\tt hour} and {\tt minute} should be
integral values, but we might allow {\tt second} to have a
fraction part.
\index{invariant}

Requirements like these are called {\bf invariants} because
they should always be true.  To put it a different way, if they
are not true, then something has gone wrong.

Writing code to check your invariants can help you detect errors
and find their causes.  For example, you might have a function
like \verb"valid_time" that takes a Time object and returns
{\tt False} if it violates an invariant:

\begin{verbatim}
def valid_time(time):
    if time.hour < 0 or time.minute < 0 or time.second < 0:
        return False
    if time.minute >= 60 or time.second >= 60:
        return False
    return True
\end{verbatim}
%
Then at the beginning of each function you could check the
arguments to make sure they are valid:
\index{raise statement}
\index{statement!raise}

\begin{verbatim}
def add_time(t1, t2):
    if not valid_time(t1) or not valid_time(t2):
        raise ValueError, 'invalid Time object in add_time'
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
%
Or you could use an {\tt assert} statement, which checks a given invariant
and raises an exception if it fails:
\index{assert statement}
\index{statement!assert}

\begin{verbatim}
def add_time(t1, t2):
    assert valid_time(t1) and valid_time(t2)
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
%
{\tt assert} statements are useful because they distinguish
code that deals with normal conditions from code
that checks for errors.


\section{Glossary}

\begin{description}

\item[prototype and patch:] A development plan that involves
writing a rough draft of a program, testing, and correcting errors as
they are found.
\index{prototype and patch}

\item[planned development:] A development plan that involves
high-level insight into the problem and more planning than incremental
development or prototype development.
\index{planned development}

\item[pure function:] A function that does not modify any of the objects it
receives as arguments.  Most pure functions are fruitful.
\index{pure function}

\item[modifier:] A function that changes one or more of the objects it
receives as arguments.  Most modifiers are fruitless.
\index{modifier}

\item[functional programming style:] A style of program design in which the
majority of functions are pure.
\index{functional programming style}

\item[invariant:] A condition that should always be true during the
execution of a program.
\index{invariant}

\end{description}


\section{Exercises}

Code examples from this chapter are available from
\url{http://thinkpython.com/code/Time1.py}; solutions to these
exercises are available from \url{http://thinkpython.com/code/Time1_soln.py}.

\begin{exercise}

Write a function called \verb"mul_time" that takes a Time object
and a number and returns a new Time object that contains
the product of the original Time and the number.

Then use \verb"mul_time" to write a function that takes a Time
object that represents the finishing time in a race, and a number
that represents the distance, and returns a Time object that represents
the average pace (time per mile).
\index{running pace}

\end{exercise}

%\begin{exercise}
%\index{Date class}
%\index{class!Date}

%Write a class definition for a Date object that has attributes {\tt
%  day}, {\tt month} and {\tt year}.  Write a function called
%\verb"increment_date" that takes a Date object, {\tt date} and an
%integer, {\tt n}, and returns a new Date object that
%represents the day {\tt n} days after {\tt date}.  Hint:
%``Thirty days hath September...''  Challenge: does your function
%deal with leap years correctly?  See \url{http://en.wikipedia.org/wiki/Leap_year}.

%\end{exercise}


\begin{exercise}
\index{datetime module}
\index{module!datetime}

The {\tt datetime} module provides {\tt date} and {\tt time} objects
that are similar to the Date and Time objects in this chapter, but
they provide a rich set of methods and operators.  Read the
documentation at \url{docs.python.org/lib/datetime-date.html}.

\begin{enumerate}

\item Use the {\tt datetime} module to write a program that gets the
  current date and prints the day of the week.
\index{birthday}

\item Write a program that takes a birthday as input and prints the
  user's age and the number of days, hours, minutes and seconds until
  their next birthday.

\item For two people born on different days, there is a day when one
  is twice as old as the other. That's their Double Day.  Write a
  program that takes two birthdays and computes their Double Day.

\item For a little more challenge, write the more general version that
  computes the day when one person is $n$ times older than the other.
\index{Double Day}

\end{enumerate}

\end{exercise}


\chapter{Classes and methods}

Code examples from this chapter are available from
\url{http://thinkpython.com/code/Time2.py}.

\section{Object-oriented features}
\index{object-oriented programming}

Python is an {\bf object-oriented programming language}, which means
that it provides features that support object-oriented
programming.

It is not easy to define object-oriented programming, but we have
already seen some of its characteristics:

\begin{itemize}

\item Programs are made up of object definitions and function
definitions, and most of the computation is expressed in terms
of operations on objects.

\item Each object definition corresponds to some object or concept
in the real world, and the functions that operate on that object
correspond to the ways real-world objects interact.

\end{itemize}

For example, the {\tt Time} class defined in Chapter~\ref{time}
corresponds to the way people record the time of day, and the
functions we defined correspond to the kinds of things people do with
times.  Similarly, the {\tt Point} and {\tt Rectangle} classes
correspond to the mathematical concepts of a point and a rectangle.

So far, we have not taken advantage of the features Python provides to
support object-oriented programming.  These
features are not strictly necessary; most of them provide
alternative syntax for things we have already done.  But in many cases,
the alternative is more concise and more accurately conveys the
structure of the program.

For example, in the {\tt Time} program, there is no obvious
connection between the class definition and the function definitions
that follow.  With some examination, it is apparent that every function
takes at least one {\tt Time} object as an argument.
\index{method}
\index{function}

This observation is the motivation for {\bf methods}; a method is
a function that is associated with a particular class.
We have seen methods for strings, lists, dictionaries and tuples.
In this chapter, we will define methods for user-defined types.
\index{syntax}
\index{semantics}

Methods are semantically the same as functions, but there are
two syntactic differences:

\begin{itemize}

\item Methods are defined inside a class definition in order
to make the relationship between the class and the method explicit.

\item The syntax for invoking a method is different from the
syntax for calling a function.

\end{itemize}

In the next few sections, we will take the functions from the previous
two chapters and transform them into methods.  This transformation is
purely mechanical; you can do it simply by following a sequence of
steps.  If you are comfortable converting from one form to another,
you will be able to choose the best form for whatever you are doing.


\section{Printing objects}
\index{object!printing}

In Chapter~\ref{time}, we defined a class named
{\tt Time} and in Exercise~\ref{ex.printtime}, you 
wrote a function named \verb"print_time":

\begin{verbatim}
class Time(object):
    """Represents the time of day."""

def print_time(time):
    print '%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)
\end{verbatim}
%
To call this function, you have to pass a {\tt Time} object as an
argument:

\begin{verbatim}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second = 00
>>> print_time(start)
09:45:00
\end{verbatim}
%
To make \verb"print_time" a method, all we have to do is
move the function definition inside the class definition.  Notice
the change in indentation.
\index{indentation}

\begin{verbatim}
class Time(object):
    def print_time(time):
        print '%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)
\end{verbatim}
%
Now there are two ways to call \verb"print_time".  The first
(and less common) way is to use function syntax:
\index{function syntax}
\index{dot notation}


\begin{verbatim}
>>> Time.print_time(start)
09:45:00
\end{verbatim}
%
In this use of dot notation, {\tt Time} is the name of the class,
and \verb"print_time" is the name of the method.  {\tt start} is
passed as a parameter.

The second (and more concise) way is to use method syntax:
\index{method syntax}

\begin{verbatim}
>>> start.print_time()
09:45:00
\end{verbatim}
%
In this use of dot notation, \verb"print_time" is the name of the
method (again), and {\tt start} is the object the method is
invoked on, which is called the {\bf subject}.  Just as the
subject of a sentence is what the sentence is about, the subject
of a method invocation is what the method is about.
\index{subject}

Inside the method, the subject is assigned to the first
parameter, so in this case {\tt start} is assigned
to {\tt time}.
\index{self (parameter name)}
\index{parameter!self}

By convention, the first parameter of a method is
called {\tt self}, so it would be more common to write
\verb"print_time" like this:

\begin{verbatim}
class Time(object):
    def print_time(self):
        print '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
\end{verbatim}
%
The reason for this convention is an implicit metaphor:
\index{metaphor, method invocation}

\begin{itemize}

\item The syntax for a function call, \verb"print_time(start)",
  suggests that the function is the active agent.  It says something
  like, ``Hey \verb"print_time"!  Here's an object for you to print.''

\item In object-oriented programming, the objects are the active
  agents.  A method invocation like \verb"start.print_time()" says
  ``Hey {\tt start}!  Please print yourself.''

\end{itemize}

This change in perspective might be more polite, but it is not obvious
that it is useful.  In the examples we have seen so far, it may not
be.  But sometimes shifting responsibility from the functions onto the
objects makes it possible to write more versatile functions, and makes
it easier to maintain and reuse code.

\begin{exercise}
\label{convert}

Rewrite \verb"time_to_int" (from Section~\ref{prototype}) as a method.
It is probably not appropriate to rewrite \verb"int_to_time" as a
method; what object you would invoke it on?

\end{exercise}


\section{Another example}
\index{increment}

Here's a version of {\tt increment} (from Section~\ref{increment})
rewritten as a method:

\begin{verbatim}
# inside class Time:

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
%
This version assumes that \verb"time_to_int" is written
as a method, as in Exercise~\ref{convert}.  Also, note that
it is a pure function, not a modifier.

Here's how you would invoke {\tt increment}:

\begin{verbatim}
>>> start.print_time()
09:45:00
>>> end = start.increment(1337)
>>> end.print_time()
10:07:17
\end{verbatim}
%
The subject, {\tt start}, gets assigned to the first parameter,
{\tt self}.  The argument, {\tt 1337}, gets assigned to the
second parameter, {\tt seconds}.

This mechanism can be confusing, especially if you make an error.
For example, if you invoke {\tt increment} with two arguments, you
get:
\index{exception!TypeError}
\index{TypeError}

\begin{verbatim}
>>> end = start.increment(1337, 460)
TypeError: increment() takes exactly 2 arguments (3 given)
\end{verbatim}
%
The error message is initially confusing, because there are
only two arguments in parentheses.  But the subject is also
considered an argument, so all together that's three.


\section{A more complicated example}

\verb"is_after" (from Exercise~\ref{isafter}) is slightly more complicated
because it takes two Time objects as parameters.  In this case it is
conventional to name the first parameter {\tt self} and the second
parameter {\tt other}:
\index{other (parameter name)}
\index{parameter!other}

\begin{verbatim}
# inside class Time:

    def is_after(self, other):
        return self.time_to_int() > other.time_to_int()
\end{verbatim}
%
To use this method, you have to invoke it on one object and pass
the other as an argument:

\begin{verbatim}
>>> end.is_after(start)
True
\end{verbatim}
%
One nice thing about this syntax is that it almost reads
like English: ``end is after start?''


\section{The init method}
\index{init method}
\index{method!init}

The init method (short for ``initialization'') is
a special method that gets invoked when an object is instantiated.  
Its full name is \verb"__init__" (two underscore characters,
followed by {\tt init}, and then two more underscores).  An
init method for the {\tt Time} class might look like this:

\begin{verbatim}
# inside class Time:

    def __init__(self, hour=0, minute=0, second=0):
        self.hour = hour
        self.minute = minute
        self.second = second
\end{verbatim}
%
It is common for the parameters of \verb"__init__"
to have the same names as the attributes.  The statement

\begin{verbatim}
        self.hour = hour
\end{verbatim}
%
stores the value of the parameter {\tt hour} as an attribute
of {\tt self}.
\index{optional parameter}
\index{parameter!optional}
\index{default value}
\index{override}

The parameters are optional, so if you call {\tt Time} with
no arguments, you get the default values.

\begin{verbatim}
>>> time = Time()
>>> time.print_time()
00:00:00
\end{verbatim}
%
If you provide one argument, it overrides {\tt hour}:

\begin{verbatim}
>>> time = Time (9)
>>> time.print_time()
09:00:00
\end{verbatim}
%
If you provide two arguments, they override {\tt hour} and
{\tt minute}.

\begin{verbatim}
>>> time = Time(9, 45)
>>> time.print_time()
09:45:00
\end{verbatim}
%
And if you provide three arguments, they override all three
default values.


\begin{exercise}
\index{Point class}
\index{class!Point}

Write an init method for the {\tt Point} class that takes
{\tt x} and {\tt y} as optional parameters and assigns
them to the corresponding attributes.
\end{exercise}


\section{The {\tt \_\_str\_\_} method}
\index{str method@\_\_str\_\_ method}
\index{method!\_\_str\_\_}

\verb"__str__" is a special method, like \verb"__init__",
that is supposed to return a string representation of an object.
\index{string representation}

For example, here is a {\tt str} method for Time objects:

\begin{verbatim}
# inside class Time:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
\end{verbatim}
%
When you {\tt print} an object, Python invokes the {\tt str} method:
\index{print statement}
\index{statement!print}

\begin{verbatim}
>>> time = Time(9, 45)
>>> print time
09:45:00
\end{verbatim}
%
When I write a new class, I almost always start by writing 
\verb"__init__", which makes it easier to instantiate objects, and 
\verb"__str__", which is useful for debugging.


\begin{exercise}

Write a {\tt str} method for the {\tt Point} class.  Create
a Point object and print it.

\end{exercise}


\section{Operator overloading}
\label{operator.overloading}

By defining other special methods, you can specify the behavior
of operators on user-defined types.  For example, if you define
a method named \verb"__add__" for the {\tt Time} class, you can use the
{\tt +} operator on Time objects.

Here is what the definition might look like:
\index{add method}
\index{method!add}

\begin{verbatim}
# inside class Time:

    def __add__(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
%
And here is how you could use it:

\begin{verbatim}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print start + duration
11:20:00
\end{verbatim}
%
When you apply the {\tt +} operator to Time objects, Python invokes
\verb"__add__".  When you print the result, Python invokes 
\verb"__str__".  So there is quite a lot happening behind the scenes!
\index{operator overloading}

Changing the behavior of an operator so that it works with
user-defined types is called {\bf operator overloading}.  For every
operator in Python there is a corresponding special method, like 
\verb"__add__".  For more details, see
\url{docs.python.org/ref/specialnames.html}.

\begin{exercise}

Write an {\tt add} method for the Point class.  

\end{exercise}


\section{Type-based dispatch}

In the previous section we added two Time objects, but you
also might want to add an integer to a Time object.  The
following is a version of \verb"__add__"
that checks the type of {\tt other} and invokes either
\verb"add_time" or {\tt increment}:

\begin{verbatim}
# inside class Time:

    def __add__(self, other):
        if isinstance(other, Time):
            return self.add_time(other)
        else:
            return self.increment(other)

    def add_time(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
%
The built-in function {\tt isinstance} takes a value and a
class object, and returns {\tt True} if the value is an instance
of the class.
\index{isinstance function}
\index{function!isinstance}

If {\tt other} is a Time object, \verb"__add__" invokes
\verb"add_time".  Otherwise it assumes that the parameter
is a number and invokes {\tt increment}.  This operation is
called a {\bf type-based dispatch} because it dispatches the
computation to different methods based on the type of the
arguments.
\index{type-based dispatch}
\index{dispatch, type-based}

Here are examples that use the {\tt +} operator with different
types:

\begin{verbatim}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print start + duration
11:20:00
>>> print start + 1337
10:07:17
\end{verbatim}
%
Unfortunately, this implementation of addition is not commutative.
If the integer is the first operand, you get
\index{commutativity}

\begin{verbatim}
>>> print 1337 + start
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
\end{verbatim}
%
The problem is, instead of asking the Time object to add an integer,
Python is asking an integer to add a Time object, and it doesn't know
how to do that.  But there is a clever solution for this problem: the
special method \verb"__radd__", which stands for ``right-side add.''
This method is invoked when a Time object appears on the right side of
the {\tt +} operator.  Here's the definition:
\index{radd method}
\index{method!radd}

\begin{verbatim}
# inside class Time:

    def __radd__(self, other):
        return self.__add__(other)
\end{verbatim}
%
And here's how it's used:

\begin{verbatim}
>>> print 1337 + start
10:07:17
\end{verbatim}
%

\begin{exercise}

Write an {\tt add} method for Points that works with either a
Point object or a tuple:  

\begin{itemize}

\item If the second operand is a Point, the method should return a new
Point whose $x$ coordinate is the sum of the $x$ coordinates of the
operands, and likewise for the $y$ coordinates.

\item If the second operand is a tuple, the method should add the
first element of the tuple to the $x$ coordinate and the second
element to the $y$ coordinate, and return a new Point with the result. 

\end{itemize}

\end{exercise}

\section{Polymorphism}

Type-based dispatch is useful when it is necessary, but (fortunately)
it is not always necessary.  Often you can avoid it by writing functions
that work correctly for arguments with different types.
\index{type-based dispatch}
\index{dispatch!type-based}

Many of the functions we wrote for strings will actually
work for any kind of sequence.
For example, in Section~\ref{histogram}
we used {\tt histogram} to count the number of times each letter
appears in a word.

\begin{verbatim}
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
\end{verbatim}
%
This function also works for lists, tuples, and even dictionaries,
as long as the elements of {\tt s} are hashable, so they can be used
as keys in {\tt d}.

\begin{verbatim}
>>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']
>>> histogram(t)
{'bacon': 1, 'egg': 1, 'spam': 4}
\end{verbatim}
%
Functions that can work with several types are called {\bf polymorphic}.
Polymorphism can facilitate code reuse.  For example, the built-in
function {\tt sum}, which adds the elements of a sequence, works
as long as the elements of the sequence support addition.
\index{polymorphism}

Since Time objects provide an {\tt add} method, they work
with {\tt sum}:

\begin{verbatim}
>>> t1 = Time(7, 43)
>>> t2 = Time(7, 41)
>>> t3 = Time(7, 37)
>>> total = sum([t1, t2, t3])
>>> print total
23:01:00
\end{verbatim}
%
In general, if all of the operations inside a function 
work with a given type, then the function works with that type.

The best kind of polymorphism is the unintentional kind, where
you discover that a function you already wrote can be
applied to a type you never planned for.


\section{Debugging}
\index{debugging}

It is legal to add attributes to objects at any point in the execution
of a program, but if you are a stickler for type theory, it is a
dubious practice to have objects of the same type with different
attribute sets.  It is usually a good idea to
initialize all of an objects attributes in the init method.
\index{init method}
\index{attribute!initializing}

If you are not sure whether an object has a particular attribute, you
can use the built-in function {\tt hasattr} (see Section~\ref{hasattr}).
\index{hasattr function}
\index{function!hasattr}
\index{dict attribute@\_\_dict\_\_ attribute}
\index{attribute!\_\_dict\_\_}

Another way to access the attributes of an object is through the
special attribute \verb"__dict__", which is a dictionary that maps
attribute names (as strings) and values:

\begin{verbatim}
>>> p = Point(3, 4)
>>> print p.__dict__
{'y': 4, 'x': 3}
\end{verbatim}
%
For purposes of debugging, you might find it useful to keep this
function handy:

\begin{verbatim}
def print_attributes(obj):
    for attr in obj.__dict__:
        print attr, getattr(obj, attr)
\end{verbatim}
%
\verb"print_attributes" traverses the items in the object's dictionary
and prints each attribute name and its corresponding value.
\index{traversal!dictionary}
\index{dictionary!traversal}

The built-in function {\tt getattr} takes an object and an attribute
name (as a string) and returns the attribute's value.
\index{getattr function}
\index{function!getattr}


\section{Interface and implementation}

One of the goals of object-oriented design is to make software more
maintainable, which means that you can keep the program working when
other parts of the system change, and modify the program to meet new
requirements.
\index{interface}
\index{implementation}
\index{maintainable}
\index{object-oriented design}

A design principle that helps achieve that goal is to keep
interfaces separate from implementations.  For objects, that means
that the methods a class provides should not depend on how the
attributes are represented.
\index{attribute}

For example, in this chapter we developed a class that represents
a time of day.  Methods provided by this class include
\verb"time_to_int", \verb"is_after", and \verb"add_time".

We could implement those methods in several ways.  The details of the
implementation depend on how we represent time.  In this chapter, the
attributes of a {\tt Time} object are {\tt hour}, {\tt minute}, and
{\tt second}.

As an alternative, we could replace these attributes with
a single integer representing the number of seconds
since midnight.  This implementation would make some methods,
like \verb"is_after", easier to write, but it makes some methods
harder.

After you deploy a new class, you might discover a better
implementation.  If other parts of the program are using your
class, it might be time-consuming and error-prone to change the
interface.  

But if you designed the interface carefully, you can
change the implementation without changing the interface, which
means that other parts of the program don't have to change.

Keeping the interface separate from the implementation means that
you have to hide the attributes.  Code in other parts of the program
(outside the class definition) should use methods to read
and modify the state of the object.  They should not access the
attributes directly.  This principle is called {\bf information hiding};
see \url{http://en.wikipedia.org/wiki/Information_hiding}.
\index{information hiding}

\begin{exercise}

Download the code from this chapter
(\url{http://thinkpython.com/code/Time2.py}).  Change the attributes
of {\tt Time} to be a single integer representing seconds since
midnight.  Then modify the methods (and the function
\verb"int_to_time") to work with the new implementation.  You should
not have to modify the test code in {\tt main}.  When you are done,
the output should be the same as before.  Solution:
\url{http://thinkpython.com/code/Time2_soln.py}

\end{exercise}


\section{Glossary}

\begin{description}

\item[object-oriented language:] A language that provides features,
  such as user-defined classes and method syntax, that facilitate
  object-oriented programming.
\index{object-oriented language}

\item[object-oriented programming:] A style of programming in which
data and the operations that manipulate it are organized into classes
and methods.
\index{object-oriented programming}

\item[method:] A function that is defined inside a class definition and
is invoked on instances of that class.
\index{method}

\item[subject:] The object a method is invoked on.
\index{subject}

\item[operator overloading:] Changing the behavior of an operator like
{\tt +} so it works with a user-defined type.
\index{overloading}
\index{operator!overloading}

\item[type-based dispatch:] A programming pattern that checks the type
of an operand and invokes different functions for different types.
\index{type-based dispatch}

\item[polymorphic:] Pertaining to a function that can work with more
  than one type.  
\index{polymorphism}

\item[information hiding:] The principle that the interface provided 
by an object should not depend on its implementation, in particular
the representation of its attributes.
\index{information hiding}


\end{description}

\section{Exercises}

\begin{exercise}
\index{default value!avoiding mutable}
\index{mutable object, as default value}
\index{worst bug}
\index{bug!worst}
\index{Kangaroo class}
\index{class!Kangaroo}

This exercise is a cautionary tale about one of the most
common, and difficult to find, errors in Python.
Write a definition for a class named {\tt Kangaroo} with the following
methods:

\begin{enumerate}

\item An \verb"__init__" method that initializes an attribute named 
\verb"pouch_contents" to an empty list.

\item A method named \verb"put_in_pouch" that takes an object
of any type and adds it to \verb"pouch_contents".

\item A \verb"__str__" method that returns a string representation
of the Kangaroo object and the contents of the pouch.

\end{enumerate}
%
Test your code 
by creating two {\tt Kangaroo} objects, assigning them to variables
named {\tt kanga} and {\tt roo}, and then adding {\tt roo} to the
contents of {\tt kanga}'s pouch.

Download \url{http://thinkpython.com/code/BadKangaroo.py}.  It contains
a solution to the previous problem with one big, nasty bug.
Find and fix the bug.

If you get stuck, you can download
\url{http://thinkpython.com/code/GoodKangaroo.py}, which explains the
problem and demonstrates a solution.
\index{aliasing}
\index{embedded object}
\index{object!embedded}

\end{exercise}




\begin{exercise}
\index{Visual module}
\index{module!Visual}
\index{vpython module}
\index{module!vpython}

Visual is a Python module that provides 3-D graphics.  It is
not always included in a Python installation, so you might have
to install it from your software repository or, if it's not there,
from \url{vpython.org}.

The following example creates a 3-D space that is 256 units
wide, long and high, and sets the ``center'' to be the
point $(128,128,128)$.  Then it draws a blue sphere.

\begin{verbatim}
from visual import *

scene.range = (256, 256, 256)
scene.center = (128, 128, 128)

color = (0.1, 0.1, 0.9)          # mostly blue
sphere(pos=scene.center, radius=128, color=color)
\end{verbatim}

{\tt color} is an RGB tuple; that is, the elements are Red-Green-Blue
levels between 0.0 and 1.0 (see
\url{http://en.wikipedia.org/wiki/RGB_color_model}).

If you run this code, you should see a window with a black
background and a blue sphere.  If you drag the middle button
up and down, you can zoom in and out.  You can also rotate
the scene by dragging the right button, but with only one
sphere in the world, it is hard to tell the difference.

The following loop creates a cube of spheres:

\begin{verbatim}
t = range(0, 256, 51)
for x in t:
    for y in t:
        for z in t:
            pos = x, y, z
            sphere(pos=pos, radius=10, color=color)
\end{verbatim}

\begin{enumerate}

\item Put this code in a script and make sure it works for
you.

\item Modify the program so that each sphere in the cube
has the color that corresponds to its position in RGB space.
Notice that the coordinates are in the range 0--255, but
the RGB tuples are in the range 0.0--1.0.
\index{color list}
\index{available colors}

\item Download \url{http://thinkpython.com/code/color_list.py}
and use the function \verb"read_colors" to generate a list
of the available colors on your system, their names and
RGB values.  For each named color draw a sphere in the
position that corresponds to its RGB values.



\end{enumerate}

You can see my solution at \url{http://thinkpython.com/code/color_space.py}.

\end{exercise}


\chapter{Inheritance}

In this chapter I present classes to represent playing cards,
decks of cards, and poker hands.  If you don't play poker, you can
read about it at \url{http://en.wikipedia.org/wiki/Poker}, but you don't have
to; I'll tell you what you need to know for the exercises.
Code examples from this chapter are available from
\url{http://thinkpython.com/code/Card.py}.
\index{playing card, Anglo-American}
\index{card, playing}
\index{poker}

If you are not familiar with Anglo-American playing cards,
you can read about them at \url{http://en.wikipedia.org/wiki/Playing_cards}.


\section{Card objects}

There are fifty-two cards in a deck, each of which belongs to one of
four suits and one of thirteen ranks.  The suits are Spades, Hearts,
Diamonds, and Clubs (in descending order in bridge).  The ranks are
Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.  Depending on
the game that you are playing, an Ace may be higher than King
or lower than 2.
\index{rank}
\index{suit}

If we want to define a new object to represent a playing card, it is
obvious what the attributes should be: {\tt rank} and
{\tt suit}.  It is not as obvious what type the attributes
should be.  One possibility is to use strings containing words like
\verb"'Spade'" for suits and \verb"'Queen'" for ranks.  One problem with
this implementation is that it would not be easy to compare cards to
see which had a higher rank or suit.
\index{encode}
\index{encrypt}
\index{map to}
\index{representation}

An alternative is to use integers to {\bf encode} the ranks and suits.
In this context, ``encode'' means that we are going to define a mapping
between numbers and suits, or between numbers and ranks.  This
kind of encoding is not meant to be a secret (that
would be ``encryption'').

\newcommand{\mymapsto}{$\mapsto$}

For example, this table shows the suits and the corresponding integer
codes:

\begin{tabular}{l c l}
Spades & \mymapsto & 3 \\
Hearts & \mymapsto & 2 \\
Diamonds & \mymapsto & 1 \\
Clubs & \mymapsto & 0
\end{tabular}

This code makes it easy to compare cards; because higher suits map to
higher numbers, we can compare suits by comparing their codes.

The mapping for ranks is fairly obvious; each of the numerical ranks
maps to the corresponding integer, and for face cards:

\begin{tabular}{l c l}
Jack & \mymapsto & 11 \\
Queen & \mymapsto & 12 \\
King & \mymapsto & 13 \\
\end{tabular}

I am using the \mymapsto~symbol to make it clear that these mappings
are not part of the Python program.  They are part of the program
design, but they don't appear explicitly in the code.
\index{Card class}
\index{class!Card}

The class definition for {\tt Card} looks like this:

\begin{verbatim}
class Card(object):
    """Represents a standard playing card."""

    def __init__(self, suit=0, rank=2):
        self.suit = suit
        self.rank = rank
\end{verbatim}
%
As usual, the init method takes an optional
parameter for each attribute.  The default card is
the 2 of Clubs.
\index{init method}
\index{method!init}

To create a Card, you call {\tt Card} with the
suit and rank of the card you want.

\begin{verbatim}
queen_of_diamonds = Card(1, 12)
\end{verbatim}
%


\section{Class attributes}
\label{class.attribute}
\index{class attribute}
\index{attribute!class}

In order to print Card objects in a way that people can easily
read, we need a mapping from the integer codes to the corresponding
ranks and suits.  A natural way to
do that is with lists of strings.  We assign these lists to {\bf class
attributes}:

\begin{verbatim}
# inside class Card:

    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', 
              '8', '9', '10', 'Jack', 'Queen', 'King']

    def __str__(self):
        return '%s of %s' % (Card.rank_names[self.rank],
                             Card.suit_names[self.suit])
\end{verbatim}
%
Variables like \verb"suit_names" and \verb"rank_names", which are
defined inside a class but outside of any method, are called
class attributes because they are associated with the class object 
{\tt Card}.
\index{instance attribute}
\index{attribute!instance}

This term distinguishes them from variables like {\tt suit} and {\tt
  rank}, which are called {\bf instance attributes} because they are
associated with a particular instance.
\index{dot notation}

Both kinds of attribute are accessed using dot notation.  For
example, in \verb"__str__", {\tt self} is a Card object,
and {\tt self.rank} is its rank.  Similarly, {\tt Card}
is a class object, and \verb"Card.rank_names" is a
list of strings associated with the class.

Every card has its own {\tt suit} and {\tt rank}, but there
is only one copy of \verb"suit_names" and \verb"rank_names".

Putting it all together, the expression
\verb"Card.rank_names[self.rank]" means ``use the attribute {\tt rank}
from the object {\tt self} as an index into the list \verb"rank_names"
from the class {\tt Card}, and select the appropriate string.''

The first element of \verb"rank_names" is {\tt None} because there
is no card with rank zero.  By including {\tt None} as a place-keeper,
we get a mapping with the nice property that the index 2 maps to the
string \verb"'2'", and so on.  To avoid this tweak, we could have
used a dictionary instead of a list.

With the methods we have so far, we can create and print cards:

\begin{verbatim}
>>> card1 = Card(2, 11)
>>> print card1
Jack of Hearts
\end{verbatim}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/card1.pdf}}
\caption{Object diagram.}
\label{fig.card1}
\end{figure}

Figure~\ref{fig.card1} is a diagram of the {\tt Card} class object
and one Card instance.
\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}
{\tt Card} is a class object, so it has type {\tt type}.  {\tt
card1} has type {\tt Card}.  (To save space, I didn't draw the
contents of \verb"suit_names" and \verb"rank_names").


\section{Comparing cards}
\label{comparecard}
\index{operator!relational}
\index{relational operator}

For built-in types, there are relational operators
({\tt <}, {\tt >}, {\tt ==}, etc.)
that compare
values and determine when one is greater than, less than, or equal to
another.  For user-defined types, we can override the behavior of
the built-in operators by providing a method named
\verb"__cmp__".  

\verb"__cmp__" takes two parameters, {\tt self} and {\tt other},
and returns a positive number if the first object is greater, a
negative number if the second object is greater, and 0 if they are
equal to each other.
\index{override}
\index{operator overloading}

The correct ordering for cards is not obvious.
For example, which
is better, the 3 of Clubs or the 2 of Diamonds?  One has a higher
rank, but the other has a higher suit.  In order to compare
cards, you have to decide whether rank or suit is more important.

The answer might depend on what game you are playing, but to keep
things simple, we'll make the arbitrary choice that suit is more
important, so all of the Spades outrank all of the Diamonds,
and so on.
\index{cmp method@\_\_cmp\_\_ method}
\index{method!\_\_cmp\_\_}

With that decided, we can write \verb"__cmp__":

\begin{verbatim}
# inside class Card:

    def __cmp__(self, other):
        # check the suits
        if self.suit > other.suit: return 1
        if self.suit < other.suit: return -1

        # suits are the same... check ranks
        if self.rank > other.rank: return 1
        if self.rank < other.rank: return -1

        # ranks are the same... it's a tie
        return 0    
\end{verbatim}
%
You can write this more concisely using tuple comparison:
\index{tuple!comparison}
\index{comparison!tuple}

\begin{verbatim}
# inside class Card:

    def __cmp__(self, other):
        t1 = self.suit, self.rank
        t2 = other.suit, other.rank
        return cmp(t1, t2)
\end{verbatim}
%
The built-in function {\tt cmp} has the same interface as
the method \verb"__cmp__": it takes two values and returns
a positive number if the first is larger, a negative number
if the second is larger, and 0 if they are equal.
\index{cmp function}
\index{function!cmp}


\begin{exercise}

Write a \verb"__cmp__" method for Time objects.  Hint: you
can use tuple comparison, but you also might consider using
integer subtraction.

%    def __cmp__(self, other):
%        return time_to_int(self) - time_to_int(other)

%If {\tt self} is later than {\tt other}, the result is
%a positive number.  If {\tt other} is later, the result
%is negative.  And if {\tt self} and {\tt other} are equal
%(but not necessarily identical)
%the result is zero.

\end{exercise}


\section{Decks}
\index{list!of objects}
\index{deck, playing cards}

Now that we have Cards, the next step is to define Decks.  Since a
deck is made up of cards, it is natural for each Deck to contain a
list of cards as an attribute.
\index{init method}
\index{method!init}

The following is a class definition for {\tt Deck}.  The
init method creates the attribute {\tt cards} and generates
the standard set of fifty-two cards:
\index{composition}
\index{loop!nested}
\index{Deck class}
\index{class!Deck}

\begin{verbatim}
class Deck(object):

    def __init__(self):
        self.cards = []
        for suit in range(4):
            for rank in range(1, 14):
                card = Card(suit, rank)
                self.cards.append(card)
\end{verbatim}
%
The easiest way to populate the deck is with a nested loop.  The outer
loop enumerates the suits from 0 to 3.  The inner loop enumerates the
ranks from 1 to 13.  Each iteration
creates a new Card with the current suit and rank,
and appends it to {\tt self.cards}.
\index{append method}
\index{method!append}


\section{Printing the deck}
\label{printdeck}
\index{str method@\_\_str\_\_ method}
\index{method!\_\_str\_\_}

Here is a \verb"__str__" method for {\tt Deck}:

\begin{verbatim}
#inside class Deck:

    def __str__(self):
        res = []
        for card in self.cards:
            res.append(str(card))
        return '\n'.join(res)
\end{verbatim}
%
This method demonstrates an efficient way to accumulate a large
string: building a list of strings and then using {\tt join}.
The built-in function {\tt str} invokes the \verb"__str__"
method on each card and returns the string representation.
\index{accumulator!string}
\index{string!accumulator}
\index{join method}
\index{method!join}
\index{newline}

Since we invoke {\tt join} on a newline character, the cards
are separated by newlines.  Here's what the result looks like:

\begin{verbatim}
>>> deck = Deck()
>>> print deck
Ace of Clubs
2 of Clubs
3 of Clubs
...
10 of Spades
Jack of Spades
Queen of Spades
King of Spades
\end{verbatim}
%
Even though the result appears on 52 lines, it is
one long string that contains newlines.


\section{Add, remove, shuffle and sort}

To deal cards, we would like a method that
removes a card from the deck and returns it.
The list method {\tt pop} provides a convenient way to do that:
\index{pop method}
\index{method!pop}

\begin{verbatim}
#inside class Deck:

    def pop_card(self):
        return self.cards.pop()
\end{verbatim}
%
Since {\tt pop} removes the {\em last} card in the list, we are
dealing from the bottom of the deck.  In real life ``bottom dealing'' is
frowned upon,
but in this context it's ok.
\index{append method}
\index{method!append}

To add a card, we can use the list method {\tt append}:

\begin{verbatim}
#inside class Deck:

    def add_card(self, card):
        self.cards.append(card)
\end{verbatim}
%
A method like this that uses another function without doing
much real work is sometimes called a {\bf veneer}.  The metaphor
comes from woodworking, where it is common to glue a thin
layer of good quality wood to the surface of a cheaper piece of
wood.
\index{veneer}

In this case we are defining a ``thin'' method that expresses
a list operation in terms that are appropriate for decks.

As another example, we can write a Deck method named {\tt shuffle}
using the function {\tt shuffle} from the {\tt random} module:
\index{random module}
\index{module!random}
\index{shuffle function}
\index{function!shuffle}

\begin{verbatim}
# inside class Deck:
            
    def shuffle(self):
        random.shuffle(self.cards)
\end{verbatim}
%
Don't forget to import {\tt random}.

\begin{exercise}
\index{sort method}
\index{method!sort}

Write a Deck method named {\tt sort} that uses the list method
{\tt sort} to sort the cards in a {\tt Deck}.  {\tt sort} uses
the \verb"__cmp__" method we defined to determine sort order.
\end{exercise}



\section{Inheritance}
\index{inheritance}
\index{object-oriented programming}

The language feature most often associated with object-oriented
programming is {\bf inheritance}.  Inheritance is the ability to
define a new class that is a modified version of an existing
class.
\index{parent class}
\index{child class}
\index{class!child}
\index{subclass}
\index{superclass}

It is called ``inheritance'' because the new class inherits the
methods of the existing class.  Extending this metaphor, the existing
class is called the {\bf parent} and the new class is
called the {\bf child}.

As an example, let's say we want a class to represent a ``hand,''
that is, the set of cards held by one player.  A hand is similar to a
deck: both are made up of a set of cards, and both require operations
like adding and removing cards.

A hand is also different from a deck; there are operations we want for
hands that don't make sense for a deck.  For example, in poker we
might compare two hands to see which one wins.  In bridge, we might
compute a score for a hand in order to make a bid.

This relationship between classes---similar, but different---lends
itself to inheritance.  

The definition of a child class is like other class definitions,
but the name of the parent class appears in parentheses:
\index{parentheses!parent class in}
\index{parent class}
\index{class!parent}
\index{Hand class}
\index{class!Hand}

\begin{verbatim}
class Hand(Deck):
    """Represents a hand of playing cards."""
\end{verbatim}
%
This definition indicates that {\tt Hand} inherits from {\tt Deck};
that means we can use methods like \verb"pop_card" and \verb"add_card"
for Hands as well as Decks.

{\tt Hand} also inherits \verb"__init__" from {\tt Deck}, but
it doesn't really do what we want: instead of populating the hand
with 52 new cards, the init method for Hands should initialize
{\tt cards} with an empty list.
\index{override}
\index{init method}
\index{method!init}

If we provide an init method in the {\tt Hand} class, it overrides the
one in the {\tt Deck} class:

\begin{verbatim}
# inside class Hand:

    def __init__(self, label=''):
        self.cards = []
        self.label = label
\end{verbatim}
%
So when you create a Hand, Python invokes this init method:

\begin{verbatim}
>>> hand = Hand('new hand')
>>> print hand.cards
[]
>>> print hand.label
new hand
\end{verbatim}
%
But the other methods are inherited from {\tt Deck}, so we can use
\verb"pop_card" and \verb"add_card" to deal a card:

\begin{verbatim}
>>> deck = Deck()
>>> card = deck.pop_card()
>>> hand.add_card(card)
>>> print hand
King of Spades
\end{verbatim}
%
A natural next step is to encapsulate this code in a method
called \verb"move_cards":
\index{encapsulation}

\begin{verbatim}
#inside class Deck:

    def move_cards(self, hand, num):
        for i in range(num):
            hand.add_card(self.pop_card())
\end{verbatim}
%
\verb"move_cards" takes two arguments, a Hand object and the number of
cards to deal.  It modifies both {\tt self} and {\tt hand}, and
returns {\tt None}.

In some games, cards are moved from one hand to another,
or from a hand back to the deck.  You can use \verb"move_cards"
for any of these operations: {\tt self} can be either a Deck
or a Hand, and {\tt hand}, despite the name, can also be a {\tt Deck}.

\begin{exercise}

Write a Deck method called \verb"deal_hands" that takes two
parameters, the number of hands and the number of cards per
hand, and that creates new Hand objects, deals the appropriate
number of cards per hand, and returns a list of Hand objects.

\end{exercise}

Inheritance is a useful feature.  Some programs that would be
repetitive without inheritance can be written more elegantly
with it.  Inheritance can facilitate code reuse, since you can
customize the behavior of parent classes without having to modify
them.  In some cases, the inheritance structure reflects the natural
structure of the problem, which makes the program easier to
understand.

On the other hand, inheritance can make programs difficult to read.
When a method is invoked, it is sometimes not clear where to find its
definition.  The relevant code may be scattered among several modules.
Also, many of the things that can be done using inheritance can be
done as well or better without it.  


\section{Class diagrams}
\label{class.diagram}

So far we have seen stack diagrams, which show the state of
a program, and object diagrams, which show the attributes
of an object and their values.  These diagrams represent a snapshot
in the execution of a program, so they change as the program
runs.

They are also highly detailed; for some purposes, too
detailed.  A class diagram is a more abstract representation
of the structure of a program.  Instead of showing individual
objects, it shows classes and the relationships between them.

There are several kinds of relationship between classes:

\begin{itemize}

\item Objects in one class might contain references to objects
in another class.  For example, each Rectangle contains a reference
to a Point, and each Deck contains references to many Cards.
This kind of relationship is called {\bf HAS-A}, as in, ``a Rectangle
has a Point.''

\item One class might inherit from another.  This relationship
is called {\bf IS-A}, as in, ``a Hand is a kind of a Deck.''

\item One class might depend on another in the sense that changes
in one class would require changes in the other.

\end{itemize}
\index{IS-A relationship}
\index{HAS-A relationship}
\index{class diagram}
\index{diagram!class}

A {\bf class diagram} is a graphical representation of these
relationships.  For example, Figure~\ref{fig.class1} shows the
relationships between {\tt Card}, {\tt Deck} and {\tt Hand}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/class1.pdf}}
\caption{Class diagram.}
\label{fig.class1}
\end{figure}


The arrow with a hollow triangle head represents an IS-A
relationship; in this case it indicates that Hand inherits
from Deck.

The standard arrow head represents a HAS-A
relationship; in this case a Deck has references to Card
objects.
\index{multiplicity (in class diagram)}

The star ({\tt *}) near the arrow head is a 
{\bf multiplicity}; it indicates how many Cards a Deck has.
A multiplicity can be a simple number, like {\tt 52}, a range,
like {\tt 5..7} or a star, which indicates that a Deck can
have any number of Cards.

A more detailed diagram might show that a Deck actually
contains a {\em list} of Cards, but built-in types
like list and dict are usually not included in class diagrams.

\begin{exercise}

Read {\tt TurtleWorld.py}, {\tt World.py} and {\tt Gui.py}
and draw a class diagram that shows the relationships among
the classes defined there.

\end{exercise}


\section{Debugging}
\index{debugging}

Inheritance can make debugging a challenge because when you
invoke a method on an object, you might not know which method
will be invoked.
\index{polymorphism}

Suppose you are writing a function that works with Hand objects.
You would like it to work with all kinds of Hands, like
PokerHands, BridgeHands, etc.  If you invoke a method like
{\tt shuffle}, you might get the one defined in {\tt Deck},
but if any of the subclasses override this method, you'll
get that version instead.  
\index{flow of execution}

Any time you are unsure about the flow of execution through your
program, the simplest solution is to add print statements at the
beginning of the relevant methods.  If {\tt Deck.shuffle} prints a
message that says something like {\tt Running Deck.shuffle}, then as
the program runs it traces the flow of execution.

As an alternative, you could use this function, which takes an
object and a method name (as a string) and returns the class that
provides the definition of the method:

\begin{verbatim}
def find_defining_class(obj, meth_name):
    for ty in type(obj).mro():
        if meth_name in ty.__dict__:
            return ty
\end{verbatim}
%
Here's an example:

\begin{verbatim}
>>> hand = Hand()
>>> print find_defining_class(hand, 'shuffle')
<class 'Card.Deck'>
\end{verbatim}
%
So the {\tt shuffle} method for this Hand is the one in {\tt Deck}.
\index{mro method}
\index{method!mro}
\index{method resolution order}

\verb"find_defining_class" uses the {\tt mro} method to get the list
of class objects (types) that will be searched for methods.  ``MRO''
stands for ``method resolution order.''
\index{override}
\index{interface}
\index{precondition}
\index{postcondition}

Here's a program design suggestion: whenever you override a method,
the interface of the new method should be the same as the old.  It
should take the same parameters, return the same type, and obey the
same preconditions and postconditions.  If you obey this rule, you
will find that any function designed to work with an instance of a
superclass, like a Deck, will also work with instances of subclasses
like a Hand or PokerHand.

If you violate this rule, your code will collapse like (sorry)
a house of cards.


\section{Data encapsulation}

Chapter~\ref{time} demonstrates a development plan we might call
``object-oriented design.''  We identified objects we needed---{\tt
  Time}, {\tt Point} and {\tt Rectangle}---and defined classes to
represent them.  In each case there is an obvious correspondence
between the object and some entity in the real world (or at least a
mathematical world).
\index{development plan}

But sometimes it is less obvious what objects you need
and how they should interact.  In that case you need a different
development plan.  In the same way that we discovered function
interfaces by encapsulation and generalization, we can discover
class interfaces by {\bf data encapsulation}.
\index{data encapsulation}
\index{encapsulation!data}

Markov analysis, from Section~\ref{markov}, provides a good example.
If you download my code from \url{http://thinkpython.com/code/markov.py},
you'll see that it uses two global variables---\verb"suffix_map" and
\verb"prefix"---that are read and written from several functions.

\begin{verbatim}
suffix_map = {}        
prefix = ()            
\end{verbatim}

Because these variables are global
we can only run one analysis
at a time.  If we read two texts, their prefixes and suffixes would
be added to the same data structures (which makes for some interesting
generated text).

To run multiple analyses, and keep them separate, we can encapsulate
the state of each analysis in an object.
Here's what that looks like:

\begin{verbatim}
class Markov(object):

    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()    
\end{verbatim}

Next, we transform the functions into methods.  For example,
here's \verb"process_word":

\begin{verbatim}
    def process_word(self, word, order=2):
        if len(self.prefix) < order:
            self.prefix += (word,)
            return

        try:
            self.suffix_map[self.prefix].append(word)
        except KeyError:
            # if there is no entry for this prefix, make one
            self.suffix_map[self.prefix] = [word]

        self.prefix = shift(self.prefix, word)        
\end{verbatim}

Transforming a program like this---changing the design without
changing the function---is another example of refactoring
(see Section~\ref{refactoring}).
\index{refactoring}

This example suggests a development plan for designing objects and
methods:

\begin{enumerate}

\item Start by writing functions that read and write global
variables (when necessary).

\item Once you get the program working, look for associations
between global variables and the functions that use them.

\item Encapsulate related variables as attributes of an object.

\item Transform the associated functions into methods of the new
class.

\end{enumerate}


\begin{exercise}

Download my code from Section~\ref{markov}
(\url{http://thinkpython.com/code/markov.py}), and follow the steps described
above to encapsulate the global variables as attributes of a new class
called {\tt Markov}.  Solution: \url{http://thinkpython.com/code/Markov.py}
(note the capital M).

\end{exercise}




\section{Glossary}

\begin{description}

\item[encode:]  To represent one set of values using another
set of values by constructing a mapping between them.
\index{encode}

\item[class attribute:] An attribute associated with a class
object.  Class attributes are defined inside
a class definition but outside any method.
\index{class attribute}
\index{attribute!class}

\item[instance attribute:] An attribute associated with an
instance of a class.
\index{instance attribute}
\index{attribute!instance}

\item[veneer:] A method or function that provides a different
interface to another function without doing much computation.
\index{veneer}

\item[inheritance:] The ability to define a new class that is a
modified version of a previously defined class.
\index{inheritance}

\item[parent class:] The class from which a child class inherits.
\index{parent class}

\item[child class:] A new class created by inheriting from an
existing class; also called a ``subclass.''
\index{child class}
\index{class!child}

\item[IS-A relationship:] The relationship between a child class
and its parent class.
\index{IS-A relationship}

\item[HAS-A relationship:] The relationship between two classes
where instances of one class contain references to instances of
the other.
\index{HAS-A relationship}

\item[class diagram:] A diagram that shows the classes in a program
and the relationships between them.
\index{class diagram}
\index{diagram!class}

\item[multiplicity:] A notation in a class diagram that shows, for
a HAS-A relationship, how many references there are to instances
of another class.
\index{multiplicity (in class diagram)}

\end{description}


\section{Exercises}

\begin{exercise}
\label{poker}

The following are the possible hands in poker, in increasing order
of value (and decreasing order of probability):
\index{poker}

\begin{description}

\item[pair:] two cards with the same rank
\vspace{-0.05in}

\item[two pair:] two pairs of cards with the same rank
\vspace{-0.05in}

\item[three of a kind:] three cards with the same rank
\vspace{-0.05in}

\item[straight:] five cards with ranks in sequence (aces can
be high or low, so {\tt Ace-2-3-4-5} is a straight and so is {\tt
10-Jack-Queen-King-Ace}, but {\tt Queen-King-Ace-2-3} is not.)
\vspace{-0.05in}

\item[flush:] five cards with the same suit
\vspace{-0.05in}

\item[full house:] three cards with one rank, two cards with another
\vspace{-0.05in}

\item[four of a kind:] four cards with the same rank
\vspace{-0.05in}

\item[straight flush:] five cards in sequence (as defined above) and
with the same suit
\vspace{-0.05in}

\end{description}
%
The goal of these exercises is to estimate
the probability of drawing these various hands.

\begin{enumerate}

\item Download the following files from \url{http://thinkpython.com/code}:

\begin{description}

\item[{\tt Card.py}]: A complete version of the {\tt Card},
{\tt Deck} and {\tt Hand} classes in this chapter.

\item[{\tt PokerHand.py}]: An incomplete implementation of a class
that represents a poker hand, and some code that tests it.

\end{description}
%
\item If you run {\tt PokerHand.py}, it deals seven 7-card poker hands
and checks to see if any of them contains a flush.  Read this
code carefully before you go on.

\item Add methods to {\tt PokerHand.py} named \verb"has_pair",
\verb"has_twopair", etc. that return True or False according to
whether or not the hand meets the relevant criteria.  Your code should
work correctly for ``hands'' that contain any number of cards
(although 5 and 7 are the most common sizes).

\item Write a method named {\tt classify} that figures out
the highest-value classification for a hand and sets the
{\tt label} attribute accordingly.  For example, a 7-card hand
might contain a flush and a pair; it should be labeled ``flush''.

\item When you are convinced that your classification methods are
working, the next step is to estimate the probabilities of the various
hands.  Write a function in {\tt PokerHand.py} that shuffles a deck of
cards, divides it into hands, classifies the hands, and counts the
number of times various classifications appear.

\item Print a table of the classifications and their probabilities.
Run your program with larger and larger numbers of hands until the
output values converge to a reasonable degree of accuracy.  Compare
your results to the values at \url{http://en.wikipedia.org/wiki/Hand_rankings}.

\end{enumerate}

Solution: \url{http://thinkpython.com/code/PokerHandSoln.py}.
\end{exercise}


\begin{exercise}
\index{Swampy}
\index{TurtleWorld}

This exercise uses TurtleWorld from Chapter~\ref{turtlechap}.
You will write code that makes Turtles play tag.  If you
are not familiar with the rules of tag, see
\url{http://en.wikipedia.org/wiki/Tag_(game)}.

\begin{enumerate}

\item Download \url{http://thinkpython.com/code/Wobbler.py} and run it.  You
should see a TurtleWorld with three Turtles.  If you press the
{\sf Run} button, the Turtles wander at random.

\item Read the code and make sure you understand how it works.
The {\tt Wobbler} class inherits from {\tt Turtle}, which means
that the {\tt Turtle} methods {\tt lt}, {\tt rt}, {\tt fd}
and {\tt bk} work on Wobblers.

The {\tt step} method gets invoked by TurtleWorld.  It invokes 
{\tt steer}, which turns the Turtle in the desired direction,
{\tt wobble}, which makes a random turn in proportion to the Turtle's
clumsiness, and {\tt move}, which moves forward a few pixels,
depending on the Turtle's speed.
\index{Tagger}

\item Create a file named {\tt Tagger.py}.  Import everything from
  {\tt Wobbler}, then define a class named {\tt Tagger} that inherits
  from {\tt Wobbler}.  Call \verb"make_world" passing the {\tt
    Tagger} class object as an argument.

\item Add a {\tt steer} method to {\tt Tagger} to override the one in
  {\tt Wobbler}.  As a starting place, write a version that always
  points the Turtle toward the origin.  Hint: use the math function
  {\tt atan2} and the Turtle attributes {\tt x}, {\tt y} and
  {\tt heading}.

\item Modify {\tt steer} so that the Turtles stay in bounds.
  For debugging, you might want to use the {\sf Step} button,
  which invokes {\tt step} once on each Turtle.

\item Modify {\tt steer} so that each Turtle points toward its nearest
  neighbor.  Hint: Turtles have an attribute, {\tt world}, that is a
  reference to the TurtleWorld they live in, and the TurtleWorld has
  an attribute, {\tt animals}, that is a list of all Turtles in the
  world.

\item Modify {\tt steer} so the Turtles play tag.  You can add methods
  to {\tt Tagger} and you can override {\tt steer} and
  \verb"__init__", but you may not modify or override {\tt step}, {\tt
    wobble} or {\tt move}.  Also, {\tt steer} is allowed to change the
  heading of the Turtle but not the position.

Adjust the rules and your {\tt steer} method for good quality play;
for example, it should be possible for the slow Turtle to tag the
faster Turtles eventually.

\end{enumerate}

Solution: \url{http://thinkpython.com/code/Tagger.py}.
\end{exercise}


%\chapter{Python Magic}
%\includepdf[pages={199-231}]{notes/project.pdf}

\chapter{Python GUI}
\includepdf[pages={299-313}]{notes/project.pdf}


%\chapter{Network Programming}
%\includepdf[pages={326-341}]{notes/project.pdf}

\chapter{Python Facts}
\section{Zip}
Combining lists is really easy using zip.
\begin{lstlisting}
names = ['john', 'peter', 'robert']
ages = [24, 26, 35]
cars = ['BMW', 'Audi', 'Ford']

print zip(names, ages, cars)

>>[('john', 24, 'BMW'), ('peter', 26, 'Audi'), ('robert', 35, 'Ford')]
\end{lstlisting}

\section{List Comprehensions Support Conditions}
You can add conditions to your list comprehensions
\begin{lstlisting}
things = [1,2,'3','dog']
numbers = [t for t in things if t.isdigit()]

>>Traceback (most recent call last):
  File "/base/data/home/apps/s~learnpythonjail/2.365841894475711898/main.py", line 75, in execute_python
    exec(code, {})
  File "<string>", line 2, in <module>
AttributeError: 'int' object has no attribute 'isdigit'
\end{lstlisting}

\section{Expanding arrays to function arguments}
To pass a list of arguments to a function using an array, use the following notation:
\begin{lstlisting}
def add(n1, n2):
    return n1 + n2

numbers = [3, 4]
print add(*numbers)

>>7
\end{lstlisting}

\section{Ordered and Named Function Arguments}
You can accept variable amounts of function parameters by name and by order
\begin{lstlisting}
def f(*args, **kwargs):
    print(args)
    print(kwargs)

f(1,2,3,named1="keyword arg1", another="another kwarg")

>>
(1, 2, 3)
{'named1': 'keyword arg1', 'another': 'another kwarg'}
\end{lstlisting}

\section{Functions as objects}
Everything is an object. Functions are true objects, so they can be passed as arguments
\begin{lstlisting}
def talk(text):
    print text

def think(idea):
    print "thinking about %s" % idea

def do_something(what, with_what):
    what(with_what)

do_something(talk, 'hello!')
do_something(think, 'food...')

>>
hello!
thinking about food...
\end{lstlisting}

\section{Mutability}
identifiers point to objects, so a change to a mutable object (like a list) will change it no matter how it's identified. To make a copy of a list, slice it, or use copy (or deepcopy).
\begin{lstlisting}
original_list = ['a','b','c']
copy_of_original_list = original_list
copy_of_original_list.pop()
print original_list


original_list = ['a','b','c']
copy_of_original_list = original_list[:]  # added 3 characters in this statement
copy_of_original_list.pop()
print original_list

>>
['a', 'b']
['a', 'b', 'c']
\end{lstlisting}

\section{Change mutable lists using another name}
Changing one list can change another list, which can hide bugs or obfuscate code.
\begin{lstlisting}
congratulatory_message = list("Lucky You!")

temp = congratulatory_message
for x in range(0,8,4):
    temp[x] = chr((8-x)*10)

# Looks like I never changed the congratulatory message...
print "".join(congratulatory_message)

>>
Puck( You!
\end{lstlisting}

\section{Factorial Function}
There are probably as many different non-native implementations of the factorial function in Python as there are stars in the sky, but this one shines particularly bright. This lambda function uses reduce to iterate through numbers from 2 to n, multiplying them as it goes along. Note that the third argument to reduce is the default value, which is returned if the sequence given by xrange is empty (e.g. if n is zero or one).
\begin{lstlisting}
from operator import mul
factorial = lambda n: reduce(mul, xrange(2, n+1), 1)
print factorial(21)
>>
51090942171709440000
\end{lstlisting}

\section{String formatting using dictionaries}
Python has really powerful string formatting. If you want to use dictionary based (template-like) formatting, then you can:
\begin{lstlisting}
data = {"name" : "Alfred"}
print "Hello %(name)s! How are you?" % data

>>Output:
Hello Alfred! How are you?
\end{lstlisting}

\section{Never Define One Line Functions}
Lambdas are Python's way of telling you to avoid overusing def. 

\begin{lstlisting}
from math import sqrt
def quad(a, b, c):
    return -b/a + sqrt(b**2-4*a*c), -b/a + sqrt(b**2-4*a*c)
roots = lambda a, b, c: (-b/a + sqrt(b**2-4*a*c), -b/a + sqrt(b**2-4*a*c))
#Use with caution.

>>Output
\end{lstlisting}

\section{Number from Digits}
Turn a list of digits to a number.
\begin{lstlisting}
digit_list = [1,2,3,4,5]
print reduce(lambda x,y: 10*x+y, digit_list)
>>Output:
12345
\end{lstlisting}

\section{Generator Functions}
Python supports generator functions, which create iteratable sequences on the fly:
\begin{lstlisting}
def lottery_numbers():
    my_numbers = [1,3,2,5,4,6]

    for n in my_numbers:
        if n > 3:
            yield n+10
        else:
            yield n

for n in lottery_numbers():
    print n

>>Output:
1
3
2
15
14
16
\end{lstlisting}

\section{Parsing REST API}
Python is really awesome when it comes to API integration. Check out how easy it is to search Twitter:
\begin{lstlisting}
import urllib, simplejson, pprint
data = simplejson.load(urllib.urlopen("http://search.twitter.com/search.json?q=learnpython&count=5"))
pprint.pprint([x["text"] for x in data["results"]])
\end{lstlisting}

\section{Sets for finding unions and intersections}
Using set operations is powerful. Find the elements common to all lists in a list of lists.
\begin{lstlisting}
def get_common_elements(list_of_lists):
    return list(set.intersection(*map(set, list_of_lists)))

a = [1,2,3,4,5,6,7,8,9,10]
b = [2,4,6,8,10,12,14,16,18,20]
print get_common_elements([a,b])
print list(set.union( set(a), set(b) ))

>>Output:
[8, 2, 4, 10, 6]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20]

\end{lstlisting}


\section{Locals and strings}
Use locals for easy string interpolation.

\begin{lstlisting}
world = "earth"
print "hello %(world)s" % locals()

>>Output:
hello earth

\end{lstlisting}


\section{Encoding \& Decoding}
Python supports a wide variety of encoding and decoding methods.
\begin{lstlisting}
print "ABCDEFGH".encode("hex")
print 'VGhpcyBpcyBhIHNlY3JldCBNZXNzYWdl\n'.decode("base64")

>>Output:
4142434445464748
This is a secret Message
\end{lstlisting}

\section{Set Comprehensions}
Python 2.7 supports set literals and comprehensions.

\begin{lstlisting}
print {1, 2, 2, 3, 1}

names = ["Foo", "bar", "foo", "Baz", "CATS", "dogs"]
print {name.upper() for name in names if name[0] in 'fFbB'}

>>Output:
set([1, 2, 3])
set(['BAZ', 'FOO', 'BAR'])
\end{lstlisting}


\section{dict() and zip() make for a powerful combination}
Create dicts by ziping keys and data.
\begin{lstlisting}
voters = ['friends','neighbors','countrymen']
counts = [10,5,800]
print dict(zip(voters,counts))

votes = ['yes',66,'no',77,'abstain',9]
print dict(zip(votes[:-1:2],votes[1::2]))

>>Output:
{'neighbors': 5, 'countrymen': 800, 'friends': 10}
{'yes': 66, 'abstain': 9, 'no': 77}
\end{lstlisting}

\section{Bools inherit from int}
Check help(True) for more details.
\begin{lstlisting}
print True + True == 2
>>Output:
True
\end{lstlisting}


\section{The Zen of Python}
Long time Pythoneer Tim Peters succinctly channels the BDFL's guiding principles for Python's design into 20 aphorisms, only 19 of which have been written down.
\begin{lstlisting}
import this
\end{lstlisting}

\chapter{Python Glossary}
This is a glossary of terms and topics in Python as covered in Codecademy courses. It does not attempt to completely define and explain terms, but rather provides a general overview that is appropriate for someone new to the language. For a more comprehensive treatment of these topics, we recommend the Mozilla Developer Network Python documentation.

\section{List}
 A Python data type that holds an ordered collection of values, which can be of any type. This is equivalant to an "array" in many other languages. Python lists are "mutable," implying that they can be changed once created.
\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> x = [1, 2, 3, 4]
>> y = ['spam', 'eggs']
>> x
[1, 2, 3, 4]
>> y
['spam','eggs']

>> y.append('mash')
>> y
['spam', 'eggs', 'mash']

>> y += ['beans']
>> y
['spam', 'eggs', 'mash', 'beans']
\end{lstlisting}

\section{Slice}
A pythonic way of extracting "slices" of a list using a special bracket notation that specifies the start and end of the section of the list you wish to extract. Leaving the beginning value blank indicates you wish to start at the beginning of the list, leaving the ending value blank indicates you wish to go to the end of the list. Using a negative value references the end of the list (so that in a list of 4 elements, -1 means the 4th element). Slicing always yields another list, even when extracting a single value. 
\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> # Specifying a beginning and end:
>> x = [1, 2, 3, 4]
>> x[2:3]
[3]

>> # Specifying start at the beginning and end at the second element
>> x[:2]
[1, 2]

>> # Specifying start at the next to last element and go to the end
>> x[-2:]
[3, 4]

>> # Specifying start at the beginning and go to the next to last element
>> x[:-1]
[1, 2, 3]

>> # Specifying a step argument returns every n-th item
>> y = [1, 2, 3, 4, 5, 6, 7, 8]
>> y[::2]
[1, 3, 5, 7]

>> # Return a reversed version of the list ( or string )
>> x[::-1]
[4, 3, 2, 1]

>> # String reverse
>> my_string = "Aloha"
>> my_string[::-1]
"aholA"
\end{lstlisting}

\section{Variables}
Variables are assigned values using the '=' operator, which is not to be confused with the '==' sign used for testing equality. A variable can hold almost any type of value such as lists, dictionaries, functions. 
\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> x = 12
>> x
12
\end{lstlisting}

\section{Functions}
 Python builds functions using the syntax: $def function\_name(variable): $ Functions can be stand-alone or can return values. Functions can also contain other functions.
\lstset{language=Python, tabsize=4}
\begin{lstlisting}
def add_two(a, b):
  c = a + b
  return c

# or without the interim assignment to c
def add_two(a, b):
  return a + b
\end{lstlisting}

\section{Tuples}
A Python data type that holds an ordered collection of values, which can be of any type. Python tuples are "immutable," meaning that they cannot be changed once created. 
\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> x = (1, 2, 3, 4)
>> y = ('spam', 'eggs')

>> my_list = [1,2,3,4]
>> my_tuple = tuple(my_list)
>> my_tuple
(1, 2, 3, 4)
\end{lstlisting}


\section{List Comprehensions}

Convenient ways to generate or extract information from lists. List Comprehensions will take a general form such as: [item for item in List if Condition]

\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> x_list = [1,2,3,4,5,6,7]
>> even_list = [num for num in x_list if (num % 2 == 0)]
>> even_list
[2,4,6]

>> m_list = ['AB', 'AC', 'DA', 'FG', 'LB']
>> A_list = [duo for duo in m_list if ('A' in duo)]
>> A_list
['AB', 'AC', 'DA']
\end{lstlisting}

\section{Sets}

Sets are collections of unique but unordered items. It is possible to convert certain iterables to a set. {"this", "is", "a", "set"}

\lstset{language=Python, tabsize=4}
\begin{lstlisting}

>> new_set = {1, 2, 3, 4, 4, 4,'A', 'B', 'B', 'C'}
>> new_set
{'A', 1, 'C', 3, 4, 2, 'B'}

>> dup_list = [1,1,2,2,2,3,4,55,5,5,6,7,8,8]
>> set_from_list = set(dup_list)
>> set_from_list
{1, 2, 3, 4, 5, 6, 7, 8, 55}
\end{lstlisting}

\section{Dictionaries}

Dictionaries, like sets, contain unique but unordered items. The big difference is the concept of "keys" to retrieve "values"; "keys" can be strings, integers or tuples (or anything else hashable), but the "values" that they map to can be any data type.

\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> my_dict = {}
>> content_of_value1 = "abcd"
>> content_of_value2 = "wxyz"
>> my_dict.update({"key_name1":content_of_value1})
>> my_dict.update({"key_name2":content_of_value2})
>> my_dict
{'key_name1':"abcd", 'key_name2':"wxyz"}
>> my_dict.get("key_name2")
"wxyz"
\end{lstlisting}

\section{Strings}

Strings store characters and have many built-in convenience methods that let you modify their content.

\lstset{language=Python, tabsize=4}
\begin{lstlisting}
>> my_string1 = "this is a valid string"
>> my_string2 = 'this is also a valid string'
>> my_string3 = 'this is' + ' ' + 'also' + ' ' + 'a string'
>> my_string3
"this is also a string"
\end{lstlisting}

\section{The len() Function}

Using $len(some\_object)$ returns the number of $\_top\-level\_$ items contained in the object being queried.

\lstset{language=Python, tabsize=4}
\begin{lstlisting}

>> my_list = [0,4,5,2,3,4,5]
>> len(my_list)
7

>> my_string = 'abcdef'
>> len(my_string)
6
\end{lstlisting}


\section{Single Line Comments}

Augmenting code with human readable descriptions can help document design decisions.

\begin{lstlisting}
# this is a single line comment.
\end{lstlisting}

\section{Multi-line Comments}

Some comments need to span several lines, use this if you have more than 4 single line comments in a row.
\begin{lstlisting}

'''
this is
a multi-line
comment, i am handy for commenting out whole
chunks of code very fast
'''
\end{lstlisting}

\section{Print}

A function to display the output of a program. Using the parenthesized version is arguably more consistent.

\begin{lstlisting}
>> # this will work in all modern versions of Python
>> print("some text here")
"some text here"

>> # but this only works in Python versions lower than 3.x
>> print "some text here too"
"some text here too"
\end{lstlisting}

\section{The range() Function}

The range() function returns a list of integers, the sequence of which is defined by the arguments passed to it.

argument variations:
\begin{itemize}
\item range(terminal)
\item range(start, terminal)
\item range(start, terminal, step\_size)
\end{itemize}

\begin{lstlisting}
>> [i for i in range(4)]
[0, 1, 2, 3]

>> [i for i in range(2, 8)]
[2, 3, 4, 5, 6, 7]

>> [i for i in range(2, 13, 3)]
[2, 5, 8, 11]
\end{lstlisting}

\section{For Loops}

Python provides a clean iteration syntax. Note the colon and indentation.

\begin{lstlisting}
>> for i in range(0, 3):
>>     print(i*2)
0
2
4

>> m_list = ["Sir", "Lancelot", "Coconuts"]
>> for item in m_list:
>>     print(item)
Sir
Lancelot
Coconuts

>> w_string = "Swift"
>> for letter in w_string:
>>     print(letter)
S
w
i
f
t
\end{lstlisting}

\section{While Loops}

A While loop permits code to execute repeatedly until a certain condition is met. This is useful if the number of iterations required to complete a task is unknown prior to flow entering the loop.

\begin{lstlisting}
>> looping_needed = True
>>
>> while looping_needed:
>>     # some operation on data
>>     if condition:
>>          looping_needed = False
\end{lstlisting}

\section{The str() Function}

Using the str() function allows you to represent the content of a variable as a string, provided that the data type of the variable provides a neat way to do so. str() does not change the variable in place, it returns a 'stringified' version of it.

\begin{lstlisting}
>> # such features can be useful for concatenating strings
>> my_var = 123
>> my_var
123

>> str(my_var)
'123'

>> my_booking = "DB Airlines Flight " + str(my_var)
>> my_booking
'DB Airlines Flight 123'
\end{lstlisting}

\section{>>>}
The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.

\section{...}
The default Python prompt of the interactive shell when entering code for an indented code block or within a pair of matching left and right delimiters (parentheses, square brackets or curly braces).

\section{2to3}
A tool that tries to convert Python 2.x code to Python 3.x code by handling most of the incompatibilities which can be detected by parsing the source and traversing the parse tree.

2to3 is available in the standard library as lib2to3; a standalone entry point is provided as Tools/scripts/2to3. See 2to3 - Automated Python 2 to 3 code translation.

\section{abstract base class}
Abstract base classes complement duck-typing by providing a way to define interfaces when other techniques like hasattr() would be clumsy or subtly wrong (for example with magic methods). ABCs introduce virtual subclasses, which are classes that don’t inherit from a class but are still recognized by isinstance() and issubclass(); see the abc module documentation. Python comes with many built-in ABCs for data structures (in the collections module), numbers (in the numbers module), and streams (in the io module). You can create your own ABCs with the abc module.

\section{argument}
A value passed to a function (or method) when calling the function. There are two types of arguments:
\begin{itemize}
\item keyword argument: an argument preceded by an identifier (e.g. name=) in a function call or passed as a value in a dictionary preceded by **. For example, 3 and 5 are both keyword arguments in the following calls to complex():
\begin{lstlisting}
complex(real=3, imag=5)
complex(**{'real': 3, 'imag': 5})
\end{lstlisting}
\item positional argument: an argument that is not a keyword argument. Positional arguments can appear at the beginning of an argument list and/or be passed as elements of an iterable preceded by *. For example, 3 and 5 are both positional arguments in the following calls:
\begin{lstlisting}
complex(3, 5)
complex(*(3, 5))
\end{lstlisting}
\end{itemize}
Arguments are assigned to the named local variables in a function body. See the Calls section for the rules governing this assignment. Syntactically, any expression can be used to represent an argument; the evaluated value is assigned to the local variable.

\section{attribute}
A value associated with an object which is referenced by name using dotted expressions. For example, if an object o has an attribute a it would be referenced as o.a.

\section{BDFL}
Benevolent Dictator For Life, a.k.a. Guido van Rossum, Python’s creator.

\section{bytecode}
Python source code is compiled into bytecode, the internal representation of a Python program in the CPython interpreter. The bytecode is also cached in .pyc and .pyo files so that executing the same file is faster the second time (recompilation from source to bytecode can be avoided). This “intermediate language” is said to run on a virtual machine that executes the machine code corresponding to each bytecode. Do note that bytecodes are not expected to work between different Python virtual machines, nor to be stable between Python releases.

A list of bytecode instructions can be found in the documentation for the dis module.

\section{class}
A template for creating user-defined objects. Class definitions normally contain method definitions which operate on instances of the class.

\section{classic class}
Any class which does not inherit from object. See new-style class. Classic classes have been removed in Python 3.

\section{coercion}
The implicit conversion of an instance of one type to another during an operation which involves two arguments of the same type. For example, int(3.15) converts the floating point number to the integer 3, but in 3+4.5, each argument is of a different type (one int, one float), and both must be converted to the same type before they can be added or it will raise a TypeError. Coercion between two operands can be performed with the coerce built-in function; thus, 3+4.5 is equivalent to calling operator.add(*coerce(3, 4.5)) and results in operator.add(3.0, 4.5). Without coercion, all arguments of even compatible types would have to be normalized to the same value by the programmer, e.g., float(3)+4.5 rather than just 3+4.5.

\section{complex number}
An extension of the familiar real number system in which all numbers are expressed as a sum of a real part and an imaginary part. Imaginary numbers are real multiples of the imaginary unit (the square root of -1), often written i in mathematics or j in engineering. Python has built-in support for complex numbers, which are written with this latter notation; the imaginary part is written with a j suffix, e.g., 3+1j. To get access to complex equivalents of the math module, use cmath. Use of complex numbers is a fairly advanced mathematical feature. If you’re not aware of a need for them, it’s almost certain you can safely ignore them.

\section{context manager}
An object which controls the environment seen in a with statement. See PEP 343.

\section{CPython}
The canonical implementation of the Python programming language, as distributed on python.org. The term “CPython” is used when necessary to distinguish this implementation from others such as Jython or IronPython.

\section{decorator}
A function returning another function, usually applied as a function transformation using the @wrapper syntax. Common examples for decorators are classmethod() and staticmethod().

The decorator syntax is merely syntactic sugar, the following two function definitions are semantically equivalent:
\begin{lstlisting}
def f(...):
    ...
f = staticmethod(f)

@staticmethod
def f(...):
    ...
\end{lstlisting}

The same concept exists for classes, but is less commonly used there. See the documentation for function definitions and class definitions for more about decorators.

\section{descriptor}
Any new-style object which defines the methods $\_\_$get$\_\_$(), $\_\_$set$\_\_$(), or $\_\_$delete$\_\_$(). When a class attribute is a descriptor, its special binding behavior is triggered upon attribute lookup. Normally, using a.b to get, set or delete an attribute looks up the object named b in the class dictionary for a, but if b is a descriptor, the respective descriptor method gets called. Understanding descriptors is a key to a deep understanding of Python because they are the basis for many features including functions, methods, properties, class methods, static methods, and reference to super classes.

For more information about descriptors’ methods, see Implementing Descriptors.

\section{dictionary}
An associative array, where arbitrary keys are mapped to values.

\section{docstring}
A string literal which appears as the first expression in a class, function or module. While ignored when the suite is executed, it is recognized by the compiler and put into the $\_\_$doc$\_\_$ attribute of the enclosing class, function or module. Since it is available via introspection, it is the canonical place for documentation of the object.

\section{duck-typing}
A programming style which does not look at an object’s type to determine if it has the right interface; instead, the method or attribute is simply called or used (“If it looks like a duck and quacks like a duck, it must be a duck.”) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). (Note, however, that duck-typing can be complemented with abstract base classes.) Instead, it typically employs hasattr() tests or EAFP programming.

\section{EAFP}
Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C.

\section{expression}
A piece of syntax which can be evaluated to some value. In other words, an expression is an accumulation of expression elements like literals, names, attribute access, operators or function calls which all return a value. In contrast to many other languages, not all language constructs are expressions. There are also statements which cannot be used as expressions, such as print or if. Assignments are also statements, not expressions.

\section{extension module}
A module written in C or C++, using Python’s C API to interact with the core and with user code.

\section{file object}
An object exposing a file-oriented API (with methods such as read() or write()) to an underlying resource. Depending on the way it was created, a file object can mediate access to a real on-disk file or to another type of storage or communication device (for example standard input/output, in-memory buffers, sockets, pipes, etc.). File objects are also called file-like objects or streams.

There are actually three categories of file objects: raw binary files, buffered binary files and text files. Their interfaces are defined in the io module. The canonical way to create a file object is by using the open() function.

\section{file-like object}
A synonym for file object.

\section{finder}
An object that tries to find the loader for a module. It must implement a method named find\_module(). See PEP 302 for details.

\section{floor division}
Mathematical division that rounds down to nearest integer. The floor division operator is //. For example, the expression 11 // 4 evaluates to 2 in contrast to the 2.75 returned by float true division. Note that (-11) // 4 is -3 because that is -2.75 rounded downward. See PEP 238.

\section{function}
A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body. See also parameter, method, and the Function definitions section.

\section{$\_\_$future$\_\_$}
A pseudo-module which programmers can use to enable new language features which are not compatible with the current interpreter. For example, the expression 11/4 currently evaluates to 2. If the module in which it is executed had enabled true division by executing:

\begin{lstlisting}
from __future__ import division
\end{lstlisting}
the expression 11/4 would evaluate to 2.75. By importing the$\_\_$future$\_\_$ module and evaluating its variables, you can see when a new feature was first added to the language and when it will become the default:
\begin{lstlisting}
>>>
>>> import __future__
>>> __future__.division
_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)
\end{lstlisting}

\section{garbage collection}
The process of freeing memory when it is not used anymore. Python performs garbage collection via reference counting and a cyclic garbage collector that is able to detect and break reference cycles.

\section{generator}
A function which returns an iterator. It looks like a normal function except that it contains yield statements for producing a series a values usable in a for-loop or that can be retrieved one at a time with the next() function. Each yield temporarily suspends processing, remembering the location execution state (including local variables and pending try-statements). When the generator resumes, it picks-up where it left-off (in contrast to functions which start fresh on every invocation).

\section{generator expression}
An expression that returns an iterator. It looks like a normal expression followed by a for expression defining a loop variable, range, and an optional if expression. The combined expression generates values for an enclosing function:
\begin{lstlisting}
>>>
>>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81
285
\end{lstlisting}

\section{GIL}
See global interpreter lock.

\section{global interpreter lock}
The mechanism used by the CPython interpreter to assure that only one thread executes Python bytecode at a time. This simplifies the CPython implementation by making the object model (including critical built-in types such as dict) implicitly safe against concurrent access. Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much of the parallelism afforded by multi-processor machines.

However, some extension modules, either standard or third-party, are designed so as to release the GIL when doing computationally-intensive tasks such as compression or hashing. Also, the GIL is always released when doing I/O.

Past efforts to create a “free-threaded” interpreter (one which locks shared data at a much finer granularity) have not been successful because performance suffered in the common single-processor case. It is believed that overcoming this performance issue would make the implementation much more complicated and therefore costlier to maintain.

\section{hashable}
An object is hashable if it has a hash value which never changes during its lifetime (it needs a $\_\_$hash$\_\_$() method), and can be compared to other objects (it needs an $\_\_$eq$\_\_$() or $\_\_$cmp$\_\_$() method). Hashable objects which compare equal must have the same hash value.

Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.

All of Python’s immutable built-in objects are hashable, while no mutable containers (such as lists or dictionaries) are. Objects which are instances of user-defined classes are hashable by default; they all compare unequal (except with themselves), and their hash value is their id().

\section{IDLE}
An Integrated Development Environment for Python. IDLE is a basic editor and interpreter environment which ships with the standard distribution of Python.

\section{immutable}
An object with a fixed value. Immutable objects include numbers, strings and tuples. Such an object cannot be altered. A new object has to be created if a different value has to be stored. They play an important role in places where a constant hash value is needed, for example as a key in a dictionary.

\section{integer division}
Mathematical division discarding any remainder. For example, the expression 11/4 currently evaluates to 2 in contrast to the 2.75 returned by float division. Also called floor division. When dividing two integers the outcome will always be another integer (having the floor function applied to it). However, if one of the operands is another numeric type (such as a float), the result will be coerced (see coercion) to a common type. For example, an integer divided by a float will result in a float value, possibly with a decimal fraction. Integer division can be forced by using the // operator instead of the / operator. See also $\_\_$future$\_\_$.
\section{importer}
An object that both finds and loads a module; both a finder and loader object.
\section{interactive}
Python has an interactive interpreter which means you can enter statements and expressions at the interpreter prompt, immediately execute them and see their results. Just launch python with no arguments (possibly by selecting it from your computer’s main menu). It is a very powerful way to test out new ideas or inspect modules and packages (remember help(x)).
\section{interpreted}
Python is an interpreted language, as opposed to a compiled one, though the distinction can be blurry because of the presence of the bytecode compiler. This means that source files can be run directly without explicitly creating an executable which is then run. Interpreted languages typically have a shorter development/debug cycle than compiled ones, though their programs generally also run more slowly. See also interactive.
\section{iterable}
An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict and file and objects of any classes you define with an $\_\_$iter$\_\_$() or $\_\_$getitem$\_\_$() method. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object. This iterator is good for one pass over the set of values. When using iterables, it is usually not necessary to call iter() or deal with iterator objects yourself. The for statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop. See also iterator, sequence, and generator.
\section{iterator}
An object representing a stream of data. Repeated calls to the iterator’s next() method return successive items in the stream. When no more data are available a StopIteration exception is raised instead. At this point, the iterator object is exhausted and any further calls to its next() method just raise StopIteration again. Iterators are required to have an $\_\_$iter$\_\_$() method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted. One notable exception is code which attempts multiple iteration passes. A container object (such as a list) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop. Attempting this with an iterator will just return the same exhausted iterator object used in the previous iteration pass, making it appear like an empty container.

More information can be found in Iterator Types.

\section{key function}
A key function or collation function is a callable that returns a value used for sorting or ordering. For example, locale.strxfrm() is used to produce a sort key that is aware of locale specific sort conventions.

A number of tools in Python accept key functions to control how elements are ordered or grouped. They include min(), max(), sorted(), list.sort(), heapq.nsmallest(), heapq.nlargest(), and itertools.groupby().

There are several ways to create a key function. For example. the str.lower() method can serve as a key function for case insensitive sorts. Alternatively, an ad-hoc key function can be built from a lambda expression such as lambda r: (r[0], r[2]). Also, the operator module provides three key function constructors: attrgetter(), itemgetter(), and methodcaller(). See the Sorting HOW TO for examples of how to create and use key functions.

\section{keyword argument}
See argument.

\section{lambda}
An anonymous inline function consisting of a single expression which is evaluated when the function is called. The syntax to create a lambda function is lambda [arguments]: expression
\section{LBYL}
Look before you leap. This coding style explicitly tests for pre-conditions before making calls or lookups. This style contrasts with the EAFP approach and is characterized by the presence of many if statements.

In a multi-threaded environment, the LBYL approach can risk introducing a race condition between “the looking” and “the leaping”. For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP approach.

\section{list}
A built-in Python sequence. Despite its name it is more akin to an array in other languages than to a linked list since access to elements are O(1).

\section{list comprehension}
A compact way to process all or part of the elements in a sequence and return a list with the results. result = $["0x\%02x" \% x for x in range(256) if x \% 2 == 0]$ generates a list of strings containing even hex numbers (0x..) in the range from 0 to 255. The if clause is optional. If omitted, all elements in range(256) are processed.

\section{loader}
An object that loads a module. It must define a method named load\_module(). A loader is typically returned by a finder. See PEP 302 for details.

\section{mapping}
A container object that supports arbitrary key lookups and implements the methods specified in the Mapping or MutableMapping abstract base classes. Examples include dict, collections.defaultdict, collections.OrderedDict and collections.Counter.

\section{metaclass}
The class of a class. Class definitions create a class name, a class dictionary, and a list of base classes. The metaclass is responsible for taking those three arguments and creating the class. Most object oriented programming languages provide a default implementation. What makes Python special is that it is possible to create custom metaclasses. Most users never need this tool, but when the need arises, metaclasses can provide powerful, elegant solutions. They have been used for logging attribute access, adding thread-safety, tracking object creation, implementing singletons, and many other tasks.

More information can be found in Customizing class creation.

\section{method}
A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which is usually called self). See function and nested scope.

\section{method resolution order}
Method Resolution Order is the order in which base classes are searched for a member during lookup. See The Python 2.3 Method Resolution Order.

\section{MRO}
See method resolution order.

\section{mutable}
Mutable objects can change their value but keep their id(). See also immutable.

\section{named tuple}
Any tuple\-like class whose indexable elements are also accessible using named attributes (for example, time.localtime() returns a tuple\-like object where the year is accessible either with an index such as t[0] or with a named attribute like t.tm\_year).

A named tuple can be a built-in type such as time.struct\_time, or it can be created with a regular class definition. A full featured named tuple can also be created with the factory function collections.namedtuple(). The latter approach automatically provides extra features such as a self-documenting representation like Employee(name='jones', title='programmer').

\section{namespace}
The place where a variable is stored. Namespaces are implemented as dictionaries. There are the local, global and built-in namespaces as well as nested namespaces in objects (in methods). Namespaces support modularity by preventing naming conflicts. For instance, the functions $\_\_$builtin$\_\_$.open() and os.open() are distinguished by their namespaces. Namespaces also aid readability and maintainability by making it clear which module implements a function. For instance, writing random.seed() or itertools.izip() makes it clear that those functions are implemented by the random and itertools modules, respectively.

\section{nested scope}
The ability to refer to a variable in an enclosing definition. For instance, a function defined inside another function can refer to variables in the outer function. Note that nested scopes work only for reference and not for assignment which will always write to the innermost scope. In contrast, local variables both read and write in the innermost scope. Likewise, global variables read and write to the global namespace.

\section{new-style class}
Any class which inherits from object. This includes all built-in types like list and dict. Only new-style classes can use Python’s newer, versatile features like $\_\_$slots$\_\_$, descriptors, properties, and $\_\_$getattribute$\_\_$().

More information can be found in New-style and classic classes.

\section{object}
Any data with state (attributes or value) and defined behavior (methods). Also the ultimate base class of any new-style class.

\section{parameter}
A named entity in a function (or method) definition that specifies an argument (or in some cases, arguments) that the function can accept. There are four types of parameters:
\begin{itemize}
\item positional-or-keyword: specifies an argument that can be passed either positionally or as a keyword argument. This is the default kind of parameter, for example foo and bar in the following:
\begin{lstlisting}
def func(foo, bar=None): ...
\end{lstlisting}
\item positional-only: specifies an argument that can be supplied only by position. Python has no syntax for defining positional-only parameters. However, some built-in functions have positional-only parameters (e.g. abs()).

\item var-positional: specifies that an arbitrary sequence of positional arguments can be provided (in addition to any positional arguments already accepted by other parameters). Such a parameter can be defined by prepending the parameter name with *, for example args in the following:
\begin{lstlisting}
def func(*args, **kwargs): ...
\end{lstlisting}
\item var-keyword: specifies that arbitrarily many keyword arguments can be provided (in addition to any keyword arguments already accepted by other parameters). Such a parameter can be defined by prepending the parameter name with **, for example kwargs in the example above.
\end{itemize}

Parameters can specify both optional and required arguments, as well as default values for some optional arguments.

See also the argument glossary entry, the FAQ question on the difference between arguments and parameters, and the Function definitions section.

\section{positional argument}
See argument.

\section{Python 3000}
Nickname for the Python 3.x release line (coined long ago when the release of version 3 was something in the distant future.) This is also abbreviated “Py3k”.

\section{Pythonic}
An idea or piece of code which closely follows the most common idioms of the Python language, rather than implementing code using concepts common to other languages. For example, a common idiom in Python is to loop over all elements of an iterable using a for statement. Many other languages don’t have this type of construct, so people unfamiliar with Python sometimes use a numerical counter instead:
\begin{lstlisting}
for i in range(len(food)):
    print food[i]
\end{lstlisting}
As opposed to the cleaner, Pythonic method:
\begin{lstlisting}
for piece in food:
    print piece
reference count
\end{lstlisting}
The number of references to an object. When the reference count of an object drops to zero, it is deallocated. Reference counting is generally not visible to Python code, but it is a key element of the CPython implementation. The sys module defines a getrefcount() function that programmers can call to return the reference count for a particular object.
\section{$\_\_$slots$\_\_$}
A declaration inside a new-style class that saves memory by pre-declaring space for instance attributes and eliminating instance dictionaries. Though popular, the technique is somewhat tricky to get right and is best reserved for rare cases where there are large numbers of instances in a memory-critical application.
\section{sequence}
An iterable which supports efficient element access using integer indices via the $\_\_$getitem$\_\_$() special method and defines a len() method that returns the length of the sequence. Some built-in sequence types are list, str, tuple, and unicode. Note that dict also supports $\_\_$getitem$\_\_$() and $\_\_$len$\_\_$(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than integers.
\section{slice}
An object usually containing a portion of a sequence. A slice is created using the subscript notation, [] with colons between numbers when several are given, such as in variable\_name[1:3:5]. The bracket (subscript) notation uses slice objects internally (or in older versions, $\_\_$getslice$\_\_$() and $\_\_$setslice$\_\_$()).
\section{special method}
A method that is called implicitly by Python to execute a certain operation on a type, such as addition. Such methods have names starting and ending with double underscores. Special methods are documented in Special method names.
\section{statement}
A statement is part of a suite (a “block” of code). A statement is either an expression or a one of several constructs with a keyword, such as if, while or for.
\section{struct sequence}
A tuple with named elements. Struct sequences expose an interface similiar to named tuple in that elements can either be accessed either by index or as an attribute. However, they do not have any of the named tuple methods like \_make() or \_asdict(). Examples of struct sequences include sys.float\_info and the return value of os.stat().

\section{type}
The type of a Python object determines what kind of object it is; every object has a type. An object’s type is accessible as its $\_\_$class$\_\_$ attribute or can be retrieved with type(obj).

\section{view}
The objects returned from dict.viewkeys(), dict.viewvalues(), and dict.viewitems() are called dictionary views. They are lazy sequences that will see changes in the underlying dictionary. To force the dictionary view to become a full list use list(dictview). See Dictionary view objects.
\section{virtual machine}
A computer defined entirely in software. Python’s virtual machine executes the bytecode emitted by the bytecode compiler.
\section{Zen of Python}
Listing of Python design principles and philosophies that are helpful in understanding and using the language. The listing can be found by typing “import this” at the interactive prompt.

\chapter{Project}
\includepdf[pages={487-505}]{notes/project.pdf}

\chapter{List Methods}
\includepdf[pages={-}]{notes/list_methods.pdf}

\chapter{String Formattig}
\includepdf[pages={-}]{notes/formatting.pdf}

\chapter{Built-in Modules}
\includepdf[pages={-}]{notes/modules.pdf}

\part{Python Labs}

\chapter{Python Syntax}

\section{Variables and Data Types}
Python was developed to be clear, powerful, and fun to use. We'll start with a quick note on what Python is and how it's used, then we'll jump right into writing code! This course assumes no prior knowledge in Python.

Python is a powerful, flexible programming language you can use in web/Internet development, to write desktop graphical user interfaces (GUIs), create games, and much more. Python is:
\begin{enumerate}
\item High-level, meaning reading and writing Python is really easy—it looks a lot like regular English!
\item Interpreted, meaning you don't need a compiler to write and run Python! You can write it here at Codecademy or even on your own computer (many are shipped with the Python interpreter built in—we'll get to the interpreter later in this lesson).
\item Object-oriented, meaning it allows users to manipulate data structures called objects in order to build and execute programs. We'll learn more about objects later.
\item Fun to use. Python is named after Monty Python's Flying Circus, and example code and tutorials often refer to the show and include jokes in order to make learning the language more interesting.
\end{enumerate}
This course assumes no previous knowledge of Python in particular or programming/computer science in general.

\subsection{Variables}
One of the most basic concepts in computer programming is the variable. A variable is a word/identifier that hangs onto a single value. For example, let's say you needed the number 5 for your program, but you're not going to use it immediately. You can set a variable, say spam, to grab the value 5 and hang onto it for later use, like this:
\begin{lstlisting}
spam = 5
\end{lstlisting}
Declaring variables in Python is easy; you just write out a name/identifier, like spam, and use = to assign it a value, and you're done!

\subsubsection{INSTRUCTIONS}
Set the variable my\_variable to the value 10.

\subsection{Data Types}
Great! We can now summon the value 10 by calling out the name my\_variable whenever we need it.

In this case, the data type of my\_variable is an integer (a positive or negative whole number). There are three data types in Python that are of interest to us at the moment: integers, floats (fractional numbers written with a decimal point, like 1.970), and booleans (which can be True or False).

Computer programs, in large part, are created to manipulate data. Therefore, it's important to understand the different types of data (or "datatypes") that we can incorporate into our programs.

Never use quotation marks (' or ") with booleans, and always capitalize the first letter! Python is case-sensitive (it cares about capitalization). We'll use quotation marks when we get to strings, which we'll cover in the next unit.

\subsubsection{INSTRUCTIONS}
Set the following variables to the corresponding values:
\begin{itemize}
\item my\_int to the value 7
\item my\_float to the value 1.23
\item my\_bool to the value True
\end{itemize}

\subsection{You've Been Reassigned}
Great work. You now know how to declare variables in Python and set them to different values, and you've learned about three different types of values: integers, floats, and booleans.

You can reassign a variable at any point. If you first set my\_int to 7 but later want to change it to 3, all you have to do is tell Python my\_int = 3, and it'll change the value of my\_int for you.

Try it and see!

\subsubsection{INSTRUCTIONS}
Change the value of my\_int from 7 to 3 in the editor.


\section{Whitespace and Statements}
Now that you're getting the hang of variables, values, and assignment (think of them like the subjects, objects, and verbs of English sentences), let's take a look at whitespace and statements: the sentences of our new Python language.

\subsection{What's a Statement?}
You can think of a Python statement as being similar to a sentence in English: it's the smallest unit of the language that makes sense by itself. Just like "I," "like," and "Spam" aren't statements by themselves, but "I like Spam" is, variables and data types aren't statements in Python, but they are the building blocks that form them.

To continue the sentence analogy, it's clear that we also need a kind of punctuation to make it obvious where one statement ends and another begins. If you're familiar with JavaScript, you know that statements end with a semicolon (;). In Python, statements are separated by whitespace. Just like you can't toss around semicolons wherever you want in JS, you can't throw whitespace around in Python.

This may take some getting used to, especially if you're coming from a programming language where whitespace doesn't matter.

\subsubsection{INSTRUCTIONS}
Don't worry about understanding the code on the right; just hit "run" to see what happens.
You should see an error message due to badly formatted code. We'll fix it in the next exercise!

\begin{lstlisting}
def spam():
	eggs = 12
	return eggs
        
print spam()
\end{lstlisting}

\subsection{Whitespace Means Right Space}
Notice the error you got when you ran the code in the editor:

IndentationError: expected an indented   block
You'll get this error whenever your Python whitespace is out of whack. (If you've studied JavaScript, think of improper whitespace as improper use of ; or {}.) When your punctuation's off, your meaning can change entirely:

The peasant said, "The witch turned me into a newt!"
"The peasant," said the witch, "turned me into a newt!"
See what we mean?

\subsubsection{INSTRUCTIONS}
Properly indent the code to the right by hitting the spacebar key on your keyboard four times on line 2 (before eggs) and another four times on line 3 (before return). Click "run" once you've done this.

\subsection{A Matter of Interpretation}
In the introduction to this unit, we mentioned that Python is an interpreted language (meaning it runs using an interpreter). In the context of Codecademy, the interpreter is the console/output window in the lower right corner of the page.

For now, think of the interpreter as a program that takes the code you write, checks it for syntax errors, and executes the statements in that code, line by line. It works as a go-between for you and the computer and lets you know the result of your instructions to the machine.

\subsubsection{INSTRUCTIONS}
Tell Python to assign the value True to the variable spam and False to the variable eggs.

\section{Comments}
Good comments make programs more readable and will help you diagnose problems when they arise. Get in the habit of commenting up your code!

\subsection{Single Line Comments}
Single Line Comments
You may have noticed the instructions in the editor that begin with a \# (pound or hash) symbol. These lines of code are called comments, and they aren't read by the interpreter—they don't affect the code at all. They're plain English comments written by the programmer to provide instructions or explain how a particular part of the program works.

Since this improves the readability of your code tremendously (and will help you debug programs more quickly, since you'll be able to tell at a glance what each part of the program is supposed to do), we encourage you to comment on your code whenever its purpose isn't immediately obvious.

\subsubsection{INSTRUCTIONS}
Write a comment on line 1 in the editor. Make sure it starts with \#! (It can say anything you like.)

\subsection{Multi-Line Comments}
Sometimes you have to write a really long comment. \# will only work across a single line, and while you could write a multi-line comment and start each line with \#, that can be a pain.

If you want to write a comment across multiple lines, you can include the whole block in a set of triple quotation marks, like so:
\begin{lstlisting}
"""I'm a lumberjack and I'm okay
I sleep all night and I work all day!"""
\end{lstlisting}

\subsubsection{INSTRUCTIONS}
Write a multi-line comment in the editor. Include whatever text you want!

\section{Math Operations}
If all we could do in Python were declare variables and write comments, it wouldn't be very exciting. Thankfully, that's not the case—we can combine and manipulate data to create powerful, flexible programs to suit our needs.

\subsection{Arithmetic Operators}
Python's statements aren't limited to simple expressions of assignment like spam = 3; they can also include mathematical expressions using arithmetic operators.

There are six arithmetic operators we're going to focus on:
\begin{itemize}
\item Addition (+)
\item Subtraction (-)
\item Multiplication (*)
\item Division (/)
\item Exponentiation (**)
\item Modulo (\%)
\end{itemize}

\subsubsection{INSTRUCTIONS}
Let's start with addition. Set the variable count\_to to the sum of 1 + 2.

\subsection{Subtraction}
Good! Now let's try subtraction.

\subsubsection{INSTRUCTIONS}
We've clearly counted too far with our count\_to—we've gotten to five but want count\_to to be smaller. Tell Python to reassign count\_to to 5 - 2.

\subsection{Multiplication}
Perfect! Now let's try a little multiplication.

\subsubsection{INSTRUCTIONS}
The Knights Who Say "Ni!" have only said "Ni!" twice. Let's make it twenty times by multiplying 2 * 10.

\subsection{Division}
On second thought, 20 "Ni!"s might be a bit much. Let's use division to get it down to 5.

\subsubsection{INSTRUCTIONS}
Set the value of ni to 5 (that is, 20 / 4).

\subsection{Exponentiation}
Excellent job!

All the arithmetic operations you've done so far have probably either been intuitive or have resembled work you've done in other programming languages (such as JavaScript). Exponentiation, however, might be a new one, so it bears some explaining.

The ** operator raises the first number, the base, to the power of the second number, the exponent. So if you type 2 ** 3, you get 8 (2 ** 3 is the same as 2 * 2 * 2, both of which equal 8). 5 ** 2 = 25, 2 ** 4 = 16, and so on.

\subsubsection{INSTRUCTIONS}
Our lumberjack is super hungry and wants 100 eggs. Set eggs to 100 using exponentiation.

\subsection{Modulo}
Impressive! That was a lot of eggs. Hope you left room for spam!

Our final arithmetic operator is modulo (also called modulus). Modulo returns the remainder left over by integer division. So, if you ask the Python interpreter to evaluate 5 \% 2, it will return 1 (since 2 goes into 5 evenly two times, with 1 left over). 10 \% 5 is 0, 113 \% 100 is 13, and so on.

\subsubsection{INSTRUCTIONS}
Turns out you did leave room for spam—but not much! Set spam equal to 1 using modulo. You can use any two numbers that will leave a remainder of 1 to do this.

\section{Review}
\subsection{Bringing It All Together}
Nice work! So far you've learned about the following in Python:
\begin{itemize}
\item Variables, which are ways to store values for later use;
\item Data types (such as integers, floats, and booleans);
\item Whitespace (and why it's significant!);
\item Statements (and how Python statements are like statements in regular English);
\item Comments (and why they're good for your code!); and
\item Arithmetic operations (including +, -, *, /, **, and %).
\end{itemize}

\subsubsection{INSTRUCTIONS}
Let's put all our knowledge to work.
\begin{itemize}
\item Write a single-line comment on line 1. It can be anything! (Make sure it starts with \# !)
\item Declare a variable, monty, and set it equal to True.
\item Declare another variable, python, and set it equal to 1.234.
\item Declare a third variable, monty\_python, and set it equal to python squared.
\end{itemize}

\section{Project: Tip Calculator}
\subsection{Your Favorite Meal}
This project is designed to complement Unit 1: Python Syntax. It assumes familiarity with only the material covered in that course.

You've just feasted on a truly delicious meal of Spam and eggs. The diner's computer is down, however, so you'll need to compute the cost of your meal yourself.

Here's how it'll break down:
\begin{itemize}
\item Cost of meal: \$44.50
\item Restaurant tax: 6.75\%
\item Tip: 15\%
\end{itemize}

You'll want to apply the tip to the overall cost of the meal (including tax).

\subsubsection{INSTRUCTIONS}
First, let's declare a variable meal and assign it the value 44.50.

\subsection{The Tax}
Good! Now let's create a variable for the tax percentage.

The tax on your meal at this diner is 6.75\%. Because we'll be multiplying with floats and not percentages, however, you'll have to divide 6.75 by 100 in order to get the decimal form of the number. Do you understand why? (See the Hint if you're not sure.)

\subsubsection{INSTRUCTIONS}
Create the variable tax and set it equal to the decimal value of 6.75%.

\subsection{The Tip}
Nice work! You received good service at this diner, so you'd like to leave a 15\% tip on top the cost of the meal (including tax).

Before we compute the tip for your overall bill, let's set a variable for the tip (15\%). Again, this is a percentage, so you'll need to divide 15.0 by 100 in order to get the decimal form of the tip.

\subsubsection{INSTRUCTIONS}
Set the variable tip to 15\% (in decimal form!) on line 5. (You can just type 0.15 directly, if you like.)

\subsection{Reassign in a Single Line}
Okay! We've got the three variables we need to perform our calculation, and we know a bunch of arithmetic operators that will be able to help us out.

We saw in Lesson 1 that we could reassign a variable when needed—for example, we could say spam = 7 at one point in the program, then later change our minds and say spam = 3.

\subsubsection{INSTRUCTIONS}
On line 7 in the editor, reassign meal to the value of itself + itself * tax (this will add the dollar amount of the tax to the cost of the meal). You're completely allowed to reassign a variable in terms of itself!
We're only calculating the cost of meal and tax here—we'll get to the tip soon!

\subsection{Second Verse, Same as the First}
Well, almost the same. Here, we're going to introduce a new variable instead of resetting an existing variable.

Now that meal's got the cost of the food + tax, let's introduce a new variable on line 8, total, that's equal to the new meal + meal * tip. (This should be very similar to what you just did in the last exercise.)

The code on line 10 will nicely format the value of total and will ensure it prints to the console with two numbers after the decimal. (We'll learn all about string formatting, the console, and the print keyword in Unit 2!)

\subsubsection{INSTRUCTIONS}
Assign the variable total to the sum of meal + meal * tip on line 8, then hit "run" to see the total cost of your meal!

\chapter{Strings and Console Output}
This tutorial will show you strings and console output for Python, including creating literal strings, calling a variety of methods of strings, and use the command "print".

\section{Strings}
Strings are an important and extremely common data type in Python. Here, we'll show you how to build and manipulate them!

\subsection{Step One: Strings}
(This course assumes familiarity with the material presented in Lesson 1: Python Syntax.)

Another useful data type in Python is the string. Strings are, well, strings of characters, which is a more formal way of saying they're really just regular English phrases. They can include numbers, letters, and various symbols, like so: "We're \#1!"

A string literal is a string created by literally just writing it down between quotation marks (' ' or " "). You have to use the same type of quotation mark on each end of the string, though—no 'string"s or "string's!

\subsubsection{INSTRUCTIONS}
Assign the string "Always look on the bright side of life!" to the variable brian.

\subsection{Step Two: Things}
Excellent! Let's get a little practice in with strings. Set the following variables to the following phrases:

\subsubsection{INSTRUCTIONS}
\begin{itemize}
\item Set caesar to "Graham"
\item Set praline to "John"
\item Set viking to "Teresa"
\end{itemize}

\subsection{Step Three: Escape!}
Don't get too comfortable: you can't use just any symbol in a string, and some results can only be achieved by special characters. The practice of including these characters in a string requires that these strings be escaped, or marked as unique. The backslash character (\\) does this work for us! We just put it directly before the character we want to escape.

\subsubsection{INSTRUCTIONS}
The string in the editor is broken: the apostrophe in I'm makes Python think the single-quote string ends there. Fix it by escaping the ' in I'm!


\subsection{Access by Offset}
Great work! (By the way, you could also have repaired the string by replacing the single quotes on the ends with double quotes, like this: "Help! Help! I'm being repressed!".)

Remember how we told you that strings were, technically speaking, strings of characters? Wouldn't it be nifty if you could get to each character in a string individually?

Well, you can!

Each character in a string has a subscript or offset, which is a fancy way of saying it has a number attached to it. The number starts at 0 for the leftmost character and increases by one as you move character-by-character to the right. Check out the diagram in the editor!

\subsubsection{INSTRUCTIONS}
\begin{lstlisting}
"""
The string "PYTHON" has six characters,
numbered 0 to 5, as shown below:

+---+---+---+---+---+---+
| P | Y | T | H | O | N |
+---+---+---+---+---+---+
  0   1   2   3   4   5

So if you wanted "Y", you could just type
"PYTHON"[1] (always start counting from 0!)
"""
fifth_letter = 

print fifth_letter
\end{lstlisting}

When you think you've got the hang of the code in the editor, set fifth\_letter equal to the fifth letter of the string "MONTY", like so: "MONTY"[?] (but replace the ? with the correct number).

\section{String Methods}
Modifying strings is useful, but doing it manually is a pain. Thankfully, Python includes a number of methods that can automate this work for us.

\subsection{Four Methods to the Madness}
Great work! Now we're going to talk about some of the methods that are available for use with strings.

We'll explain methods much more in future lessons, but for now, the takeaway is that string methods are pre-built pieces of code that perform specific tasks for strings.

We're going to focus on four string methods in this section:
\begin{itemize}
\item len()
\item lower()
\item upper()
\item str()
\end{itemize}
Let's start with len(), which gets the length of a string!

\subsubsection{INSTRUCTIONS}
Create a variable called parrot and set it to the string "Norwegian Blue" (be sure to include the space and capitalize exactly as shown!).
Then type len(parrot) on line 5, after the word print, like so: print len(parrot). This will print out the number of letters in "Norwegian Blue"!

\subsection{lower()}
Well done! Again, len() returns the length—that is, the number of characters—of the string on which it's called.

Let's say that you don't want any capitalization in your string, though (in this case, "Norwegian Blue"). In this example, it's a tiny amount of work to manually change "Norwegian Blue" to "norwegian blue". But what if you wanted to convert thousands of words to all-lower case? Doing it manually would take forever.

\subsubsection{INSTRUCTIONS}
Python is all about automation! Call lower() on parrot (after the word print) on line 5 in the editor, like so: parrot.lower(). This will make the string all lower-case! (This is different from the way you call len(), and we'll explain the reasoning behind this before this section is over.)

\subsection{upper()}
Perfect! Now your string is 100\% lower case.

\subsubsection{INSTRUCTIONS}
Unfortunately, you just realized you actually need your string to be completely upper case, not lower. Call upper() on parrot (after the word print on line 5) in order to fix this in one fell swoop!

\subsection{str()}
It looks like you're really getting the hang of string methods in Python. In case you're getting a bit bored (and we know adjusting string capitalization isn't the most exciting thing in the world), try the str() method on for size!

The str() method returns a string containing a nicely printable representation of whatever you put between the parentheses. It makes strings out of non-strings! For example,

str(2)
would turn 2 into "2".

\subsubsection{INSTRUCTIONS}
Two steps here:
\begin{itemize}
\item Create a variable pi and set it to 3.14 on line 4.
\item Call str(pi) on line 5, after the print keyword.
\end{itemize}

\subsection{Dot Notation}
As promised, we'll now explain the reason you use len(string) and str(object), but dot notation (e.g. "String".upper()) for the rest.

Dot notation works on string literals ("The Ministry of Silly Walks".upper()) and variables assigned to strings (ministry.upper()) because these methods are specific to strings—that is, they don't work on anything else.

By contrast, len() and str() can work on a whole bunch of different objects (which we'll get to later), so they can't be tied just to strings with dot notation.

\subsubsection{INSTRUCTIONS}
Let's do just a bit more practice. Call len() on ministry on line 4 and upper() on line 5 (do this after the print keyword each time).

\section{Print}
From time to time, we need to see the output of our Python programs. The "print" keyword makes this possible!

\subsection{Printing with String Literals}
The area to the right of these instructions is the editor, which is where we've been writing our code.

Python translates your instructions to instructions the computer can understand with an interpreter. You can think of the interpreter as a little program that ferries information between your Python code and the computer when you click "Save \& Submit Code." The actual window to which the interpreter spits out the output of your code is the console (the window in the upper right).

If you're familiar with JavaScript, then you know that console.log logs the result of evaluating your code to the console; print is Python's version of console.log.

If you haven't studied JavaScript, never fear! All you need to know is that print prints the result of the interpreter's evaluation of your code to the console for you to see.

\subsubsection{INSTRUCTIONS}
Let's start with something simple. Try printing "Monty Python" to the console. The syntax looks like this:
\begin{lstlisting}
print "Your string goes here"
\end{lstlisting}
Don't forget the quotes (' or ")!

\subsection{Printing with Variables}
Great! Now let's combine what we've learned about variables with our new print keyword.

\subsubsection{INSTRUCTIONS}
Declare a variable called the\_machine\_goes and assign it the string value "Ping!" on line 5. Make sure to type "Ping!" exactly as shown—complete with capital "P" and an exclamation point!
Go ahead and print the\_machine\_goes on line 6.

\section{Advanced Printing}
Now that you know how to print output to the console, let's take a look at some of the more complex features supported by "print."

\subsection{String Concatenation}
You know about strings, and you know about arithmetic operators. But did you know some arithmetic operators work on strings?

If you use the + operator between two strings, it concatenates them (glues them together).

print "Monty " + "Python"
will print out "Monty Python"!

\subsubsection{INSTRUCTIONS}
Give it a go in the editor. print the concatenated strings "Spam ", "and ", "eggs" on line 3 to print the string "Spam and eggs" to the console.

\subsection{Explicit String Conversion}
Remember when we talked about the str() method a couple of lessons back, and how it turns non-strings into strings? The fancy name for that process is explicit string conversion.

You're explicitly telling Python, "Hey, I know this isn't a string, but I want to turn it into one." Contrast this with just putting quotes around a sequence of characters to make it a string.

Making a number into a string can let you glue together strings and numbers (which Python normally won't allow). Check it out:

print "I have " + str(2) + " coconuts!"
will print "I have 2 coconuts!"

\subsubsection{INSTRUCTIONS}
\begin{itemize}
\item Run the code as-is. You get an error!
\item Use str() to turn 3.14 into a string, then run the code again.
\end{itemize}

\subsection{String Formatting with \%, Part 1}
Awesome work so far. This is the last new thing to cover before we review!

We saw earlier that you can access individual characters in a string by offset, or, if you want to think about it this way, ID number. (Remember, "PYTHON"[1] is "Y", not "P"!)

Unfortunately, strings in Python are immutable—you can't change them once they're created.

However, there is a way you can work flexibility into your strings, and that's with string formatting. It uses the \% symbol (don't confuse this with modulo!), and you can sort of think of it as a variable for your string.

\subsubsection{INSTRUCTIONS}
Take a look at the code in the editor. What do you think it'll do? Click Save \& Submit Code when you think you know.

\begin{lstlisting}
string_1 = "Camelot"
string_2 = "place"

print "Let's not go to %s. 'Tis a silly %s." % (string_1, string_2)
\end{lstlisting}

\subsection{String Formatting with \%, Part 2}
Did you see that? The \% string formatter replaced the \%s (the "s" is for "string") in our string with the variables in parentheses. (We could have done that by just putting "Camelot" and "place" in parentheses after the string, but we wanted to show you how it works with variables.)

The syntax went like this:
\begin{lstlisting}
print "%s" % (string_variable)
\end{lstlisting}
You can have as many variables (or strings!) separated by commas between your parentheses as you like:
\begin{lstlisting}
print "The %s who %s %s!" % ("Knights", "say", "Ni")
prints "The Knights who say Ni!"
\end{lstlisting}

\subsubsection{INSTRUCTIONS}
For our grand finale, we're showing you a bit of new code. Don't worry if you don't get how it works yet; we'll explain it soon!
For now, replace the \_\_\_s with the form of \% you need to complete your quest: \%s inside the string, and \% to link the string with its arguments. Answer the questions in the console as they pop up!

\begin{lstlisting}
name = raw_input("What is your name?")
quest = raw_input("What is your quest?")
color = raw_input("What is your favorite color?")

print "Ah, so your name is ___, your quest is ___, " \
"and your favorite color is ___." ___ (name, quest, color)
\end{lstlisting}

\section{Review}
Let's take a moment to go over what we've learned.

And Now, For Something Completely Familiar
Great job! You've learned a lot in this unit, including:

What strings are, and how to create them literally (using ' ' or " ") or explicitly (using the str() method);
string methods, such as len(), upper(), and lower();
the print keyword for outputting Python's evaluation of your code to the console; and
advanced printing techniques using \%.
Let's wrap it all up!

\subsection{INSTRUCTIONS}
\begin{enumerate}
\item Create a variable called my\_string and set it to any string you'd like.
\item Go ahead and print its len()gth on line 4.
\item Go for the gold and print its .upper() case version on line 5.
\end{enumerate}

\section{Project: Date and Time}
\subsection{The datetime Library}
In this small project, we'll create a program that experiments with Python's ability to give us the current date and time. This will give you some practice with printing strings, concatenation, and the str() explicit conversion function.

At the end of this section, you'll know how to print the date and time in the following format: mm/dd/yyyy hh:mm:ss.

On line 1, notice the statement from datetime import datetime. Importing special functionality into your programs will be covered in Unit 4's discussion of the import statement.

For now, just know that we're telling the Python interpreter to give our program the ability to retrieve the current date and time.

In the next exercise, we'll cover how to explicitly retrieve this information!

\subsubsection{INSTRUCTIONS}
\begin{lstlisting}
from datetime import datetime
\end{lstlisting}

\subsection{Getting the Current Date and Time}
To retrieve the current date and time, we can use a function called datetime.now() to get that information.

In a later course, you'll learn all about functions. For now, just know that datetime.now() calls on a piece of code that comes with Python that figures out the current date and time for us.

\subsubsection{INSTRUCTIONS}
\begin{enumerate}
\item Create a variable called now and store the result of datetime.now() in it. We'll use this variable in the next exercise.
\item Go ahead and print the value of the variable now.
\end{enumerate}

\subsection{Extracting Information}
Notice how we got an output of the form 2012-07-19 12:50:53.180759. That's pretty ugly.

Let's examine how to extract portions of the date and time to eventually print out a "prettier" form of this information.

Let's start by retrieving the month, day, and year from the result of datetime.now(). To do this, we can use our variable now in the following way: current\_year = now.year.

Of course, the variable on the left-hand side of the assignment could be named anything.

The fact that we can extract parts of the date in such an elegant syntax is pretty awesome. As you could guess, we can use a similar syntax to extract the month and day.

Note: Don't worry about the details of the notation now.year. It's called dot notation and it's used to access data from an object. We mentioned this briefly in Unit 2 and will talk much more about objects later.

\subsubsection{INSTRUCTIONS}
Go ahead and print out the current month, day, and year to the console on separate lines.

\subsection{Hot Date}
Great job printing out the date's components! In gearing up for our ultimate goal of printing out mm/dd/yyyy hh:mm:ss, let's tackle adding / slashes to the date's parts.

You might think to do something like:

print now.month, "/", now.day, "/", now.year
However, this would incorrectly give you spaces between the slashes. Hence, the better solution is to use string concatenation (the + operator), covered in Unit 2.

As you'll see, it's not as simple as just using concatenation—mainly because concatenation only works with strings.

When you extract information like now.year, you end up with an integer (a positive or negative whole number). To convert an integer to a string, you can use the str() function. For example, if a variable x had the value 4 and we wanted to convert that into "4", you could type:
\begin{lstlisting}
str(x)
\end{lstlisting}
\subsubsection{INSTRUCTIONS}
Print out the current date in the pretty form of mm/dd/yyyy. It's totally okay if it comes out as m/d/yyyy.

\subsection{Pretty Time}
Nice work! Let's do the same for the parts of the time—namely, the hour, minute, and second.

As you might guess, we can also use our variable now to print out the time information. If you wanted to print out the current hour, you could do:
\begin{lstlisting}
current_hour = now.hour
\end{lstlisting}
Just for clarification, our variable now contains the results of datetime.now(); there's nothing special about naming the variable "now." It's just for convenience!

\subsubsection{INSTRUCTIONS}
Similar to the last exercise, print out the current time in the pretty form of hh:mm:ss. Remember to use string concatenation.
Note: It's also okay if you end up with h:m:s.

\subsection{Grand Finale}
So far, we've managed to prettily print the date and time separately. Let's combine the two!

\subsubsection{INSTRUCTIONS}
Print out the date and time together in the form: mm/dd/yyyy hh:mm:ss
(Note that a space separates the date and time, so you'll need the + operator once more.)

\chapter{Conditionals and Control Flow}
In this course, we'll learn how to create programs that generate different outcomes based on user input!

\section{Introduction to Control Flow}
"Control flow" is the order in which events occur in a program. This section will introduce the concept of control flow and the ways in which it can be altered.

\subsection{Go With the Flow}

(This course assumes familiarity with the material presented in Unit 1: Python Syntax and Unit 2: Strings \& Console Output. From here on out, take for granted that each new course assumes knowledge of the material presented in the previous courses.)

You may have noticed that the Python programs we've been writing so far have had sort of one-track minds. They compute the sum of two numbers or print something to the console, but they don't have the ability to pick one outcome over another—say, add two numbers if their sum is less than 100, or instead print the numbers to the console without adding them if their sum is greater than 100.

Control flow allows us to have these multiple outcomes and to select one based on what's going on in the program. Different outcomes can be produced based on user input or any number of factors in the program's environment. (The environment is the technical name for all the variables—and their values—that exist in the program at a given time.)

\subsubsection{INSTRUCTIONS}

Check out the code in the editor. To help keep you motivated, we've provided a glimpse into the not-so-distant future: the type of program you'll be able to write once you've mastered control flow. Click Save \& Submit Code to see what happens!

\begin{lstlisting}
def clinic():
    print "You've just entered the clinic!"
    print "Do you take the door on the left or the right?"
    answer = raw_input("Type left or right and hit 'Enter'.").lower()
    if answer == "left" or answer == "l":
        print "This is the Verbal Abuse Room, you heap of parrot droppings!"
    elif answer == "right" or answer == "r":
        print "Of course this is the Argument Room, I've told you that already!"
    else:
        print "You didn't pick left or right! Try again."
        clinic()

clinic()
\end{lstlisting}
    
\section{Comparators}
Comparators help programs make decisions by establishing relationships between variables: for instance, which values are greater than, less than, or equal to others.
    
\subsection{Compare Closely!}

Let's not get ahead of ourselves. First, we'll start with the simplest aspect of control flow: comparators. There are six of them, and we're willing to bet at least a few look familiar:
\begin{lstlisting}
    Equal to (==)
    Not equal to (!=)
    Less than (<)
    Less than or equal to (<=)
    Greater than (>)
    Greater than or equal to (>=)
\end{lstlisting}
Note that == is used to compare whether two things are equal, and = is used to assign a value to a variable.

We hope you're familiar with the ideas of greater/less than and greater/less than or equal to. They work exactly as you think they would: they test to see if a number is (or is not) equal to, greater than (or equal to), or less than (or equal to) another number.

(If you're coming from the JavaScript track: there is no === in Python.)

\subsubsection{INSTRUCTIONS}

Let's run through the comparators in the editor. Set each variable to either True or False depending on what you think the result of the evaluation above it will be. For example, 1 < 2 will be True, because one is less than two.

\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# 17 < 118 % 100
bool_one = 

# 100 == 33 * 3 + 1
bool_two = 

# 19 <= 2**4
bool_three = 

# -22 >= -18
bool_four = 

# 99 != 98 + 1
bool_five = 
\end{lstlisting}

\subsection{Compare... Closelier}

Excellent! It looks like you're comfortable with basic expressions and comparators.

But what about... extreme expressions and comparators?

(This exercise may seem unnecessary to you, but we can't tell you the number of problems caused in programs by incorrect order of operations or reversed >s and <s. Bugs like this can be a serious problem!)

\subsubsection{Instructions}

Let's run through the comparators in the editor one more time (these expressions are more complex than what you saw in the last exercise). Again, set each variable to either True or False depending on what you think the result of the evaluation above it will be.

\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# 20 + -10 * 2 > 10 % 3 % 2
bool_one = 

# (10 + 17)**2 == 3**6
bool_two = 

# 1**2**3 <= -(-(-1))
bool_three = 

# 40 / 20 * 4 >= -4**2
bool_four = 

# 100**0.5 != 6 + 4
bool_five = 
\end{lstlisting}

\subsection{How the Tables Have Turned}

Nice work!

Based on our comparisons, you've probably guessed that comparisons in Python generate one of two results: True or False. These are instances of a data type we mentioned briefly in Unit 1 called booleans, and they are the only two instances. Things aren't "sort of True" or "Falseish" or "maybe" in Python—they are True or False (and are always capitalized, unlike in JavaScript).

Let's reverse things a bit: we'll supply the boolean value (True or False), and you write an expression that evaluates appropriately.

\subsubsection{Instructions}

For each boolean value in the editor, write an expression that evaluates to that value. Feel free to write expressions that are as simple or as complex as you'd like! Remember, though: simple is better than complex!

Remember, comparators are: ==, !=, >, >=, <, and <=.

\begin{lstlisting}
# Create comparative statements as appropriate on the lines below!

# Make me true!
bool_one = 

# Make me false!
bool_two = 

# Make me true!
bool_three = 

# Make me false!
bool_four = 

# Make me true!
bool_five = 
\end{lstlisting}

\section{Boolean Operators}
Boolean (or logical) operators help programs make decisions based on whether something AND something else is true, something OR something else is true, or something is NOT true.

\subsection{To Be and/or Not to Be}

Boolean operators (or logical operators) are words used to connect Python statements in a grammatically correct way—almost exactly as in regular English. There are three boolean operators in Python:

    and, which means the same as it does in English;
    or, which means "one or the other OR BOTH" (it's not exclusively one or the other, the way it often is in English);
    not, which means the same as it does in English.

We want to stress this second case to you: if your mom tells you you can have Monty Python and the Holy Grail or Monty Python's Life of Brian, she probably means "one or the other, but not both." Python, on the other hand, would be totally fine with your picking both, so long as you don't pick neither. Python is cooler than your mom.

Boolean operators result (predictably) in boolean values—True or False. We'll go through the three operators one by one.

\subsubsection{Instructions}

Before we get started with and, take a look at the truth table in the editor. (This is for those of you who like to see the bigger picture before we dive into the details.) Don't worry if you don't completely get it yet—you will by the end of this section!

\begin{lstlisting}
"""
     Boolean Operators
---------------------------
True and True is True
True and False is False
False and True is False
False and False is False

True or True is True
True or False is True
False or True is True
False or False is False

Not True is False
Not False is True

"""
\end{lstlisting}

\subsection{And}

The boolean operator and only results in True when the expressions on either side of and are both true. An expression is any statement involving one or more variables and operators (arithmetic, logical, or boolean). For instance:

1 < 2 and 2 < 3 results in True because it is true that one is less than two and that two is less than three.

1 < 2 and 2 > 3 results in False because it is not true that both statements are true—one is less than two, but two is not greater than three.

\subsubsection{Instructions}

Let's practice a bit with and. Assign the boolean values beneath each expression as appropriate. This may seem overkill, but remember: practice makes perfect.

\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# False and False
bool_one = 

# -(-(-(-2))) == -2 and 4 >= 16**0.5
bool_two = 

# 19 % 4 != 300 / 10 / 10 and False
bool_three = 

# -(1**2) < 2**0 and 10 % 10 <= 20 - 10 * 2
bool_four = 

# True and True
bool_five = 
\end{lstlisting}

\subsection{Or}
The boolean operator or only returns True when either (meaning one, the other or both!) of the expressions on each side of or are true. (It's only False when both expressions are False.) For example:

    1 < 2 or 2 > 3 is True, even though two is not greater than three;
    1 > 2 or 2 > 3 is False, because it is neither the case that one is greater than two nor that two is greater than three.

\subsubsection{Instructions}

Time to practice with or!

\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# 2**3 == 108 % 100 or 'Cleese' == 'King Arthur'
bool_one = 

# True or False
bool_two = 

# 100**0.5 >= 50 or False
bool_three = 

# True or True
bool_four = 

# 1**100 == 100**1 or 3 * 2 * 1 != 3 + 2 + 1
bool_five = 
\end{lstlisting}

\subsection{Not}

The boolean operator not returns True for false statements and False for true statements. Remember, the only two boolean values are True and False!

For example:

not False will evaluate to True, as will not 40 > 41. Applying not to expressions that would otherwise be true makes them False.

\subsubsection{Instructions}

Last but not least, let's get some practice in with not.
\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# not True
bool_one = 

# not 3**4 < 4**3
bool_two = 

# not 10 % 3 <= 10 % 2
bool_three = 

# not 3**2 + 4**2 != 5**2
bool_four = 

# not not False
bool_five = 
\end{lstlisting}

\subsection{This and That (or This, But Not That!)}

Fun fact: boolean operators can be chained together!

It's important to know that boolean operators are not evaluated straight across from left to right all the time; just like with arithmetic operators, where / and * are evaluated before + and - (remember Please Excuse My Dear Aunt Sally?), there is an order of precedence or order of operations for boolean operators. The order is as follows:

    not is evaluated first;
    and is evaluated next;
    or is evaluated last.

This order can be changed by including parentheses (()). Anything in parentheses is evaluated as its own unit.

For instance, True or not False and False returns True. Can you see why? If not, check out the Hint.

Best practice: always use parentheses (()) to group your expressions to ensure they're evaluated in the order you want. Remember: explicit is better than implicit!

\subsubsection{Instructions}

Go ahead and assign True or False as appropriate for bool\_one through bool\_five. No math in this one!

\begin{lstlisting}
# Assign True or False as appropriate on the lines below!

# False or not True and True
bool_one = 

# False and not True or True
bool_two = 

# True and not (False or False)
bool_three = 

# not not True or False and not True
bool_four = 

# False or not (True and True)
bool_five = 
\end{lstlisting}

\subsection{Mix 'n Match}

Great work! We're almost done with boolean operators.

\subsubsection{Instructions}

Finally, let's try it the other way 'round—we'll provide the expected result (True or False), and you use any combination of boolean operators you want to achieve that result.

Remember, the boolean operators are and, or, and not.

\begin{lstlisting}
# Use boolean expressions as appropriate on the lines below!

# Make me false!
bool_one = 

# Make me true!
bool_two = 

# Make me false!
bool_three = 

# Make me true!
bool_four = 

# Make me true!
bool_five = 
\end{lstlisting}

\section{If, Else and Elif}
"If," "else," and "elif" are conditional statements that round out the process by which Python programs make decisions—for example, "if there's Spam, eat it! If not, watch TV."
    
\subsection{Conditional Statement Syntax}

Remember when we showed you that whitespace in Python is significant? If not, write this down: whitespace in Python is significant. If you've learned any JavaScript here on Codecademy, you know that the block of code an if statement executes is bound by curly braces ({}). In Python, whitespace (tabs or spaces) does this work for us.

Here's an example of if statement syntax in Python:

if 8 < 9:
    print "Eight is less than nine!"

if is always followed by an expression, which is followed by a colon (:). The code block (the code to be executed if the expression evaluates to True) is indented four spaces.

This is also true for elif and else (which we'll get to in a moment). The full syntax would look something like this:

if 8 < 9:
    print "I get printed!"
elif 8 > 9:
    print "I don't get printed."
else:
    print "I also don't get printed!"

\subsubsection{Instructions}

Here's a piece of code that should look familiar: it's a snippet from the example we showed you in 1.1, "Introduction to Control Flow." If you think the print statement will print to the console, set response equal to 'Y'; otherwise, set response equal to 'N'.

\begin{lstlisting}
response = 

answer = "Left"
if answer == "Left":
    print "This is the Verbal Abuse Room, you heap of parrot droppings!"
    
# Will the above print statement print to the console?
# Set response to 'Y' if you think so, and 'N' if you think not.
\end{lstlisting}

\subsection{If You're Having...}

Let's get some practice in with if statements. Remember, the syntax looks like this:

\begin{lstlisting}
if expression:
    # block line one
    # block line two
    # et cetera
\end{lstlisting}

\subsubsection{Instructions}

Write two if statements in the editor: one that returns True, and a second that returns False. Use any expressions you like! (Don't worry about def and return just yet—we'll cover those in the next unit.)

\begin{lstlisting}
# Write your two if statements below!

def true_function():
    if                # Fill in your if statement here!
        return        # Make sure this returns True

def false_function():
    if                # Fill in your if statement here!
        return        # Make sure this returns False
\end{lstlisting}

\subsection{Else Problems, I Feel Bad for You, Son...}

The else statement in Python is the complement to the if statement. While an if statement will return control of the program to the next line of code after the if code block even if there's no else statement, it's considered a good habit to pair each if with an else.

An if/else pair says to Python: "If this expression is true, run this indented code block; otherwise, run this code after the else statement."

Remember when we said "set response equal to 'Y', otherwise, set it to 'N'" in the first exercise of this section? That was a kind of if/else statement!

\subsubsection{Instructions}

Complete the else statements to the right. Remember to capitalize your booleans, and note the indentation for each line! It's important.

\begin{lstlisting}
# Write your two else statements below!
answer = "'Tis but a scratch!"

def black_knight():
    if answer == "'Tis but a scratch!":
        return True
    else:             # Fill in your else statement here!
        return        # Make sure this returns False

def french_soldier():
    if answer == "Go away, or I shall taunt you a second time!":
        return True
    else:             # Fill in your else statement here!
        return        # Make sure this returns False
\end{lstlisting}

\subsection{I Got 99 Problems, But a Switch Ain't One}

"Elif" is short for "else if." It means exactly what it sounds like: "otherwise, if the following code is true, do this!"

If you're coming from JavaScript, you may know that you have two choices when you have a chain of conditional statements: a bunch of else if statements, or a switch statement. Python simplifies this for you: there's only elif.

\subsubsection{Instructions}

Fill in the elif statement in the editor such that it returns True for the answer "I like Spam!"

You'll want to check whether answer equals the "I like Spam!" string after elif.
\begin{lstlisting}
# Write your two elif statements below!
answer = "I like Spam!"

def feelings_about_spam():
    if answer == "I hate Spam!":
        return False
    elif              # Check the answer variable here!
        return        # Make sure this returns True
    else:
        return False
\end{lstlisting}

\section{Review}
Let's take some time to review what we've covered in this unit.
\subsection{The Big If}

Really great work! Here's what you've learned in this unit:
\begin{itemize}
\item Basics of control flow;
\item Comparators (such as >, <, and ==);
\item Boolean operators (and, or, and not);
\item And conditional statements (if, else, and elif).
\end{itemize}

Let's get to the grand finale.
\subsubsection{Instructions}

Write an if statement in the\_flying\_circus(). It must include:
\begin{itemize}
\item and, or, or not;
\item ==, !=, <, <=, >, or >=;
\item an if, elif, AND else statement;
\item it must return True when evaluated.
\end{itemize}

\chapter{Project: PygLatin}
In this project we'll put together all of the Python skills we've learned so far including string manipulation and branching. We'll be building a Pyg Latin translator. (That's Pig Latin for Python Programmers!)

\section{PygLatin Part 1}
This project will put together all the Python concepts we've been learning to build an English to PYg Latin Translator.

\subsection{Break It Down}

When you start a big project like this, it's important to take some time to break the problem into individual steps. Then you can tackle (and test) one step at a time rather than trying to write a huge program all at once!

Let's think about the PygLatin problem. Pig Latin is a language where we take the first letter of a word and put it on the end while also adding a vowel sound. So dog becomes "ogday". What are the steps we need to take?
\begin{enumerate}
\item    Ask the user to input a word in English
\item    Check to make sure the user entered a valid word
\item    Convert the word from English to Pig Latin
\item    Display the translation result
\end{enumerate}

Notice that some of the steps can themselves be broken down into individual steps. For example, we'll want to think through the algorithm for step \#3 before we start coding.

A little bit of time invested in thinking through the decomposition of and algorithms for your program can save you a LOT of frustration down the road!

Get a piece of paper and work out an algorithm for step \#3 of the project.

\subsubsection{Instructions}

All set? When you're ready to get coding, click the Run button to continue. Since we took the time to write out the steps for our solution, you'll know what's coming next!

\subsection{Ahoy! (or Should I Say Ahoyay!)}

This project will be a workout, so let's warm up by printing a welcome message for our translator users.

\subsubsection{Instructions}

Use Python to print "Welcome to the English to Pig Latin translator!" to the console.

\subsection{Input!}

If we're going to translate an English word into Pig Latin, the first thing we're going to need is a word.

Python can ask for input from the user with the raw\_input command. For example, if you type:
\begin{lstlisting}
name = raw_input("What's your name?")
\end{lstlisting}
Python will print:
\begin{lstlisting}
What's your name? >
\end{lstlisting}
Once you type something and hit Enter, Python will store whatever you typed in the name variable.
\subsubsection{Instructions}

Below your existing code, prompt the user to enter a word, and store it in a variable called original. The prompt message can be whatever you want!

\subsection{Check Yourself!}

Whenever you ask a user for input, it's a good idea to check the result that you get before you use it in your program.

In this case, we want to make sure that the input is something we can reliably translate into Pig Latin. That is, we want to make sure we got something resembling an English word.

The first thing we can check is that there are characters in our string. Let's check to make sure the string isn't empty. How can we check to make sure that our original variable isn't empty?
\subsubsection{Instructions}

Write an if statement that checks to see if the string is not empty.
\begin{itemize}
\item    If the string is not empty, print the user's word.
\item    Otherwise (else), print "empty" if the string is empty.
\end{itemize}
Make sure you thoroughly test your code. You'll want to make sure you run it multiple times and test both an empty string and a string with characters. When you are confident that your code works, continue on to the next exercise.

\subsection{Check Yourself... Some More}

Great! Now we know we have a non-empty string. Let's be even more thorough, though. After all, a user might try to be tricky and enter something like 8675309 which, since it is numbers not letters, would not make sense in PygLatin.

Let's add to our input validation and make sure that the word the user enters contains only alphabetical characters. You can use the isalpha() function to check this. To check if the string "J123" within a variable x is alphabetical, you could do:
\begin{lstlisting}
x = "J123"
x.isalpha() # False
\end{lstlisting}

\subsubsection{Instructions}

Add onto your if condition to check that the word is also composed of all alphabetical characters. You should end up with a single if-else statement that makes sure original is a non-empty alphabetical string.

Make sure to check both an all-alphabetical string and one with letters and numbers!

\subsection{Pop Quiz!}

Teachers sometimes give pop quizzes to make sure their students are mastering current material. Similarly, when you're working on a big project, you should periodically take time to really put your program to the test.

When you finish one part of your program, it's important to test it multiple times, using a variety of inputs.
\subsubsection{Instructions}

Take some time right now to test your current code. Make sure you try some inputs that should pass the word test and some that should fail. Enter some strings that contain non-alphabetical characters and an empty string.

When you're convinced your code is ready to go, click Save \& Submit Code to move on to the next step!

\section{PygLatin Part 2}
Let's continue to build our PygLatin translator!

\subsection{Ay B C}

Now that we know we have a good word, we can get ready to start translating to Pig Latin! Let's quickly review the rules for translation:
\begin{enumerate}
\item If the original word starts with a vowel, you append the suffix 'ay' to the end of the word.
\begin{lstlisting}
Example: anaconda -> anacondaay
\end{lstlisting}
\item If the original word starts with a consonant, you move the first letter of the word to the end, and then append the suffix 'ay'.
\begin{lstlisting}
Example: python -> ythonpay
\end{lstlisting}
\end{enumerate}
Let's create a variable to hold our translation suffix.
\subsubsection{Instructions}
Create a variable named pyg and set it equal to the suffix 'ay'.

\subsection{Word Up}

Since the translation rules depend on the first letter of the word we are translating, we need to grab it so we can check if it is a consonant or a vowel. To simplify things, we'll also go ahead and make sure that all the letters in our word are lowercase to make things a little easier.

To convert a word to all lowercase letters, we can use lower(). For example, to convert the string value "FOO" in a variable x to lowercase, we could do the following:
\begin{lstlisting}
x = "FOO"
x.lower()  # "foo"
\end{lstlisting}
You'll want to think about where to put the code that you write in this step. It really only makes sense to do these steps if you already know that you have a useable word, so make sure you put this code inside the if/else block.
\subsubsection{Instructions}
\begin{itemize}
\item Convert the variable original to all lowercase letters. Store the result in a variable named word.
\item    Create a new variable called first that holds the first letter of word.
\end{itemize}

\begin{lstlisting}
pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    print original
else:
    print 'empty'
\end{lstlisting}

\subsection{E-I-E-I-O}

Now that we have access to the first letter of our word, we need to check to see if it is a vowel or a consonant. Since there are way fewer vowels than consonants, it is easier to explicitly check for a vowel. (The vowels in English are: a, e, i, o and u.)

Again, it only makes sense to do this check if we already know that we have a "good" word (one that isn't empty and is all alphabetical characters). You have a couple of options on how to organize your code.

You could add onto your existing if condition to check that something is a good word and starts with a vowel. But then you'd have to add an elif to check if the word is a good word and starts with a consonant.

In this case, it makes more sense to nest the new if block inside the if part of the existing if/else. This means that the whole if/else that you will create here goes inside the if part of your existing if/else block.

A nested if/else looks like this:

\begin{lstlisting}
if condition:
    if other_condition:
        # Do something
    else:
        # Do something else!
else:
    # Do yet another thing

\end{lstlisting}

\subsubsection{Instructions}

Add a new if/else block nested inside of your existing one.

The new if should check to see if the first letter of word is a vowel. If it is, your code should print "vowel". If the first letter of word is not a vowel, your code should print "consonant".

You can remove the print original line from your code.

\subsection{I'd Like to Buy a Vowel}

Now that we have the logical structure in place to check for a vowel, let's put in the code to do the actual translation.

Remember that if a word starts with a vowel, you translate it to Pig Latin by appending our suffix ("ay") to the end of the word.

We'll want to make sure we output the result of the translation so we can check our work.
\subsubsection{Instructions}

Create a new variable called new\_word that contains the result of appending 'ay' to the end of word. (Remember that this suffix is stored in the variable pyg.)

Make sure you are only doing this in the case where the word starts with a vowel. Don't worry about the consonants just yet, we'll get to them in the next step!

After the translation, print the new word so you can check your work. (This should replace the print 'vowel' bit of your code.) Make sure to test your code with a word that starts with a vowel!

\subsection{Almost Oneday!}

Now that we have the vowel case working, all that's left is to tackle the consonant case (our inner else, since a letter can only be a consonant or a vowel).

The rule for translation here is a little trickier. You have to remove the first letter from the word, move it to the end, and then append the 'ay' suffix.

The most appropriate way to get the remainder of the string after removing the first letter is to use slicing. If you have a string s, you can get the "slice" of s from i to j using s[i:j]. This gives you the characters from position i to j.

For example, if s = "foo", then s[0:2] gives you "fo". Think about how to use this technique to get the rest of the string minus the first character.

\subsubsection{Instructions}

Inside the else part of your if/else block that checks the first letter of the word, set the new\_word variable equal to the translation result for a word that starts with a consonant.

Replace the print 'consonant' bit with print new\_word. Make sure to test your code with a word that starts with a consonant!

\subsection{Testing, Testing, is This Thing On?}

Yay! You should have a fully functioning Pig Latin translator. Just to make sure everything is working smoothly, make sure you test your code thoroughly.

You'll also want to go back through and take out any print statements that you were using to help debug intermediate steps of your code. While you're cleaning things up—now might be a good time to add some comments too! Making sure your code is clean, commented, and fully functional is just as important as writing it in the first place.

\subsubsection{Instructions}

When you're sure your translator is working just the way you want it, click Save \& Submit Code to finish this project.

\begin{lstlisting}
pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    print original
else:
    print 'empty'
\end{lstlisting}

\chapter{Functions}
A function is a reusable section of code written to perform a specific task in a program. We gave you a taste of functions in Unit 3; here, you'll learn how to create your own.

\section{Introduction to Functions}
It's... functions!
\subsection{Documentation: a PSA}

Codecademy is a great educational tool—you can think of it as an online classroom for learning a programming language. It's important to remember, however, that the emphasis should be on your approach to problems and learning to think like a programmer, and not on memorizing every single method or nuance of syntax to be found in a given programming language.

Think of it this way: if you're going to Germany, you wouldn't say to yourself, "Hey, I took a year of German in college, I don't need my dictionary or translation app!" You would totally bring those things to help remind you of vocabulary and syntax in case you were to get stuck; even professional translators keep dictionaries and grammar guides handy for unusual words and tricky constructions.

Much like professional translators, professional programmers refer to documentation when they're not clear on best practices, forget how a certain method works, or need to look up syntax. Python's documentation can be found here. We encourage you to read through it on your own!
\subsubsection{Instructions}

Part of Python's documentation are the PEPs, or "Python Enhancement Proposals." PEP 20, "The Zen of Python," is something of an easter egg hidden in the interpreter (you may have caught us quoting from it in instructional text or hints).

Type import this in the editor to see what happens (we'll learn about the import keyword later in this lesson). Scroll to read all the text output to the console.

\subsubsection{What Good are Functions?}

A function is a reusable section of code written to perform a specific task in a program. You might be wondering why you need to separate your code into functions, rather than just writing everything out in one giant block. You might have guessed the answer(s) already, but here are some of the big ones:
\begin{enumerate}
\item    If something goes wrong in your code, it's much easier to find and fix bugs if you've organized your program well. Assigning specific tasks to separate functions helps with this organization.

\item    By assigning specific tasks to separate functions (an idea computer scientists call separation of concerns), you make your program less redundant and your code more reusable—not only can you repeatedly use the same function in a single program without rewriting it each time, but you can even use that function in another program.

\item    When we learn more about objects, you'll find out there are a lot of interesting things we can do with functions that belong to those objects (called methods).
\end{enumerate}
\subsubsection{Instructions}

Check out the code in the editor. If you completed the Tip Calculator project, you'll remember going through and calculating tax and tip in one chunk of program. Here you can see we've defined two functions: tax to calculate the tax on a bill, and tip to compute the tip.

See how much of the code you understand at first glance (we'll explain it all soon). When you're ready, click Save \& Submit Code to continue.

\begin{lstlisting}
def tax(bill):
    """Adds 8% tax to a restaurant bill."""
    bill *= 1.08
    print "With tax: %f" % bill
    return bill

def tip(bill):
    """Adds 15% tip to a restaurant bill."""
    bill *= 1.15
    print "With tip: %f" % bill
    return bill
    
meal_cost = 100
meal_with_tax = tax(meal_cost)
meal_with_tip = tip(meal_with_tax)
\end{lstlisting}

\subsection{Ample Examples}

All right! Now that you know what functions are good for, it's time to see one in action. (Hopefully it's familiar to you!)

You'll see in the editor a variable, length, assigned to the result or output of a function, len(). This function is built into Python (we'll see how to define our own functions in a moment—you got a sneak peek in the last exercise). Here's how the code to the right works:
\begin{enumerate}
\item    It first evaluates the right hand-side of the assignment. To evaluate the function call, it looks at the long string in parentheses.
\item    Since it's a string literal, it doesn't need to be evaluated (that is, it's not an expression that Python has to figure out, like 1 + 1). So, this string is fed directly as an input to the len() function.
\item    len() accepts this input and returns (or outputs) an integer representing the length of the literal string (in this case 45, including spaces and punctuation).
\end{enumerate}
We've tossed in a print statement to show you that the result is, in fact, 45.
\subsubsection{Instructions}

Replace the string literal inside len's parentheses with a stringified version of the number 45. That is, don't just type "45", but actually use a string function to turn 45 into a string.

\section{Function Syntax}
Functions are great for automating tasks you're going to use over and over, or for making it easy to refer to large sections of your program using one specific name. But how are they put together?

\subsection{Function Junction}

Functions are defined using the keyword def (short for "define"). Functions have three parts:

    The header, which includes the def keyword, the name of the function, any arguments the function takes inside parentheses (()), and a colon (:). (We'll get to arguments in the next exercise);
    An optional docstring, which is a triple-quoted, multi-line comment that briefly explains what the function does;
    And the body, which is the code block that describes the procedures the function carries out. The body is indented (much like for if, elif, and else statements).

Here's an example of what the syntax would look like for a simple function, ni\_sayer, that just prints "Ni!" to the console:
\begin{lstlisting}
def ni_sayer():
    """Prints 'Ni!' to the console."""
    print "Ni!"
\end{lstlisting}

(This is not a very good example of a docstring—ideally, the docstring should explain something that isn't blindingly obvious.)
\subsubsection{Instructions}

Time for you to make your own simple function. Go ahead and create a function, spam, that prints the string "Eggs!" to the console. Be sure to use the capitalization and punctuation shown! Don't forget to include a docstring of your own choosing (just remember to enclose it in triple quotes).

\begin{lstlisting}
# Define your spam function starting on line 5. You
# can leave the code on line 11 alone for now--we'll
# explain it soon!






# Define the spam function above this line.
spam()
\end{lstlisting}

\subsection{Call and Response}

Defining a function is all well and good, but it's not much use to you unless you call it. That's the code you saw on line 11 in the previous exercise: when Python saw spam(), it understood that to mean: "Look for the function called spam and execute the code inside it." The parentheses after the function name let Python know that spam is the name of a function.

\subsubsection{Instructions}

We've set up a function, square, in the editor to the right. Call it on the number 10 on line 9 to see what it does! (That is, put 10 between the parentheses of square().)

\begin{lstlisting}
def square(n):
    """Returns the square of a number."""
    squared = n**2
    print "%d squared is %d." % (n, squared)
    return squared
    
# Call the square function on line 9! Make sure to
# include the number 10 between the parentheses.
\end{lstlisting}

\subsection{No One Ever Does}

If a function takes arguments, we say it accepts or expects those arguments. For instance, if the function no\_one takes a single argument, "The Spanish Inquisition", we would say that no\_one expects "The Spanish Inquisition".

Ha!

To be precise, the argument is the piece of code you actually put between the function's parentheses when you call it, and the parameter is the name you put between the function's parentheses when you define it. For instance, when we defined square in the previous exercise, we gave it the parameter n (for "number"), but passed it the argument 10 when we called it.

You can think of parameters as nicknames the function definition gives to arguments, since it doesn't know ahead of time exactly what argument it's going to get.

The syntax for a function that just prints out the argument it expects would look something like the below.

Function definition:
\begin{lstlisting}
def no_one(sentence):
    print sentence
\end{lstlisting}
Calling the function:
\begin{lstlisting}
no_one("The Spanish Inquisition")
\end{lstlisting}
And the console would display:
\begin{lstlisting}
"The Spanish Inquisition"
\end{lstlisting}
which is the value the parameter sentence takes on when you call no\_one and pass the argument "The Spanish Inquisition".
\subsubsection{Instructions}

Make sense? Good! Check out the function in the editor, power. It should take two arguments, a base and an exponent, and raise the first to the power of the second. It's currently broken, however, because its parameters are missing.

Replace the \_\_\_s with the parameters base and exponent and call power on a base of 37 and a power of 4.

\begin{lstlisting}
def power(___, ___):  # Add your parameters here!
    result = base**exponent
    print "%d to the power of %d is %d." % (base, exponent, result)

power()  # Add your arguments here!
\end{lstlisting}

\subsection{Splat!}

Speaking of not knowing what to expect: your functions not only don't know what arguments they're going to get ahead of time, but occasionally, they don't even know how many arguments there will be.

Let's say you have a function, favorite\_actor, that prints out the argument it receives from the user. It might look something like this:

\begin{lstlisting}
def favorite_actor(name):
    """Prints out your favorite actor."""
    print "Favorite actor is: " , name
\end{lstlisting}
This is great for just one actor, but what if you want to print out the user's favorite actors, without knowing how many names the user will put in?

The solution: splat arguments. Splat arguments are an arbitrary number of arguments, and you use them by preceding your parameter with a *. This says to Python, "Hey man, I don't know how many arguments there are about to be, but it could be more than one." The convention is to use *args, but you can use just about any name you like with a * before it.
\subsubsection{Instructions}

Replace the \_\_\_\_\_s in the function to the right with the appropriate code and click Save \& Submit Code to see who your favorite actors are (or, at least, who they should be). Remember to include a * before your parameter (between the parentheses on line 1).

You don't need the * when you replace the \_\_\_\_\_ on line 3—just the parameter name you chose on line 1.

\begin{lstlisting}
def favorite_actors(_____):
    """Prints out your favorite actorS (plural!)"""
    print "Your favorite actors are:" , _____
    
    
favorite_actors("Michael Palin", "John Cleese", "Graham Chapman")
\end{lstlisting}

\subsection{Functions Calling Functions}

So far, we've seen functions that can print text to the console or do simple arithmetic, but functions can be much more powerful than that. For example, it's completely permissible for a function to call another function.
\subsubsection{Instructions}

Check out the two functions in the editor: one\_good\_turn and deserves\_another. The first function adds 1 to number it gets as an argument, and the second adds 2.

In the body of deserves\_another, change the function so that it always adds 2 to the output of one\_good\_turn.

\begin{lstlisting}
def one_good_turn(n):
    return n + 1
    
def deserves_another(n):
    return n + 2
\end{lstlisting}

\subsection{Practice Makes Perfect}

You never really know how to do something until you do it yourself. We're taking the training wheels off now: time for you to define and call functions all on your lonesome. No examples, no code in the editor. Not even a hint! (Well, okay, one hint.)

And while we're thinking of it: you can always practice your functions (or any Python code) in either the scratch pad. Experimenting in the Labs is a great way to reinforce what you've learned in Codecademy lessons.
\subsubsection{Instructions}
\begin{enumerate}
\item    Define a function called cube that takes a number and returns the cube of that number. (Cubing a number is the same as raising it to the third power).

\item    Define a second function called by\_three that takes one number as an argument. If that number is evenly divisible by 3, by\_three should call cube on that number. If the number is not evenly divisible by 3, cube should return False.
\end{enumerate}
So, for example, by\_three should take 9, determine it's evenly divisible by 3, and pass it to cube, who returns 729 (the result of 9**3). If by\_three gets 4, however, it should return False and leave it at that.

    
\section{Importing Modules}
Remember that scene in The Matrix where Neo learns kung fu by downloading a program directly into his brain? Importing modules: just like that.

\subsection{I Know Kung Fu}

Remember import this from the first exercise in this course? That was an example of importing a module. A module is a file that contains definitions—including variables and functions—that you can use. It would clutter up the interpreter to keep all these variables and functions around all the time, so you just import the module you want when you need something from it.
\subsubsection{Instructions}

Before we try any fancy importing, let's see what Python already knows about square roots. On line 3 in the editor, ask Python to
\begin{lstlisting}
print sqrt(25)
\end{lstlisting}
which we would expect to equal five.

\subsection{Generic Imports}

Did you see that? Python said: "NameError: name 'sqrt' is not defined." Python doesn't know what square roots are—yet.

There is a Python module named math that includes a number of useful variables and functions, and (as you've probably guessed) sqrt() is one of those functions. In order to get to it, all you need is the import keyword. When you simply import a module this way, it's called a generic import.

\subsubsection{Instructions}

You'll need to do two things here:
\begin{enumerate}
\item    Type import math on line 2 in the editor, and
\item    Insert math. (that's math, followed by a period) before sqrt(). This tells Python not only to import math, but to get the sqrt() function from within math.
\end{enumerate}
Once you've done this, hit "run" to see what Python now knows.

\subsection{Function Imports}

Nice work! Now Python knows how to take the square root of a number (as well as how to do everything contained in the math module).

Importing the entire math module is kind of annoying for two reasons, though: first, we really only want the sqrt function, and second, we have to remember to type math.sqrt() any time we want to retrieve that function from the math module.

Thankfully, it's possible to import only certain variables or functions from a given module. Pulling in just a single function from a module is called a function import, and it's done using the from keyword, like so:
\begin{lstlisting}
from module import function
\end{lstlisting}
where "module" and "function" are replaced by the names of the module and function you want. The best part is, now you only have to type sqrt() to get the square root of a number—no more math.sqrt()!
\subsubsection{Instructions}

Let's import the sqrt function from math again, only this time, let's only get the sqrt function. (You don't need the () after sqrt in the from math import sqrt bit.)

\subsection{Universal Imports}

Great! We've found a way to handpick the variables and functions we want from the modules that contain them.

What if we want a large selection (or all) of the variables and functions available in a module? We can import module, but there's another option.

When you import math, you're basically saying: "Bring the Math Box to my apartment so I can use all the cool stuff in it." Whenever you want a tool in math, you have to go to the box and pull out the thing you want (which is why you have to type math.name for everything—even though the box is in your apartment, all the cool stuff you want is still in that box).

When you choose from math import sqrt, you're saying: "Bring me only the square root tool from the Math Box, and don't bring the Math Box to my apartment." This means you can use sqrt without reference to math, but if you want anything else from math, you have to import it separately, since the whole Math Box isn't in your apartment for you to dig through.

The third option is to say: "Don't bring the Math Box to my apartment, but bring me absolutely every tool in it." This gives you the advantage of having a wide variety of tools, and since you have them in your apartment and they're not all still stuck in the Math Box, you don't have to constantly type math.name to get what you want.

The syntax for this is:
\begin{lstlisting}
from module import *
\end{lstlisting}
If you're familiar with CSS, you've seen that * can stand for "every selector," and it serves a similar function in Python: it stands in for every variable and function name in a module.
\subsubsection{Instructions}

Use the power of from module import * to import everything from the math module on line 3 of the editor.

\subsection{Here Be Dragons}

Here's something we've learned in life (and not just from programming): just because you can do something doesn't mean that you should.

Universal imports may look great on the surface, but they're not a good idea for one very important reason: they can fill your program with a ton of variable and function names, but without the safety of those names still being associated with the module(s) they came from.

If you have a function of your very own named sqrt and you import math, your function is safe: there is your sqrt and there is math.sqrt, and ne'er the twain shall meet. If you do from math import *, however, you have a problem: namely, two different functions with the exact same name.

Even if your own definitions don't directly conflict with names from imported modules, if you import * from several modules at once, there won't be any way for you to figure out which variable or function came from where. It'd be like having someone dump a ton of random stuff from a bunch of different boxes in your apartment, then throwing the boxes away so you can't even see where the stuff came from.

For these reasons, it's best to stick with either import module and suffer the inconvenience of having to type module.name, or just import specific variables and functions from various modules as needed.

\subsubsection{Instructions}

Line 1 and line 3 in the editor should look familiar to you; line 2 is an example of some of the cool stuff you'll be able to do in future lessons. In a nutshell, this code will show you everything available in the math module.

Click Save \& Submit Code to check it out (you'll see sqrt, along with some other useful things like pi, factorial, and trigonometric functions). Feel free to spend a few minutes playing around with them!



\section{Built-In Functions}

    Just because you didn't define a function for Python doesn't mean it doesn't know it. Python has a number of built-in functions you can use to write all sorts of powerful, elegant programs.

\subsection{On Beyond Strings}

Now that you understand what functions are and how to import modules, it's worth showing you some of the cool functions that are built in to Python (no modules required!).

You already know about some of the built-in functions we've used on (or to create) strings, such as .upper(), .lower(), str(), and len(). These are great for doing work with strings, but what about something a little more analytic?
\subsubsection{Instructions}

Check out the code in the editor. What do you think it'll do? Click Save \& Submit Code when you think you have an idea.

\begin{lstlisting}
def biggest_number(*args):
    print max(args)
    return max(args)
    
def smallest_number(*args):
    print min(args)
    return min(args)

def distance_from_zero(arg):
    print abs(arg)
    return abs(arg)


biggest_number(-10, -5, 5, 10)
smallest_number(-10, -5, 5, 10)
distance_from_zero(-10)
\end{lstlisting}

\subsection{max()}

The max() function takes any number of arguments and returns the largest one. ("Largest" can have odd definitions here, so it's best to use max() on things like integers and floats, where the results are straightforward, and not on other objects, like strings.)

For example, max(1,2,3) will return 3 (the largest number in the set of arguments).
\subsubsection{Instructions}

Try out the max() function on line 3 of the editor. You can provide any number of integer or float arguments to max().

\begin{lstlisting}
# Set maximum to the max value of any set of numbers on line 3!

maximum = 

print maximum
\end{lstlisting}

\subsection{min()}

As you might imagine, min() does the opposite of max()—given a series of arguments, it returns the smallest one.
\subsubsection{Instructions}

Go ahead and set minimum equal to the min() of any set of integers or floats you'd like.

\begin{lstlisting}
# Set minimum to the min value of any set of numbers on line 3!

minimum = 

print minimum
\end{lstlisting}


\subsection{abs()}

The abs() function returns the absolute value of the number it takes as an argument—that is, that number's distance from 0 on an imagined number line, regardless of whether it's positive or negative. For instance, 3 and -3 are both equally far from 0, and thus have the same absolute value: 3. The abs() function always returns a positive value, and unlike max() and min(), it can only take a single number.
\subsubsection{Instructions}

Set absolute equal to the absolute value of -42 on line 3. (This may seem basic, but bear with us—you'll see the value of the exercise soon enough.)

\begin{lstlisting}
# Set absolute to the absolute value of -42 on line 3!

absolute = 

print absolute
\end{lstlisting}

\subsection{type()}

Finally, the type() function does something very interesting: it returns the type of the data it receives as an argument. If you ask Python to do the following:
\begin{lstlisting}
print type(42)
print type(4.2)
print type('spam')
print type({'Name':'John Cleese'})
print type((1,2))
\end{lstlisting}

Python will output:
\begin{lstlisting}
<type 'int'>
<type 'float'>
<type 'unicode'>
<type 'dict'>
<type 'tuple'>
\end{lstlisting}

(The 'unicode' type is a special type of string.)

You're already familiar with integers, floats, and strings; you'll learn about dictionaries and tuples in later lessons.

\subsubsection{Instructions}

Have Python print out the type of an int, a float, and a unicode string in the editor. You can pick any values on which to call type(), so long as they produce one of each.


\section{Review}

    Let's take some time to go over what we've covered in this unit.
\subsection{Review: Functions}

Up until now, the review section of each unit has been a single exercise. As you progress through the Python courses, you'll see longer review sections (starting with this one)—this is to ensure you have ample practice as you're exposed to more (and more complex) aspects of the language.

Okay! Let's review functions. Again, training wheels are off, but feel free to take a peek at earlier exercises if you need a refresher.
\subsubsection{Instructions}

Write a function, shut\_down, that takes one parameter (you can use anything you like; in this case, we'd use s for string). The shut\_down function should return "Shutting down..." when it gets "Yes", "yes", or "YES" as an argument, and "Shutdown aborted!" when it gets "No", "no", or "NO".

If it gets anything other than those inputs, the function should return "Sorry, I didn't understand you."

\subsection{Review: Modules}

Good work! Now let's see what you remember about importing modules (and, specifically, what's available in the math module).
Instructions

Import the math module in whatever way you prefer. Call its sqrt function on the number 13689 and print that value to the console.

\subsection{Review: Built-In Functions}

Perfect! Last but not least, let's review some of the built-in functions you've learned about in this lesson.
\subsubsection{Instructions}

This is a two-parter: first, define a function, distance\_from\_zero, with one parameter (choose any parameter name you like).

Second, have that function do the following:
\begin{enumerate}
\item    Check the type of the input it receives.
\item    If the type is int or float, the function should return the absolute value of the function input.
\item    If the type is any other type, the function should return "Not an integer or float!"
\end{enumerate}

\chapter{Taking a Vacation}
Hard day at work? Rough day at school? Take a load off with a programming vacation!

\section{A Review of Function Creation}
    A quick review of writing functions.
\subsection{Before We Begin}

Before we start the lesson, we are just going to do a quick review of functions in Python. Remember, functions are callable blocks of code that we can use over and over again. Using functions saves us time, lines of code, and confusion when writing long programs.
\subsubsection{Instructions}
For a warm up, write a function called answer that takes no input and returns the value 42.

\subsection{Finding Your Identity}

Unfortunately for us, 42 is not the answer to every question in the universe.
\subsubsection{Instructions}

Write the function identity that takes the input x and returns x. You do not need to call the function.

\subsection{Call Me Maybe?}

Remember that you can call functions to make computationally challenging tasks much easier.
\subsubsection{Instructions}

Call the function cube with an input of 27 on line 4. Print the result to the console after you call the function.
\begin{lstlisting}
def cube(x):
    return x**3

\end{lstlisting}

\subsection{Function and Control Flow}

Remember that functions often have to react differently depending on the input they receive.
\subsubsection{Instructions}

Write a function called is\_even that takes one input, x, and returns the string "yep" if the input is even and "nope" otherwise. You do not need to call the function.

\subsection{Problem Solvers}

This final review exercise will involve applying functions to a real life problem.

Let's try writing a function to solve a traditional math question.

For this exercise, you'll need to import the math module discussed in Unit 4. This can be achieved by typing import math at the top of your program.
\subsubsection{Instructions}

Write a function called area\_of\_circle that takes radius as input and returns the area of a circle. The area of a circle is equal to pi times the radius squared. (Use the math.pi in order to represent Pi.)

\section{Planes, Hotels and Automobiles}
It's vacation time! Let's see how much this trip will cost you!
\subsection{Planning Your Trip}

When planning a vacation, it is very important to know exactly how much you are going to spend. With the aid of programming, this task becomes very easy.

We will break your trip down into 3 main costs and then put them together in one big function at the end.
\subsubsection{Instructions}

First, write a function called hotel\_cost that takes the variable nights as input. The function should return how much you have to pay if the hotel costs 140 dollars for every night that you stay.

\subsection{Getting There}

To get to your location, you are going to need to take a plane ride.
\subsubsection{Instructions}

Below your existing code, write a function called plane\_ride\_cost that takes a string, city, as input. The function should return a different price depending on the location. Below are the valid destinations and their corresponding round-trip prices.
\begin{itemize}
\item "Charlotte": 183
\item "Tampa": 220
\item "Pittsburgh": 222
\item "Los Angeles": 475
\end{itemize}

\subsection{Transportation}

Now when you arrive at your destination, you are going to need a rental car in order for you to get around. Luckily for you, the rental car company you use gives discounts depending on how many days you rent the car.
\subsubsection{Instructions}

Below your existing code, write a function called rental\_car\_cost that takes days as input and returns the cost for renting a car for said number of days. The cost must abide by the following conditions:
\begin{enumerate}
\item    Every day you rent the car is \$40.
\item    If you rent the car for 3 or more days, you get \$20 off your total.
\item    If you rent the car for 7 or more days, you get \$50 off your total. (This does not stack with the 20 dollars you get for renting the car over 3 days.)
\end{enumerate}

\subsection{Pull it Together}

Great! Now that you've got your 3 main costs figured out, it's time to put them together in order to find the total cost of your trip.
\subsubsection{Instructions}

Below your existing code, write a function called trip\_cost that takes two inputs, city and days. city should be the city that you are going to visit and days should be the number of days that you are staying.

Have your function return the sum of the rental\_car\_cost, hotel\_cost, and plane\_ride\_cost functions with their respective inputs.

\subsection{Hey, You Never Know!}

You can't expect to only spend money on the plane ride, hotel, and rental car when going on a vacation. While the above items will cover the majority of your expenses, there also needs to be room for additional costs like fancy food or souvenirs.

The amount of money that you wish to spend on additional luxuries is completely up to you.
\subsubsection{Instructions}

Make it so that your trip\_cost function takes a third parameter, spending\_money. Just modify the trip\_cost function to do just as it did before, except add the spending money to the total that it returns.

\subsection{Plan Your Trip!}
\subsubsection{Instructions}

Now that you have it all together, print out the cost of a trip to "Los Angeles" for 5 days with an extra 600 dollars of spending money.


\section{Return to Base}

    Welcome back home! It's time to see how much you owe.
\subsection{Coming Back Home}

Welcome back home! It looks like you've had an amazing vacation.

Unfortunately for you, one too many drinks and a bit too much time at the casino have put you a bit over-budget.
\subsubsection{Instructions}

Go ahead and print out how far over budget you went if you spent 2734.23 on your trip.
\begin{lstlisting}
def hotel_cost(nights):
    return nights * 140

def plane_ride_cost(city):
    if city == "Charlotte":
        return 183 
    elif city == "Tampa":
        return 220 
    elif city == "Pittsburgh": 
        return 222
    else:
        return 475

def rental_car_cost(days):
    cost = days * 40
    if days >= 7:
        cost = cost - 50
    elif days >= 3:
        cost = cost - 20
    return cost 

def trip_cost(city, days, spending_money):
    return rental_car_cost(days) + hotel_cost(days) + plane_ride_cost(city)

# You were planning on taking a trip to LA
# for five days with $600 of spending money.
print trip_cost("Los Angeles", 5, 600)
\end{lstlisting}

\subsection{Gotta Give Me Some Credit}

Yikes! That is a bit more than you intended to spend. You put your hotel bill on your credit card and now you don't have the money to pay for it up front.

It looks like you're going to have to break it up into monthly payments. Programming might aid you in handling this mess.
\subsubsection{Instructions}

Call the hotel\_cost function with 5 days as the input and store the result in a variable called bill.

\begin{lstlisting}
def hotel_cost(nights):
    return nights * 140

\end{lstlisting}

\subsection{At a Bare Minimum}

First, we need to know what the minimum payment is that you can make each month.

Note that the minimum payment you can make is 2\% of your total balance. So the minimum payment you can make with a rate of 2\% and a balance of 1,000 would be 20 dollars (1000 * 0.02 equals 20.)
\subsubsection{Instructions}

Below your existing code, write a function called get\_min that takes balance and rate as inputs and returns the minimum payment that you can make with your total balance. balance and rate should both be given as numbers and not percentages, so 2\% is 0.02.

Go ahead and print out the minimum payment of your bills with a 2\% rate, as calculated by your get\_min function.

\subsection{Something of Interest}

All credit cards charge interest in proportion to your current balance. It's important that we know exactly how much we still owe after making a payment.
\subsubsection{Instructions}

Write a function called add\_monthly\_interest that takes the input balance and returns your balance with interest added to it.

Assume your interest is 15\%. This means that we need to add on 15\% to whatever balance is passed in!

Note that 1/12th of your interest multiplied by your balance is equal to the amount of interest you pay each month (or at least close, anyway). So, addmonthlyinterest(100) should return 101.25.

\subsection{Paying Up}

Now it's time for you to make a function that computes how much you still owe after every monthly payment.

You'll create the function make\_payment as described below. The function should return how much you still owe after you make an arbitrary payment at the beginning of the month.

Note: you calculate how much you still owe by subtracting your payment from your total balance and then adding interest using your add\_monthly\_interest function.
\subsubsection{Instructions}

Finish the function make\_payment that takes the inputs payment and balance.

Have the function return the string "You still owe: x", with x being the amount that you still owe. Remember to add interest to the final amount!

\begin{lstlisting}
def hotel_cost(nights):
    return nights * 140

bill = hotel_cost(5)

def add_monthly_interest(balance):
    return balance * (1 + (0.15 / 12))

def make_payment(payment, balance):
	
	
    return "You still owe: " + str(new_balance)
\end{lstlisting}

\subsection{Run It}
\subsubsection{Instructions}

To finish up, make a \$100 first payment on your hotel bill using your make\_payment function. Remember that you stayed at the hotel for 5 days.

Finally, print that result to the console!

\begin{lstlisting}
def hotel_cost(nights):
    return nights * 140

bill = hotel_cost(5)

def add_monthly_interest(balance):
    return balance * (1 + (0.15 / 12))

def make_payment(payment, balance):
	
	
    return "You still owe: " + str(new_balance)
\end{lstlisting}

\chapter{Lists and Dictionaries}
Lists and dictionaries are powerful tools you can use to store, organize, and manipulate all kinds of information.
\section{Lists}
    A Python list is just a sequence of pieces of information. You can use lists to store strings, numbers, and more!
\subsection{Introduction to Lists}

Lists are a datatype you can use to store a collection of different pieces of information as a sequence under a single variable name. (Datatypes you've already learned about include strings, numbers, and booleans.)

You can assign items to a list with an expression of the form list\_name = [item\_1, item\_2], with the items in between brackets. A list can also be empty: empty\_list = [].
\subsubsection{Instructions}

The list zoo\_animals has three items (check them out on line 1). Go ahead and add a fourth! Just enter the name of your favorite animal (as a "string") on line 1, after the final comma but before the closing ].

\begin{lstlisting}
zoo_animals = ["pangolin", "cassowary", "sloth", ]
# One animal is missing!

if len(zoo_animals) > 3:
	print "The first animal at the zoo is the " + zoo_animals[0]
	print "The second animal at the zoo is the " + zoo_animals[1]
	print "The third animal at the zoo is the " + zoo_animals[2]
	print "The fourth animal at the zoo is the " + str(zoo_animals[3])
\end{lstlisting}

\subsection{Access by Index}

You can access an individual item on the list by its index. An index is like an address that identifies the item's place in the list. The index appears directly after the list name, in between brackets, like this: list\_name[index].

List indices begin with 0, not 1! You access the first item in a list like this: list\_name[0]. The second item in a list is at index 1: list\_name[1]. Computer scientists love to start counting from zero.
\subsubsection{Instructions}

Write a statement that prints the result of adding the second and fourth items of the list. Make sure to access the list by index!
\begin{lstlisting}
numbers = [5, 6, 7, 8]

print "Adding the numbers at indices 0 and 2..."
print numbers[0] + numbers[2]
print "Adding the numbers at indices 1 and 3..."
# Your code here!

\end{lstlisting}

\subsection{New Neighbors}

A list index behaves like any other variable name! It can be used to access as well as assign values.

You saw how to access a list index like this:
\begin{lstlisting}
zoo_animals[0]
# Gets the value "pangolin"
\end{lstlisting}
You can see how assignment works on line 5:
\begin{lstlisting}
zoo_animals[2] = "hyena"
# Changes "sloth" to "hyena"
\end{lstlisting}

\subsubsection{Instructions}

Write an assignment statement that will replace the item that currently holds the value "tiger" with another animal (as a string). It can be any animal you like.
\begin{lstlisting}
zoo_animals = ["pangolin", "cassowary", "sloth", "tiger"]
# Last night our zoo's sloth brutally attacked the poor tiger and ate it whole.

# The ferocious sloth has been replaced by a friendly hyena.
zoo_animals[2] = "hyena"

# What shall fill the void left by our dear departed tiger?
# Your code here!
\end{lstlisting}

\section{List Capabilities and Functions}
    Great work with lists! Now let's learn about some of the cool things we can do with them.
\subsection{Late Arrivals \& List Length}

A list doesn't have to have a fixed length—you can add items to the end of a list any time you like! In Python, we say lists are mutable: that is, they can be changed.

You can add items to lists with the built-in list function append(), like this:
\begin{lstlisting}
list_name.append(item)
\end{lstlisting}
Check it out: we've appended a string to suitcase on line 2.

You can get the number of items in a list with the len() function (short for "length"), like so:
\begin{lstlisting}
len(list_name)
\end{lstlisting}

\subsubsection{Instructions}

Append three more items to the suitcase list. (Maybe bring a bathing suit?) Then, set list\_length equal to the length of suitcase.

\begin{lstlisting}
suitcase = [] 
suitcase.append("sunglasses")

# Your code here!




list_length = # Set this to the length of suitcase

print "There are %d items in the suitcase." % list_length
print suitcase
\end{lstlisting}

\subsection{List Slicing}

If you only want a small part of a list, that portion can be accessed using a special notation in the index brackets. list\_name[a:b] will return a portion of list\_name starting with the index a and ending before the index b.

If you tell Python my\_list = [0, 1, 2, 3], then my\_list[1:3] will return the list [1, 2], leaving the original list unchanged! Check it out:
\begin{lstlisting}
my_list = [0, 1, 2, 3]
my_slice = my_list[1:3]
print my_list
# Prints [0, 1, 2, 3]
print my_slice
# Prints [1, 2]
\end{lstlisting}

\subsubsection{Instructions}

Use list slicing to make a list called first that's composed of just the first two items from suitcase, a list called middle containing only the two middle items from suitcase, and a list called last made up only of the last two items from suitcase.

\begin{lstlisting}
suitcase = ["sunglasses", "hat", "passport", "laptop", "suit", "shoes"]

first =    # The first two items
middle =   # Third and fourth items
last =     # The last two items
\end{lstlisting}

\subsection{Slicing Lists and Strings}

You can slice a string exactly like a list! In fact, you can think of strings as lists of characters: each character is a sequential item in the list, starting from index 0.

If your list slice includes the very first or last item in a list (or a string), the index for that item doesn't have to be included. Here's an example:
\begin{lstlisting}
my_list[:2]
# Grabs the first two items
my_list[3:]
# Grabs the fourth through last items
\end{lstlisting}
\subsubsection{Instructions}

Assign each variable a slice of animals that spells out that variable's name.

\begin{lstlisting}
animals = "catdogfrog"
cat =    # The first three characters of animals
dog =    # The fourth through sixth characters
frog =   # From the seventh character to the end
\end{lstlisting}

\subsection{Maintaining Order}

You can search through a list with the index() function. my\_list.index("dog") will return the first index that contains the string "dog". An error will occur if there is no such item.

Items can be added to the middle of a list (instead of to the end) with the insert() function. my\_list.insert(4,"cat") adds the item "cat" at index 4 of my\_list, and moves the item previously at index 4 and all items following it to the next index (that is, they all get bumped forward by one).
\subsubsection{Instructions}

Use the index() function to assign duck\_index the index of the string equal to "duck". Then insert the string "cobra" at that index.

\begin{lstlisting}
animals = ["aardvark", "badger", "duck", "emu", "fennec fox"]
duck_index =    # Use index() to find "duck"

# Your code here!



print animals # Observe what prints after the insert operation
\end{lstlisting}

\subsection{For One and All}

If you want to do something with every item in the list, you can use a for loop. If you've learned about for loops in JavaScript, pay close attention! They're different in Python.

Here's the syntax:
\begin{lstlisting}
for variable in list_name:
    # Do stuff!
\end{lstlisting}
A variable name follows the for keyword; it will be assigned the value of each list item in turn. in list\_name designates list\_name as the list the loop will work on. The line ends with a colon (:) and the indented code that follows it will be executed once per item in the list.
\subsubsection{Instructions}

Write a statement in the indented part of the for loop that prints a number equal to 2 * number for every list item.
\begin{lstlisting}
my_list = [1,9,3,8,5,7]

for number in my_list:
    # Your code here
    
\end{lstlisting}

\subsection{More with 'for'}

If your list is a jumbled mess, you may need to sort() it. my\_list.sort() will sort the items in my\_list in increasing numerical/alphabetical order.

It's worth noting that sort() does not return a new list; instead, your existing my\_list is sorted in place (the sorted version replaces the unsorted version).
\subsubsection{Instructions}

Write a for loop that populates square\_list with items that are the square (x ** 2) of each item in start\_list. Then sort square\_list!
\begin{lstlisting}
start_list = [5, 3, 1, 2, 4]
square_list = []

# Your code here!


print square_list
\end{lstlisting}

\section{Dictionaries}

    What if you want to store information using something other than the preset index values of 0, 1, 2, and so on? Dictionaries can do that for you!

\subsection{This Next Part is Key}

A dictionary is similar to a list, but you access values by looking up a key instead of an index. A key can be any string or number. Dictionaries are enclosed in curly braces, like so:

d = {'key1' : 1, 'key2' : 2, 'key3' : 3}

This is a dictionary called d with three key-value pairs. The key 'key1' points to the value 1, 'key2' to 2, and so on.

Dictionaries are great for things like phone books (pairing a name with a phone number), login pages (pairing an e-mail address with a username), and more!
\subsubsection{Instructions}

Print the values stored under the 'Sloth' and 'Burmese Python' keys. Accessing dictionary values by key is just like accessing list values by index:
\begin{lstlisting}
residents['Puffin']
# Gets the value 104

# Assigning a dictionary with three key-value pairs to residents:
residents = {'Puffin' : 104, 'Sloth' : 105, 'Burmese Python' : 106}

print residents['Puffin'] # Prints Puffin's room number

# Your code here!

\end{lstlisting}


\subsection{New Entries}

A new key-value pair in a dictionary is created by assigning a new key, like so:
\begin{lstlisting}
dict_name[new_key] = new_value
\end{lstlisting}
An empty pair of curly braces {} is an empty dictionary, just like an empty pair of [] is an empty list.

The length len() of a dictionary is the number of key-value pairs it has. Each pair counts only once, even if the value is a list. (That's right: you can put lists inside dictionaries!)
\subsubsection{Instructions}

Add at least three key-value pairs to the menu variable, with the dish name (as a "string") for the key and the price (a float or integer) as the value. Here's an example:
\begin{lstlisting}
menu['Spam'] = 2.50
\end{lstlisting}

\begin{lstlisting}
menu = {} # Empty dictionary
menu['Chicken Alfredo'] = 14.50 # Adding new key-value pair
print menu['Chicken Alfredo']

# Your code here: Add some dish-price pairs to menu!




print "There are " + str(len(menu)) + " items on the menu."
print menu
\end{lstlisting}

\subsection{Changing Your Mind}

Like lists, dictionaries are mutable (they can be changed). Items can be removed from a dictionary with the del command:
\begin{lstlisting}
del dict_name[key_name]
\end{lstlisting}
will remove the key key\_name and its associated value from the dictionary.

A new value can be associated with a key by assigning a value to the key, like so:
\begin{lstlisting}
dict_name[key] = new_value
\end{lstlisting}
\subsubsection{Instructions}

Delete the 'Sloth' and 'Bengal Tiger' items from zoo\_animals using del.

Set the value associated with 'Rockhopper Penguin' to anything other than 'Arctic Exhibit'.
\begin{lstlisting}
# key - animal_name : value - location 
zoo_animals = { 'Unicorn' : 'Cotton Candy House',
'Sloth' : 'Rainforest Exhibit',
'Bengal Tiger' : 'Jungle House',
'Atlantic Puffin' : 'Arctic Exhibit',
'Rockhopper Penguin' : 'Arctic Exhibit'}
# A dictionary (or list) declaration may break across multiple lines

# Removing the 'Unicorn' entry. (Unicorns are incredibly expensive.)
del zoo_animals['Unicorn']

# Your code here!




print zoo_animals
\end{lstlisting}

\subsection{It's Dangerous to Go Alone! Take This}

Finally, my\_list.remove(value) will remove the the first item from my\_list that has a value equal to value. The difference between del and .remove() is:
\begin{itemize}
\item    del deletes a key and its value based on the key you tell it to delete.
\item    .remove() removes a key and its value based on the value you tell it to delete.
\end{itemize}

\subsubsection{Instructions}

Final challenge! Add code that modifies the dictionary inventory in the following ways:
\begin{enumerate}
\item    Add a key to inventory called 'pocket'
\item    Set the value of 'pocket' to be a list consisting of the strings 'seashell', 'strange berry', and 'lint'
\item    .sort() the items in the list stored under the 'backpack' key
\item    Remove 'dagger' from the list of items stored under the 'backpack' key
\item    Add 50 to the number stored under the 'gold' key
\end{enumerate}

\begin{lstlisting}
inventory = {'gold' : 500,
'pouch' : ['flint', 'twine', 'gemstone'], # Assigned a new list to 'pouch' key
'backpack' : ['xylophone','dagger', 'bedroll','bread loaf']}

# Adding a key 'burlap bag' and assigning a list to it
inventory['burlap bag'] = ['apple', 'small ruby', 'three-toed sloth']

# Sorting the list found under the key 'pouch'
inventory['pouch'].sort() 
# Here the dictionary access expression takes the place of a list name 

# Your code here!

\end{lstlisting}


\chapter{Project: A Day at the Supermarket}
Let's manage our own supermarket and buy some goods along the way!

\section{Looping with Lists and Dictionaries}
Lean how to use the for loop with lists and dictionaries.
\subsection{BeFOR We Begin}

Before we begin our exercise, we should go over the Python for loop one more time. For now, we are only going to go over the for loop in terms of how it relates to lists and dictionaries. We'll explain more cool for loop uses in later courses.

for loops allow us to iterate through all of the elements in a list from the left-most (or zeroth element) to the right-most element. A sample loop would be structured as follows:

\begin{lstlisting}
a = [1,2,3,4,....]
for x in a: 
    # Do something for every x
\end{lstlisting}

This loop will run all of the code in the indented block under the for x in a: statement. The item in the list that is currently being evaluated will be x. So running the following:
\begin{lstlisting}
for item in [1, 3, 21]: 
    print item
\end{lstlisting}
would print 1, then 3, and then 21. The variable between for and in can be set to any variable name (currently item), but you should be careful to avoid using the word “list” as a variable, since that's a reserved word (that is, it means something special) in the Python language.
\subsubsection{Instructions}
Use a for loop to print out all of the elements in the list names.

\begin{lstlisting}
names = ["Adam","Alex","Mariah","Martine","Columbus"]
\end{lstlisting}

\subsection{This is KEY!}

You can also use a for loop on a dictionary to loop through its keys with the following:
\begin{lstlisting}
d = {"foo" : "bar"}

for key in d: 
    print d[key]  # prints "bar" 
\end{lstlisting}
Note that dictionaries are unordered, meaning that any time you loop through a dictionary, you will go through every key, but you are not guaranteed to get them in any particular order.
\subsubsection{Instructions}

Use a for loop to go through the webster dictionary and print out all of the definitions.

\begin{lstlisting}
webster = {
	"Aardvark" : "A star of a popular children's cartoon show.",
    "Baa" : "The sound a goat makes.",
    "Carpet": "Goes on the floor.",
    "Dab": "A small amount."
}

# Add your code below!

\end{lstlisting}

\subsection{Control Flow and Looping}

The blocks of code in a for loop can be as big or as small as they need to be. While looping, you may want to perform different actions depending on the particular item in the list. This can be achieved by combining your loops with control flow (if/else statements) that might resemble the following:
\begin{lstlisting}
for item in numbers: 
    if condition: 
        # Do something
\end{lstlisting}
Make sure to keep track of your indentation or you may get confused!
\subsubsection{Instructions}

Loop through list a and only print out the even numbers.
\begin{lstlisting}
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
\end{lstlisting}

\subsection{Lists + Functions}

Functions can also take lists as inputs and perform various operations on those lists.
\subsubsection{Instructions}

Write a function called fizz\_count that takes a list x as input and returns the count of the string “fizz” in that list.

For example, fizz\_count(["fizz","buzz","fizz"]) should return 2. Check out the Hint if you need help!

\subsection{String Looping}

As we've mentioned, strings are like lists with characters as elements. You can loop through strings the same way you loop through lists! While we won't ask you to do that in this section, we've put an example in the editor of how looping through a string might work.
\subsubsection{Instructions}

Run the code to see string iteration in action!

\begin{lstlisting}
for letter in "Codecademy":
    print letter
    
# Empty lines to make the output pretty
print
print

word = "Programming is fun!"

for letter in word:
    # Only print out the letter i
    if letter == "i":
        print letter
\end{lstlisting}

\section{Owning a Store}

    Learn how to run your very own supermarket!

\subsection{Your Own Store!}

Okay—on to the core of our project.

Congratulations! You are now the proud owner of your very own Codecademy brand supermarket!

The first thing that you need to do is figure out what your inventory is (and how much each item costs).
Instructions

Set your prices to the following values. Put these values in a dictionary called prices and write your dictionary in the {} format.
\begin{lstlisting}
"banana": 4
"apple": 2
"orange": 1.5
"pear": 3
\end{lstlisting}
Yeah, this place is really expensive. (Your supermarket subsidizes the zoo from the last course.)

\subsection{Investing in Stock}

Good work! As a store manager, you’re also in charge of keeping track of your stock/inventory.
Instructions

Create a stock dictionary with the values below.
\begin{lstlisting}
"banana": 6
"apple": 0
"orange": 32
"pear": 15
\end{lstlisting}

\subsection{Keeping Track of the Produce}

Now that you have all of your product info, you need to make a formal document with all of your inventory information. This will not only give you a big-picture sense of your stock situation, but will help you figure out which items you need to order (and which ones you may have over-ordered last time).
\subsubsection{Instructions}

Print out all of the items in your store along with their prices. Print the answer in the following format:
\begin{lstlisting}
item
price: x
stock: x
\end{lstlisting}
So when you print out the data for apples, print out:
\begin{lstlisting}
apple
price: 2
stock: 0
\end{lstlisting}
Each of these values should be in a different print statement. Remember to convert numbers to strings before trying to combine them, and check the Hint if you need help.

\subsection{Something of Value}

For paperwork and accounting purposes, let's record the total value of your inventory. It's nice to know what we're worth!
\subsubsection{Instructions}

Loop through your dictionaries in order to figure out how much money you would make if you sold all of the food in stock. Print that value into the console!

\begin{lstlisting}
prices = {
    "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}
    
stock = {
    "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
\end{lstlisting}

\section{Shopping Trip!}

    Let's buy some goods at the supermarket.

\subsection{Shopping at the Market}

Great work! Now we're going to take a step back from the management side and take a look through the eyes of the shopper.

In order for customers to order online, we are going to have to make a consumer interface. Don't worry: it's easier than it sounds!
\subsubsection{Instructions}

First, make a list (not a dictionary!) with the name groceries. Insert a "banana", "orange", and "apple".

\subsection{Making a Purchase}

Good! Now you're going to need to know how much you’re paying for all of the items on your grocery list.

Remember how to compute a rolling sum? If not, here's a reminder: total += price is the same as total = total + price. Evaluating the right hand side grabs the values of those variables, adds those values and then stores it back into the variable total.
\subsubsection{Instructions}

Write a function compute\_bill that takes a parameter food as input and computes your bill by looping through your food list and summing the costs of each item in the list.

For now, go ahead and ignore whether or not the item you're billing for is in stock.

\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!
\end{lstlisting}

\subsection{Stocking Out}

Now you need your compute\_bill function to take the stock/inventory of a particular item into account when computing the cost.

Ultimately, if an item isn't in stock, then it shouldn't be included in the total. You can't buy or sell what you don't have!
\subsubsection{Instructions}

Do the following for your compute\_bill function:
\begin{enumerate}
\item    Let your function take a list of groceries as input.
\item    Do not add the price of an item into your list if it is out of stock.
\item    After you buy an item, subtract one from its stock.
\item    If an item is in your list multiple times you must repeat this process multiple times.
\end{enumerate}

\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!
\end{lstlisting}

\subsection{Let's Check Out!}

Perfect! You've done a great job with lists and dictionaries in this project. You've practiced:
\begin{itemize}
\item    Using for loops with lists and dictionaries
\item    Writing functions with loops, lists, and dictionaries
\item    Updating data in response to changes in the environment (for instance, decreasing the number of bananas in stock by 1 when you sell one).
\end{itemize}
Thanks for shopping at the Codecademy supermarket!
\subsubsection{Instructions}

\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!
\end{lstlisting}

\chapter{Lists and Dictionaries}
Lists and dictionaries are powerful tools you can use to store, organize, and manipulate all kinds of information.

\section{Lists}
A Python list is just a sequence of pieces of information. You can use lists to store strings, numbers, and more!
\subsection{Introduction to Lists}

Lists are a datatype you can use to store a collection of different pieces of information as a sequence under a single variable name. (Datatypes you've already learned about include strings, numbers, and booleans.)

You can assign items to a list with an expression of the form list\_name = [item\_1, item\_2], with the items in between brackets. A list can also be empty: empty\_list = [].

\subsubsection{Instructions}

The list zoo\_animals has three items (check them out on line 1). Go ahead and add a fourth! Just enter the name of your favorite animal (as a "string") on line 1, after the final comma but before the closing ].

\begin{lstlisting}
zoo_animals = ["pangolin", "cassowary", "sloth", ];
# One animal is missing!

if len(zoo_animals) > 3:
	print "The first animal at the zoo is the " + zoo_animals[0]
	print "The second animal at the zoo is the " + zoo_animals[1]
	print "The third animal at the zoo is the " + zoo_animals[2]
	print "The fourth animal at the zoo is the " + zoo_animals[3]
\end{lstlisting}

\subsection{Access by Index}

You can access an individual item on the list by its index. An index is like an address that identifies the item's place in the list. The index appears directly after the list name, in between brackets, like this: list\_name[index].

List indices begin with 0, not 1! You access the first item in a list like this: list\_name[0]. The second item in a list is at index 1: list\_name[1]. Computer scientists love to start counting from zero.
\subsubsection{Instructions}

Write a statement that prints the result of adding the second and fourth items of the list. Make sure to access the list by index!
\begin{lstlisting}
numbers = [5, 6, 7, 8]

print "Adding the numbers at indices 0 and 2..."
print numbers[0] + numbers[2]
print "Adding the numbers at indices 1 and 3..."
# Your code here!
\end{lstlisting}

\subsection{New Neighbors}

A list index behaves like any other variable name! It can be used to access as well as assign values.

You saw how to access a list index like this:
\begin{lstlisting}
zoo_animals[0]
# Gets the value "pangolin"
\end{lstlisting}
You can see how assignment works on line 5:
\begin{lstlisting}
zoo_animals[2] = "hyena"
# Changes "sloth" to "hyena"
\end{lstlisting}
\subsubsection{Instructions}

Write an assignment statement that will replace the item that currently holds the value "tiger" with another animal (as a string). It can be any animal you like.
\begin{lstlisting}
zoo_animals = ["pangolin", "cassowary", "sloth", "tiger"]
# Last night our zoo's sloth brutally attacked 
#the poor tiger and ate it whole.

# The ferocious sloth has been replaced by a friendly hyena.
zoo_animals[2] = "hyena"

# What shall fill the void left by our dear departed tiger?
# Your code here!

\end{lstlisting}

\section{List Capabilities and Functions}
Great work with lists! Now let's learn about some of the cool things we can do with them.

\subsection{Late Arrivals and List Length}
A list doesn't have to have a fixed length—you can add items to the end of a list any time you like! In Python, we say lists are mutable: that is, they can be changed.

You can add items to lists with the built-in list function append(), like this:
\begin{lstlisting}
list_name.append(item)
\end{lstlisting}
Check it out: we've appended a string to suitcase on line 2.

You can get the number of items in a list with the len() function (short for "length"), like so:
\begin{lstlisting}
len(list_name)
\end{lstlisting}
\subsubsection{Instructions}

Append three more items to the suitcase list. (Maybe bring a bathing suit?) Then, set list\_length equal to the length of suitcase.

\begin{lstlisting}
suitcase = [] 
suitcase.append("sunglasses")

# Your code here!




list_length = # Set this to the length of suitcase

print "There are %d items in the suitcase." % list_length
print suitcase
\end{lstlisting}

\subsection{List Slicing}

If you only want a small part of a list, that portion can be accessed using a special notation in the index brackets. list\_name[a:b] will return a portion of list\_name starting with the index a and ending before the index b.

If you tell Python my\_list = [0, 1, 2, 3], then my\_list[1:3] will return the list [1, 2], leaving the original list unchanged! Check it out:
\begin{lstlisting}
my_list = [0, 1, 2, 3]
my_slice = my_list[1:3]
print my_list
# Prints [0, 1, 2, 3]
print my_slice
# Prints [1, 2]
\end{lstlisting}
\subsubsection{Instructions}

Use list slicing to make a list called first that's composed of just the first two items from suitcase, a list called middle containing only the two middle items from suitcase, and a list called last made up only of the last two items from suitcase.

\begin{lstlisting}
suitcase = ["sunglasses", "hat", "passport", "laptop", "suit", "shoes"]

first =    # The first two items
middle =   # Third and fourth items
last =     # The last two items
\end{lstlisting}

\subsection{Slicing Lists and Strings}

You can slice a string exactly like a list! In fact, you can think of strings as lists of characters: each character is a sequential item in the list, starting from index 0.

If your list slice includes the very first or last item in a list (or a string), the index for that item doesn't have to be included. Here's an example:
\begin{lstlisting}
my_list[:2]
# Grabs the first two items
my_list[3:]
# Grabs the fourth through last items
\end{lstlisting}
\subsubsection{Instructions}

Assign each variable a slice of animals that spells out that variable's name.
\begin{lstlisting}
animals = "catdogfrog"
cat =    # The first three characters of animals
dog =    # The fourth through sixth characters
frog =   # From the seventh character to the end
\end{lstlisting}

\subsection{Maintaining Order}

You can search through a list with the index() function. my\_list.index("dog") will return the first index that contains the string "dog". An error will occur if there is no such item.

Items can be added to the middle of a list (instead of to the end) with the insert() function. my\_list.insert(4,"cat") adds the item "cat" at index 4 of my\_list, and moves the item previously at index 4 and all items following it to the next index (that is, they all get bumped forward by one).
\subsubsection{Instructions}

Use the index() function to assign duck\_index the index of the string equal to "duck". Then insert the string "cobra" at that index.

\begin{lstlisting}
animals = ["aardvark", "badger", "duck", "emu", "fennec fox"]
duck_index =    # Use index() to find "duck"

# Your code here!



print animals # Observe what prints after the insert operation
\end{lstlisting}


\subsection{For One and All}

If you want to do something with every item in the list, you can use a for loop. If you've learned about for loops in JavaScript, pay close attention! They're different in Python.

Here's the syntax:
\begin{lstlisting}
for variable in list_name:
    # Do stuff!
\end{lstlisting}
A variable name follows the for keyword; it will be assigned the value of each list item in turn. in list\_name designates list\_name as the list the loop will work on. The line ends with a colon (:) and the indented code that follows it will be executed once per item in the list.
\subsubsection{Instructions}

Write a statement in the indented part of the for loop that prints a number equal to 2 * number for every list item.

\begin{lstlisting}
my_list = [1,9,3,8,5,7]

for number in my_list:
    # Your code here
    
\end{lstlisting}

\subsection{More with 'for'}

If your list is a jumbled mess, you may need to sort() it. my\_list.sort() will sort the items in my\_list in increasing numerical/alphabetical order.

It's worth noting that sort() does not return a new list; instead, your existing my\_list is sorted in place (the sorted version replaces the unsorted version).
\subsubsection{Instructions}

Write a for loop that populates square\_list with items that are the square (x ** 2) of each item in start\_list. Then sort square\_list!

\begin{lstlisting}
start_list = [5, 3, 1, 2, 4]
square_list = []

# Your code here!


print square_list
\end{lstlisting}

\section{Dictionaries}
What if you want to store information using something other than the preset index values of 0, 1, 2, and so on? Dictionaries can do that for you!

\subsection{This Next Part is Key}

A dictionary is similar to a list, but you access values by looking up a key instead of an index. A key can be any string or number. Dictionaries are enclosed in curly braces, like so:
\begin{lstlisting}
d = {'key1' : 1, 'key2' : 2, 'key3' : 3}
\end{lstlisting}
This is a dictionary called d with three key-value pairs. The key 'key1' points to the value 1, 'key2' to 2, and so on.

Dictionaries are great for things like phone books (pairing a name with a phone number), login pages (pairing an e-mail address with a username), and more!
\subsubsection{Instructions}

Print the values stored under the 'Sloth' and 'Burmese Python' keys. Accessing dictionary values by key is just like accessing list values by index:
\begin{lstlisting}
residents['Puffin']
# Gets the value 104
\end{lstlisting}

\begin{lstlisting}
# Assigning a dictionary with three key-value pairs to residents:
residents = {'Puffin' : 104, 'Sloth' : 105, 'Burmese Python' : 106}

print residents['Puffin'] # Prints Puffin's room number

# Your code here!

\end{lstlisting}

\subsection{New Entries}

A new key-value pair in a dictionary is created by assigning a new key, like so:
\begin{lstlisting}
dict_name[new_key] = new_value
\end{lstlisting}
An empty pair of curly braces {} is an empty dictionary, just like an empty pair of [] is an empty list.

The length len() of a dictionary is the number of key-value pairs it has. Each pair counts only once, even if the value is a list. (That's right: you can put lists inside dictionaries!)
\subsubsection{Instructions}

Add at least three key-value pairs to the menu variable, with the dish name (as a "string") for the key and the price (a float or integer) as the value. Here's an example:
\begin{lstlisting}
menu['Spam'] = 2.50
\end{lstlisting}

\begin{lstlisting}
menu = {} # Empty dictionary
menu['Chicken Alfredo'] = 14.50 # Adding new key-value pair
print menu['Chicken Alfredo']

# Your code here: Add some dish-price pairs to menu!




print "There are " + str(len(menu)) + " items on the menu."
print menu
\end{lstlisting}

\subsection{Changing Your Mind}

Like lists, dictionaries are mutable (they can be changed). Items can be removed from a dictionary with the del command:
\begin{lstlisting}
del dict_name[key_name]
\end{lstlisting}
will remove the key key\_name and its associated value from the dictionary.

A new value can be associated with a key by assigning a value to the key, like so:
\begin{lstlisting}
dict_name[key] = new_value
\end{lstlisting}
\subsubsection{Instructions}

Delete the 'Sloth' and 'Bengal Tiger' items from zoo\_animals using del.

Set the value associated with 'Rockhopper Penguin' to anything other than 'Arctic Exhibit'.
\begin{lstlisting}
# key - animal_name : value - location 
zoo_animals = { 'Unicorn' : 'Cotton Candy House',
'Sloth' : 'Rainforest Exhibit',
'Bengal Tiger' : 'Jungle House',
'Atlantic Puffin' : 'Arctic Exhibit',
'Rockhopper Penguin' : 'Arctic Exhibit'}
# A dictionary (or list) declaration may break across multiple lines

# Removing the 'Unicorn' entry. (Unicorns are incredibly expensive.)
del zoo_animals['Unicorn']

# Your code here!




print zoo_animals
\end{lstlisting}

\subsection{It's Dangerous to Go Alone! Take This}

Finally, my\_list.remove(value) will remove the the first item from my\_list that has a value equal to value. The difference between del and .remove() is:
\begin{itemize}
\item    del deletes a key and its value based on the key you tell it to delete.
\item    .remove() removes a key and its value based on the value you tell it to delete.
\end{itemize}
\subsubsection{Instructions}

Final challenge! Add code that modifies the dictionary inventory in the following ways:
\begin{itemize}
\item    Add a key to inventory called 'pocket'
\item    Set the value of 'pocket' to be a list consisting of the strings 'seashell', 'strange berry', and 'lint'
\item    .sort() the items in the list stored under the 'backpack' key
\item    Remove 'dagger' from the list of items stored under the 'backpack' key
\item    Add 50 to the number stored under the 'gold' key
\end{itemize}

\begin{lstlisting}
inventory = {'gold' : 500,
'pouch' : ['flint', 'twine', 'gemstone'], # Assigned a new list to 'pouch' key
'backpack' : ['xylophone','dagger', 'bedroll','bread loaf']}

# Adding a key 'burlap bag' and assigning a list to it
inventory['burlap bag'] = ['apple', 'small ruby', 'three-toed sloth']

# Sorting the list found under the key 'pouch'
inventory['pouch'].sort() 
# Here the dictionary access expression takes the place of a list name 

# Your code here!

\end{lstlisting}

\chapter{Project: A Day at Supermarket}
Let's manage our own supermarket and buy some goods along the way!

\section{Looping with Lists and Dictionaries}
Lean how to use the for loop with lists and dictionaries.
\subsection{BeFOR We Begin}

Before we begin our exercise, we should go over the Python for loop one more time. For now, we are only going to go over the for loop in terms of how it relates to lists and dictionaries. We'll explain more cool for loop uses in later courses.

for loops allow us to iterate through all of the elements in a list from the left-most (or zeroth element) to the right-most element. A sample loop would be structured as follows:

\begin{lstlisting}
a = [List of some sort]
for x in a: 
    # Do something for every x
\end{lstlisting}
This loop will run all of the code in the indented block under the for x in a: statement. The item in the list that is currently being evaluated will be x. So running the following:
\begin{lstlisting}
for item in [1, 3, 21]: 
    print item
\end{lstlisting}
would print 1, then 3, and then 21. The variable between for and in can be set to any variable name (currently item), but you should be careful to avoid using the word “list” as a variable, since that's a reserved word (that is, it means something special) in the Python language.
\subsubsection{Instructions}
Use a for loop to print out all of the elements in the list names.
\begin{lstlisting}
names = ["Adam","Alex","Mariah","Martine","Columbus"]
\end{lstlisting}

\subsection{This is KEY!}

You can also use a for loop on a dictionary to loop through its keys with the following:
\begin{lstlisting}
d = {"foo" : "bar"}

for key in d: 
    print d[key]  # prints "bar" 
\end{lstlisting}
Note that dictionaries are unordered, meaning that any time you loop through a dictionary, you will go through every key, but you are not guaranteed to get them in any particular order.
\subsubsection{Instructions}
Use a for loop to go through the webster dictionary and print out all of the definitions.
\begin{lstlisting}
webster = {
	"Aardvark" : "A star of a popular children's cartoon show.",
    "Baa" : "The sound a goat makes.",
    "Carpet": "Goes on the floor.",
    "Dab": "A small amount."
}

# Add your code below!
\end{lstlisting}

\subsection{Control Flow and Looping}

The blocks of code in a for loop can be as big or as small as they need to be. While looping, you may want to perform different actions depending on the particular item in the list. This can be achieved by combining your loops with control flow (if/else statements) that might resemble the following:
\begin{lstlisting}
for item in numbers: 
    if condition: 
        # Do something
\end{lstlisting}
Make sure to keep track of your indentation or you may get confused!
\subsubsection{Instructions}
Loop through list a and only print out the even numbers.
\begin{lstlisting}
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
\end{lstlisting}

\subsection{Lists + Functions}

Functions can also take lists as inputs and perform various operations on those lists.
\subsubsection{Instructions}

Write a function called fizz\_count that takes a list x as input and returns the count of the string “fizz” in that list.

For example, fizz\_count(["fizz","buzz","fizz"]) should return 2. Check out the Hint if you need help!

\subsection{String Looping}

As we've mentioned, strings are like lists with characters as elements. You can loop through strings the same way you loop through lists! While we won't ask you to do that in this section, we've put an example in the editor of how looping through a string might work.
\subsubsection{Instructions}
Run the code to see string iteration in action!
\begin{lstlisting}
for letter in "Codecademy":
    print letter
    
# Empty lines to make the output pretty
print
print

word = "Programming is fun!"

for letter in word:
    # Only print out the letter i
    if letter == "i":
        print letter
\end{lstlisting}

\section{Owning a Store}
Learn how to run your very own supermarket!
\subsection{Your Own Store!}

Okay—on to the core of our project.

Congratulations! You are now the proud owner of your very own Codecademy brand supermarket!

The first thing that you need to do is figure out what your inventory is (and how much each item costs).
\subsubsection{Instructions}
Set your prices to the following values. Put these values in a dictionary called prices and write your dictionary in the {} format.
\begin{lstlisting}
"banana": 4
"apple": 2
"orange": 1.5
"pear": 3
\end{lstlisting}
Yeah, this place is really expensive. (Your supermarket subsidizes the zoo from the last course.)

\subsection{Investing in Stock}

Good work! As a store manager, you’re also in charge of keeping track of your stock/inventory.
\subsubsection{Instructions}

Create a stock dictionary with the values below.
\begin{itemize}
\item "banana": 6
\item "apple": 0
\item "orange": 32
\item "pear": 15
\end{itemize}

\subsection{Keeping Track of the Produce}

Now that you have all of your product info, you need to make a formal document with all of your inventory information. This will not only give you a big-picture sense of your stock situation, but will help you figure out which items you need to order (and which ones you may have over-ordered last time).
\subsubsection{Instructions}
Print out all of the items in your store along with their prices. Print the answer in the following format:
\\
item\\
“price: x“\\
“stock: x”\\

So when you print out the data for apples, print out:
\\
apple\\
price: 2\\
stock: 0\\

Each of these values should be in a different print statement. Remember to convert numbers to strings before trying to combine them, and check the Hint if you need help.

\subsection{Something of Value}

For paperwork and accounting purposes, let's record the total value of your inventory. It's nice to know what we're worth!
\subsubsection{Instructions}

Loop through your dictionaries in order to figure out how much money you would make if you sold all of the food in stock. Print that value into the console!
\begin{lstlisting}
prices = {
    "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}
    
stock = {
    "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
\end{lstlisting}

    
\section{Shopping Trip!}
Let's buy some goods at the supermarket.
\subsection{Shopping at the Market}

Great work! Now we're going to take a step back from the management side and take a look through the eyes of the shopper.

In order for customers to order online, we are going to have to make a consumer interface. Don't worry: it's easier than it sounds!
\subsubsection{Instructions}

First, make a list (not a dictionary!) with the name groceries. Insert a "banana", "orange", and "apple".
\subsection{Making a Purchase}

Good! Now you're going to need to know how much you’re paying for all of the items on your grocery list.

Remember how to compute a rolling sum? If not, here's a reminder: total += price is the same as total = total + price. Evaluating the right hand side grabs the values of those variables, adds those values and then stores it back into the variable total.
\subsubsection{Instructions}

Write a function compute\_bill that takes a parameter food as input and computes your bill by looping through your food list and summing the costs of each item in the list.

For now, go ahead and ignore whether or not the item you're billing for is in stock.

\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!

\end{lstlisting}

\subsection{Stocking Out}

Now you need your compute\_bill function to take the stock/inventory of a particular item into account when computing the cost.

Ultimately, if an item isn't in stock, then it shouldn't be included in the total. You can't buy or sell what you don't have!
\subsubsection{Instructions}

Do the following for your compute\_bill function:
\begin{itemize}
\item    Let your function take a list of groceries as input.
\item    Do not add the price of an item into your list if it is out of stock.
\item    After you buy an item, subtract one from its stock.
\item    If an item is in your list multiple times you must repeat this process multiple times.
\end{itemize}

\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!

\end{lstlisting}

\subsection{Let's Check Out!}

Perfect! You've done a great job with lists and dictionaries in this project. You've practiced:
\begin{itemize}
\item    Using for loops with lists and dictionaries
\item    Writing functions with loops, lists, and dictionaries
\item    Updating data in response to changes in the environment (for instance, decreasing the number of bananas in stock by 1 when you sell one).
\end{itemize}
Thanks for shopping at the Codecademy supermarket!
\subsubsection{Instructions}
\begin{lstlisting}
groceries = ["banana", "orange", "apple"]

stock = { "banana": 6,
    "apple": 0,
    "orange": 32,
    "pear": 15
}
    
prices = { "banana": 4,
    "apple": 2,
    "orange": 1.5,
    "pear": 3
}

# Write your code below!
\end{lstlisting}

\chapter{Student Becomes the Teacher}
Use what you've learned so far to manage your own class.
\section{Good Morning Class!}
Use what you've learned about lists and dictionaries to keep track of class data.
\subsection{Lesson Number One}

By this point, you’ve probably taken a handful of classes here at Codecademy. Now we’re going to switch it up a bit and allow you to be the teacher of your own class. The first thing that you need to do as a teacher is make a gradebook for all of your students. In most schools, grades are determined by weighted averages. Grades are typically divided between homework, quiz, and test averages.
\subsubsection{Instructions}

Fill out three dictionaries named lloyd, alice, and tyler. Give each dictionary the keys "name", "homework", "quizzes", and "tests". Have the "name" key reference the name of the student (that is, lloyd's name should be "Lloyd") and the other keys reference an empty list.

\subsection{What's the Score?}

Great work!
\subsubsection{Instructions}

Now fill your lloyd dictionary with the appropriate scores. To save you some time, we've filled out the rest for you.
\begin{itemize}
\item Homework: 90, 97, 75, 92
\item Quizzes: 88, 40, 94
\item Test Scores: 75, 90
\end{itemize}

\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [],
    "quizzes": [],
    "tests": []
}
alice = {
    "name": "Alice",
    "homework": [100,92,98,100],
    "quizzes": [82,83,91],
    "tests": [89,97]
}
tyler = {
    "name": "Tyler",
    "homework": [0,87,75,22],
    "quizzes": [0,75,78],
    "tests": [100,100]
}
\end{lstlisting}

\subsection{Put It Together}
\subsubsection{Instructions}
Now put the Lloyd, Alice and Tyler dictionaries in a list called students.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [],
    "quizzes": [],
    "tests": []
}
alice = {
    "name": "Alice",
    "homework": [100,92,98,100],
    "quizzes": [82,83,91],
    "tests": [89,97]
}
tyler = {
    "name": "Tyler",
    "homework": [0,87,75,22],
    "quizzes": [0,75,78],
    "tests": [100,100]
}
\end{lstlisting}

\subsection{For the Record}

Perfect! Now you need a hard copy document with all of your students' grades.
\subsubsection{Instructions}

Print out all the data in your students list, using the below as an example.
\\
Lloyd\\
90, 97, 75, 92\\
88, 40, 94\\
75, 90\\

Use a for loop in order to avoid repeating the same code for each student. It's okay to use four print statements, though.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [],
    "quizzes": [],
    "tests": []
}
alice = {
    "name": "Alice",
    "homework": [100,92,98,100],
    "quizzes": [82,83,91],
    "tests": [89,97]
}
tyler = {
    "name": "Tyler",
    "homework": [0,87,75,22],
    "quizzes": [0,75,78],
    "tests": [100,100]
}
\end{lstlisting}


\section{Just Average}
Combine basic mathematics with previous constructs.
\subsection{It's Okay to be Average}

When teaching a class, it's important to take the students' averages in order to assign grades.
\subsubsection{Instructions}

First, write a function average that returns the average value of a list filled only with numbers. If you need help with this, take a look at the Hint.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [90, 97, 75, 92],
    "quizzes": [88, 40, 94],
    "tests": [75, 90]
}
alice = {
    "name": "Alice",
    "homework": [100, 92, 98, 100],
    "quizzes": [82, 83, 91],
    "tests": [89, 97]
}
tyler = {
    "name": "Tyler",
    "homework": [0, 87, 75, 22],
    "quizzes": [0, 75, 78],
    "tests": [100, 100]
}

# Add your function below!

\end{lstlisting}
\subsection{Just Weight and See}

Great! Now you need to compute a student’s average using weighted averages. In order to calculate weighted averages, just multiply each individual section by its fraction of the whole.

For example, in order to compute the average for a student whose score is based 60\% on tests and 40\% on homework, you would multiply their test average by .6 and their homework average by .4, then add them together. In that case, if your homework average is 80 and your test average is 86, you would do
\begin{lstlisting}
80 * 0.4 + 86 * 0.6
\end{lstlisting}
giving you a weighted average of 83.6.
\subsubsection{Instructions}

Write a function called get\_average that takes a student dictionary as input and returns his/her weighted average. Use your average function to help. Homework is 10\%, quizzes are 30\% and tests are 60\%.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [90, 97, 75, 92],
    "quizzes": [88, 40, 94],
    "tests": [75, 90]
}
alice = {
    "name": "Alice",
    "homework": [100, 92, 98, 100],
    "quizzes": [82, 83, 91],
    "tests": [89, 97]
}
tyler = {
    "name": "Tyler",
    "homework": [0, 87, 75, 22],
    "quizzes": [0, 75, 78],
    "tests": [100, 100]
}

# Add your function below!

\end{lstlisting}
\subsection{Sending a Letter}

Great work!
\subsubsection{Instructions}

Now write a get\_letter\_grade function that takes score as input and returns a string with the letter grade that that student should receive.

These are the grade cutoffs. Be sure to round your students' scores before assigning grades! You can round a score using Python's built-in round() function, like so:
\begin{lstlisting}
score = round(score)

Scores 90 or above: return "A"
If 80 <= score < 90: return "B"
If 70 <= score < 80: return "C"
If 60 <= score < 70: return "D"
If score < 60: return "F"
\end{lstlisting}
Finally, pass your function the result of running get\_average on lloyd and print the resulting letter grade.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [90, 97, 75, 92],
    "quizzes": [88, 40, 94],
    "tests": [75, 90]
}
alice = {
    "name": "Alice",
    "homework": [100, 92, 98, 100],
    "quizzes": [82, 83, 91],
    "tests": [89, 97]
}
tyler = {
    "name": "Tyler",
    "homework": [0, 87, 75, 22],
    "quizzes": [0, 75, 78],
    "tests": [100, 100]
}

# Add your function below!

\end{lstlisting}

\subsection{Part of the Whole}

Good! Now let's see how your class is doing on average.
\subsubsection{Instructions}

Write a function called get\_class\_average that takes your student list as input to compute the average of your entire class.

In order to do this, you will need to use get\_average on each individual student and then take the average of those averages.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [90, 97, 75, 92],
    "quizzes": [88, 40, 94],
    "tests": [75, 90]
}
alice = {
    "name": "Alice",
    "homework": [100, 92, 98, 100],
    "quizzes": [82, 83, 91],
    "tests": [89, 97]
}
tyler = {
    "name": "Tyler",
    "homework": [0, 87, 75, 22],
    "quizzes": [0, 75, 78],
    "tests": [100, 100]
}

# Add your function below!

\end{lstlisting}
\subsection{How is Everybody Doing?}
\subsubsection{Instructions}

Finally, go ahead and add your students list back in and run your get\_class\_average function on your students to print out the numerical grade AND the letter grade.
\begin{lstlisting}
lloyd = {
    "name": "Lloyd",
    "homework": [90, 97, 75, 92],
    "quizzes": [88, 40, 94],
    "tests": [75, 90]
}
alice = {
    "name": "Alice",
    "homework": [100, 92, 98, 100],
    "quizzes": [82, 83, 91],
    "tests": [89, 97]
}
tyler = {
    "name": "Tyler",
    "homework": [0, 87, 75, 22],
    "quizzes": [0, 75, 78],
    "tests": [100, 100]
}

# Add your function below!

\end{lstlisting}

\chapter{Lists and Functions}
Now that you've learned about lists, let's turbo-charge them with functions.

\section{List Recap}
In this section, we'll go over some simple exercises on the uses of lists.
\subsection{List accessing}
This exercise goes over just pulling information from a list, which we've covered in a previous section!
\subsubsection{Instructions}
Please add the code to print out the second element in the list.
\begin{lstlisting}
n = [1, 3, 5]

# Add your code below
\end{lstlisting}
\subsection{List element modification}

You've already learned how to modify elements of a list in a previous section. This exercise is just a recap of that!
\subsubsection{Instructions}
Go ahead and multiply the second element of the n list by 5 on line 3.
\begin{lstlisting}
n = [1, 3, 5]
# Do your multiplication here

print n
\end{lstlisting}

\subsection{Appending to a list}

Here, we'll quickly recap how to .append() elements to the end of a list.
\subsubsection{Instructions}

Append the number 4 to the end of the list n.

\begin{lstlisting}
n = [1, 3, 5]
# Append the number 4 here

print n
\end{lstlisting}

\subsection{Removing elements from lists}

This exercise will expand on ways to remove items from a list. You actually have a few options. For a list called n:
\begin{itemize}
\item    n.pop(index) will remove the item at index from the list and return it to you:
\begin{lstlisting}
n = [1, 3, 5]
n.pop(1)
# Returns 3 (the item at index 1)
print n
# prints [1, 5]
\end{lstlisting}
\item    n.remove(item) will remove the actual item if it finds it:
\begin{lstlisting}
n.remove(1)
# Removes 1 from the list,
# NOT the item at index 1
print n
# prints [3, 5]
\end{lstlisting}
\item    del(n[1] is like .pop in that it will remove the item at the given index, but it won't return it:
\begin{lstlisting}
del(n[1])
# Doesn't return anything
print n
# prints [1, 5]
\end{lstlisting}
\end{itemize}
\subsubsection{Instructions}
Remove the first item from the list n using either .pop(), .remove(), or del.
\begin{lstlisting}
n = [1, 3, 5]
# Remove the first item in the list here

print n
\end{lstlisting}

\section{Function Recap}
This section is just a refresher on some basic uses of functions.
\subsection{Changing the functionality of a function}

In this exercise, you will just be making a minor change to a function to change what that function does.
\subsubsection{Instructions}

Change the function so the given argument is multiplied by 3 and returned.
\begin{lstlisting}
number = 5

def my_function(x):
    return x + 3

print my_function(number)
\end{lstlisting}

\subsection{More than one argument}

This exercise is to recap how to use more than one argument in a function.
\subsubsection{Instructions}

Define a function called add\_function that takes 2 arguments and adds them together.
\begin{lstlisting}
m = 5
n = 13
# Add add_function here!



print add_function(m, n)
\end{lstlisting}

\subsection{Arbitrary number of arguments}

This exercise goes over how to take an arbitrary number of arguments in a function.
\subsubsection{Instructions}

Change your code from the last exercise to take an arbitrary number of arguments. Have it return the sum of those arguments.
\begin{lstlisting}
m = 5
n = 13
# Add add_function here!



print add_function(m, n)
\end{lstlisting}

\subsection{Strings in functions}

This is a basic recap on using strings in functions.
\subsubsection{Instructions}

Write a function called string\_function that takes in a string argument and then returns that argument concatenated with the word 'world'. Don't add a space before word!
\begin{lstlisting}
n = "Hello"
# Your function here!



print string_function(n)
\end{lstlisting}

\section{Introduction to Using Functions With Lists}
This section shows you how to create simple functions that take lists as arguments.
\subsection{Passing a list to a function}

You pass a list to a function the same way you pass any other argument to a function.
\subsubsection{Instructions}

Click Save and Submit Code to see that using a list as an argument in a function is essentially the same as using just a number or string!
\begin{lstlisting}
n = [3, 5, 7]

def list_function(x):
    return x

print list_function(n)
\end{lstlisting}

\subsection{Using an element from a list in a function}

If you pass a list to a function, you can call the elements of that list in that function the same way you would call an element of an argument list (e.g. *args, which was covered in Section 2, Exercise 3).
\subsubsection{Instructions}

Change list\_function to only return the second value in the list.
\begin{lstlisting}
n = [3, 5, 7]

def list_function(x):
    return x

print list_function(n)
\end{lstlisting}
\subsection{Modifying an element of a list in a function}

Modifying an element in a list in a function is the same as if you were just modifying an element of a list outside a function.
\subsubsection{Instructions}

Change list\_function so that it adds 3 to the second element of the list, then return the whole list.
\begin{lstlisting}
n = [3, 5, 7]

def list_function(x):
    return x

print list_function(n)
\end{lstlisting}
\subsection{List manipulation in functions}

You can change the size of a list in a function and return it just as if you were manipulating the list outside a function.
\subsubsection{Instructions}

Create a function called list\_extender that appends the number 9 to the end of a list and then returns that list.
\begin{lstlisting}
n = [3, 5, 7]
# Add your function here



print list_extender(n)
\end{lstlisting}

\section{Using the Entire List in a Function}
This section shows how you use an entire list regardless of whether or not you know the size of the function.
\subsection{Printing out a list item by item in a function}

This exercise is to go over how to utilize every element in a list in a function. You can use the existing code to complete the exercise and see how running this operation inside a function isn't much different from running this operation outside a function.

Don't worry about the range function quite yet—we'll explain it later in this section.
\subsubsection{Instructions}

Create a function called print\_list that takes a list and prints out each element one by one. Use the existing code as a scaffold. Have the argument in the function be called x.

(No need to call your function—we've taken care of that for you behind the scenes.)
\begin{lstlisting}
n = [3, 5, 7]

for i in range(0, 3):
    print n[i]
\end{lstlisting}

\subsection{Modifying each element in a list in a function}

This exercise shows how to modify each element in a list. It is useful to do so in a function as you can easily put in a list of any length and get the same functionality. As you can see, len(n) is the length of the list.
\subsubsection{Instructions}

Create a function called double\_list that takes a single argument x (which will be a list) and multiplies each element by 2 and returns that list. Use the existing code as a scaffold.
\begin{lstlisting}
n = [3, 5, 7]

for i in range(0, len(n)):
    n[i] = n[i] * 2
# Don't forget to return your new list!

print double_list(n)
\end{lstlisting}

\subsection{}
Passing a range into a function

Okay! Range time. The Python range() function is just a shortcut for generating a list, so you can use ranges in all the same places you can use lists.

A range can take 1, 2 or 3 arguments. If you use one argument, it starts the range at zero and increments by 1 until the size reaches 1 less than the range. For instance:
\begin{lstlisting}
range(1) # => [0]
range(2) # => [0,1]
\end{lstlisting}
If you use two arguments, the first argument is the start for the range and the second argument is the same as above:
\begin{lstlisting}
range(1,3) # => [1,2]
\end{lstlisting}
If you use 3 arguments, the range's first argument is the number the list starts at, the second number is where the list ends, and the third argument is how much you should increment by instead of the default increment of 1. For instance:
\begin{lstlisting}
range(2,8,3) # => [2,5]
range(2,9,3) # => [2,5,8]
\end{lstlisting}
\subsubsection{Instructions}

Go ahead and pass a range consisting of 0, 1, 2 to my\_function.
\begin{lstlisting}
def my_function(x):
    for i in range(0, len(x)):
        x[i] = x[i] * 2
    return x

print my_function() # Add your range between the parentheses!
\end{lstlisting}

\subsection{Counting up the elements in a list of arbitrary size in a function}

This exercise shows how to use the skills you have learned in this lesson to run operations against each element in a list to get a single output.

This is useful for adding up all the elements or counting all the duplicates in a list.
\subsubsection{Instructions}

Create a function called total that adds up all the elements of a list and returns that count, using the existing code as a hint. Use a for loop so it can be used for any size list.
\begin{lstlisting}
n = [3, 5, 7]

count = n[0] + n[1] + n[2]

print count
\end{lstlisting}

\subsection{Using strings in lists in functions}

Using strings is not much different from using numbers or other objects in lists in functions.
\subsubsection{Instructions}

Create a function called join\_strings that concatenates all the strings in a list and returns the resulting string. Don't add spaces between the joined strings!
\begin{lstlisting}
n = ["Michael", "Lieberman"]
# Add your function here



print join_strings(n)
\end{lstlisting}

\section{Using Lists of Lists in Functions}
This section shows how using lists containing other lists are not much different than anything you've learned previously in this lesson.
\subsection{Using two lists as two arguments in a function}

Using multiple lists in a function is no different from just using multiple arguments in a function. In this exercise you can see how to append one list onto another.
\subsubsection{Instructions}

Create a function called join\_lists that takes two lists, x and y, appends y to the end of x, then returns the finalized list. Use the existing code as a scaffold.

You want the output to look like this:
\begin{lstlisting}
[1, 2, 3, 4, 5, 6]
\end{lstlisting}
Not like this:
\begin{lstlisting}
[1, 2, 3, [4, 5, 6]]
\end{lstlisting}

\begin{lstlisting}
m = [1, 2, 3]
n = [4, 5, 6]

# Add your code here!





print join_lists(m, n)
\end{lstlisting}

\subsection{Using an arbitrary number of lists in a function}

In this exercise you can see how to use an arbitrary number of lists and perform operations on them. Using an arbitrary number of lists is no different than using an arbitrary number of any other object in a function.
\subsubsection{Instructions}

Update the join\_lists function to take an arbitrary number of lists and concatenate them. Your final list should look like this:
\begin{lstlisting}
[1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{lstlisting}
\begin{lstlisting}
m = [1, 2, 3]
n = [4, 5, 6]
o = [7, 8, 9]

# Update the below function to take
# an arbitrary number of arguments
def join_lists(x, y):
    return x + y


print join_lists(m, n, o)
\end{lstlisting}

\subsection{Using a list of lists in a function}

Finally, this exercise shows how to make use of a single list that contains multiple lists and how to use them in a function.

This, like most of the previous exercises, is not much different from the simpler examples. Using a list of lists is no different than if you just had a single list with multiple objects in it. These objects just happen to be other lists.
\subsubsection{Instructions}

Create a function called flatten that takes a single list and concatenates all the sublists that are part of it into a single list.

For instance, it should turn
\begin{lstlisting}
[[1, 2, 3], [4, 5, 6]]
\end{lstlisting}
into
\begin{lstlisting}
[1, 2, 3, 4, 5, 6]
\end{lstlisting}

\begin{lstlisting}
n = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
# Add your function here




print flatten(n)
\end{lstlisting}

\chapter{Project: Battleship!}
In this project we will make a simplified version of the classic board game Battleship! We'll use functions, lists, and conditionals to make our game.

\section{Don't Sink My Battleship!}
We will build our Battleship program step-by-step.
\subsection{Welcome to Battleship!}

In this project you will build a simplified, one-player version of the classic board game Battleship! In this version of the game, there will be a single ship hidden in a random location on a 5x5 grid. The player will have 10 guesses to try to sink the ship.

To build this game we will use our knowledge of lists, conditionals and functions in Python. When you're ready to get started, click run to continue.
\subsubsection{Instructions}

Click Save and Submit Code to get started with Battleship!

\subsection{Getting Our Feet Wet}

The first thing we need to do is to set up the game board.
\subsubsection{Instructions}

Create a variable board and set it equal to an empty list.

\subsection{Make a List}

Good! Now we'll use a built-in Python function to generate our board, which we'll make into a 5 x 5 grid of all "O"s, for "ocean."

The .append function will add an item to a list. Typing
\begin{lstlisting}
board.append(["O"] * 5)
\end{lstlisting}
will add five "O"s, which is the basis for creating our row. We'll do this five times to make five rows. (Since we have to do this five times, it sounds like a loop might be in order.)
\subsubsection{Instructions}

Create a 5 x 5 grid initialized to all 'O's and store it in board. Check the Hint if you need help!

\subsection{Check it Twice}

Great job! Now that we've built our board, let's show it off.

Throughout our game, we'll want to print the game board so that the player can see which locations they have already guessed. Regularly printing the board will also help us debug our program.

The easiest way to print the board would be to have Python display it for us using the print command. Let's give that a try and see what the results look like—is this a useful way to print our board for Battleship?
\subsubsection{Instructions}

Use the print command to display the contents of the board list.

\subsection{Custom Print}

Now we can see the contents of our list, but clearly it would be easier to play the game if we could print the board out like a grid with each row on its own line.

We can use the fact that our board is a list of lists to help us do this. Let's set up a for loop to go through each of the elements in the outer list (each of which is a row of our board) and print them.

While we're cleaning up our print routine, let's also move it to a function. Since we'll want to print our board often, it will be handy to have a function to call. Also, printing is a self-contained task that is easily packaged as a function. To be able to print a board, the print function will need to take a board as a parameter.
\subsubsection{Instructions}

First, delete your existing print statement. Then, define a function named print\_board that takes a single parameter, board. Inside the function, write a for loop that iterates through each row in board and prints it to the screen. Call your function in order to make sure it works.

\subsection{Printing Pretty}

We're getting pretty close to a playable board, but wouldn't it be nice to get rid of those quote marks and commas? We're storing our data as a list, but the player doesn't need to know that!

To get rid of the formatting, we're going to use another built-in Python function: .join. If we type
\begin{lstlisting}
print " ".join(row)
\end{lstlisting}
inside our function, this tells Python to concatenate, or string together, all the "O"s in each row, putting a space in between them.

We'll want to do the .joining inside our for loop, so make sure your indentation is correct. If all's well, this will print each 'O' character without the quotes or commas.
\subsubsection{Instructions}

Inside your for loop, use .join on the elements of row to make each row into a string of "O"s with spaces in between each "O".

\subsection{Hide...}

Excellent! Now that our board is printing perfectly, we need to hide a battleship on it. Since we are making a 1-player game, we'll use Python to choose a random location on the board for the battleship.

Since we have a 2-dimensional list, we'll need two numbers to identify a single location on the board: one number to specify the row and another to specify the column. Let's call our variables ship\_row and ship\_col.

Python has a randint function that will help us generate a random number. randint(x, y) will generate a random integer between x and y. What should we use for x and y? We'll want to make sure the index that we generate puts the battleship in a location that is on the board!
\subsubsection{Instructions}

Create two new functions, random\_row and random\_col, that both take board as input. These function should return a random row index and a random column index from your board, respectively. Each function should use randint(x, y) and len(). Call each one on board.

\begin{lstlisting}
from random import randint 

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

# Add your code below!
\end{lstlisting}

\subsection{...and Seek!}

Good job! For now, let's store coordinates for the ship in the variables ship\_row and ship\_col. Now you have a hidden battleship in your ocean! Let's write the code to allow the player to guess where it is.

Just like we needed both a row and a column to determine the position to hide the ship, we'll need to ask the player to enter both a row and column guess. Let's call these variables guess\_col and guess\_row.

Use the raw\_input command to ask the user to enter their guesses for row and column.
\subsubsection{Instructions}

Create two new variables named guess\_row and guess\_col. Use the input command to have the user enter values for both variables. For guessing the row the input box should prompt "Guess Row:" for guessing the col the prompt should display "Guess Col:"

\begin{lstlisting}
from random import randint

board = []

for x in range(0,5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)

# Add your code below!

\end{lstlisting}

\subsection{It's Not Cheating—It's Debugging!}

Awesome! Now we have a hidden battleship and a guess from our player. In the next few steps, we'll check the user's guess to see if they are correct.

While we're writing and debugging this part of the program, it will be helpful to know where that battleship is hidden. Let's add a print statement that displays the location of the hidden ship.

Of course, we'll remove this output when we're finished debugging since if we left it in, our game wouldn't be very challenging. :)
\subsubsection{Instructions}

Add a print statement that displays the values of ship\_col and ship\_row.

\begin{lstlisting}
from random import randint

board = []

for x in range(0,5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)

# Add your code below!

\end{lstlisting}
    
\section{Hit or Miss?}
Check the guess to see if a ship has been hit.
\subsection{You win!}

Okay—now for the fun! We have the actual location of the ship and the player's guess so we can check to see if the player guessed right.

For a guess to be right, guess\_col should be equal to ship\_col and guess\_row should be equal to ship\_row.

In this step, we'll write an if statement that checks to see if the player has correctly guessed the location of the ship. If they did, we will print the message "Congratulations! You sank my battleship!"
\subsubsection{Instructions}

Write an if statement that checks to see if guess\_row matches ship\_row and guess\_col matches ship\_col.
\begin{lstlisting}
from random import randint

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print_board(board)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
guess_row = raw_input("Guess Row:")
guess_col = raw_input("Guess Col:")

print ship_row
print ship_col

# Write your code below!

\end{lstlisting}

\subsection{Danger, Will Robinson!!}

Great! Of course, the player isn't going to guess right all the time, so we also need to handle the case where the guess is wrong.

When the player guesses wrong we'll do two things:
\begin{itemize}
\item    Print a message saying "You missed my battleship!"
\item    To help the player keep track of which locations they have already guessed, we'll change that element in the list to an "X".
\end{itemize}

Because Python turns the numerical guesses into strings via raw\_input, you'll want to use the built-in int() function to change the guesses to numbers, like so:
\begin{lstlisting}
board[int(guess_row)][int(guess_col)] = "X"
\end{lstlisting}
\subsubsection{Instructions}

Add an else under the if we wrote in the previous step. Since the if handles the case where the player's guess is correct, this else will handle an incorrect guess. Display the missed guess message and change the list element at guess\_row, guess\_col to an "X".

As the last line in your else statement, go ahead and call print\_board(board) again so you can see the "X"!

\begin{lstlisting}
from random import randint

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print_board(board)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
guess_row = raw_input("Guess Row:")
guess_col = raw_input("Guess Col:")

print ship_row
print ship_col

# Write your code below!

\end{lstlisting}

\subsection{Bad Aim}

Great job! Now we can handle both correct and incorrect guesses from the user. But now let’s think a little bit more about the "miss" condition. There are lots of ways that the user can guess wrong:
\begin{itemize}
\item    They can enter a guess that's off the board
\item    They can guess a spot they’ve already guessed
\item    They can just miss the ship
\end{itemize}
So, let’s expand our else condition to add some helpful feedback based on each of these possibilities. We'll do this with a new if block nested under the else of our existing if block (since all of these cases will occur when the user guesses incorrectly).

First, let’s add the case where the spot the user guesses is off the board. What x and y values are illegal? Let’s build an if statement and print out "Oops, that's not even in the ocean."

Notice that you'll have to add another else for the code that is already there.
\subsubsection{Instructions}

Add a new if statement nested under the else. The else handles all incorrect guesses and we are going to add code to handle different types of incorrect guesses.

Your new if should check to see if the row and column coordinates guessed by the user are not valid for the given board size.

Add an else under your new if for the code that is already there (the generic incorrect guess code).

\begin{lstlisting}
from random import randint

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print_board(board)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
guess_row = raw_input("Guess Row:")
guess_col = raw_input("Guess Col:")

print ship_row
print ship_col

# Write your code below!

\end{lstlisting}

\subsection{Not Again!}

Great! Now let's handle the second type of incorrect guess: the player guesses a location that was already guessed. How will we know that a location was previously guessed?

It should have an 'X' instead of an 'O' if our code is working correctly.
\subsubsection{Instructions}

Add an elif that checks to see if the guessed location already has an 'X' in it. If it has, print "You guessed that one already."

\begin{lstlisting}
from random import randint

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print_board(board)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
guess_row = raw_input("Guess Row:")
guess_col = raw_input("Guess Col:")

print ship_row
print ship_col

# Write your code below!

\end{lstlisting}

\subsection{Test Run}

Congratulations! Now you should have a game of Battleship! that is fully functional for one guess.

Make sure you play it a couple of times and try different kinds of incorrect guesses. This is a great time to stop and do some serious debugging.

In the next step, we'll move on and look at how to give the user 4 guesses to find the battleship.
\subsubsection{Instructions}

Thoroughly test your game. Make sure you try a variety of different guesses and look for any errors in the syntax or logic of your program.

\begin{lstlisting}
from random import randint

board = []

for x in range(0, 5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print_board(board)

def random_row(board):
    return randint(0, len(board) - 1)

def random_col(board):
    return randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
guess_row = raw_input("Guess Row:")
guess_col = raw_input("Guess Col:")

print ship_row
print ship_col

# Write your code below!

\end{lstlisting}

\section{You Sunk My Battleship!}
Keep the guesses going until the game is over.
\subsection{Play It, Sam}

You can successfully make one guess in Battleship! But we’d like our game to allow the player to make up to 4 guesses before they lose.

We can use a for loop to iterate through our turns just like we used it to iterate through our list. We use the same syntax, but instead of specifying a list to iterate through, we give a range. Then our loop will execute all the commands inside it that number of times.

For example, the loop
\begin{lstlisting}
for i in range(5):
\end{lstlisting}
executes a loop 5 times. The variable i starts at 0 and gets incremented each time through the loop. That means the loop will run five times and i will take on the values 0, 1, 2, 3, and 4 on successive iterations.

We can use a for loop just like this to run our program 4 times for 4 turns. Let’s use the variable turn instead of i and have a range of 4. To help us see what is going on, let’s print out the value of turn each time through the loop (remember that turn will start at 0, but most human players will want their turns to start with number 1, so we’ll actually want to print turn+1.)

Make sure you are careful only to put the code that should repeat (guessing and checking the guess) inside the loop. Put the code that should only execute once (hiding the ship) outside the loop.
\subsubsection{Instructions}

Add a for loop that repeats the guessing and checking part of your game for 4 turns. Print out a message on each iteration of the loop letting the player know what turn they are on.
\begin{lstlisting}
from random import randint

board = []

for x in range(5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print "Let's play Battleship!"
print_board(board)

def random_row(board):
    return random.randint(0, len(board) - 1)

def random_col(board):
    return random.randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
print ship_row
print ship_col

# Everything from here on should go in your for loop!
# Be sure to indent four spaces!
guess_row = input("Guess Row:")
guess_col = input("Guess Col:")

if guess_row == ship_row and guess_col == ship_col:
    print "Congratulations! You sunk my battleship!"
else:
    if (guess_row < 0 or guess_row > 4) or (guess_col < 0 or guess_col > 4):
        print "Oops, that's not even in the ocean."
    elif(board[guess_row][guess_col] == "X"):
        print "You guessed that one already."
    else:
        print "You missed my battleship!"
    board[guess_row][guess_col] = "X"
    # Print (turn + 1) here!
    print_board(board)
\end{lstlisting}

\subsection{Game Over}

If someone runs out of guesses without winning right now, the game just exits. It would be nice to let them know why. Let’s print a "Game Over" message letting the player know that they are out of turns. Since we only want this message to display if the user guesses wrong on their last turn, we need to think carefully about where to put it.
\begin{enumerate}
\item We’ll want to put it under the else that accounts for misses
\item We’ll want to print the message no matter what the cause of the miss
\item We’ll need to add a check to see if the user is out of guesses. Since our turn variable starts at 0 and goes to 3, it'll have value 3 on the last guess.
\end{enumerate}
\subsubsection{Instructions}

Add an if statement that checks to see if the user is out of guesses. If the player has made 4 incorrect guesses, print "Game Over".
\begin{lstlisting}
from random import randint

board = []

for x in range(5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print "Let's play Battleship!"
print_board(board)

def random_row(board):
    return random.randint(0, len(board) - 1)

def random_col(board):
    return random.randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
print ship_row
print ship_col

# Everything from here on should go in your for loop!
# Be sure to indent four spaces!
guess_row = input("Guess Row:")
guess_col = input("Guess Col:")

if guess_row == ship_row and guess_col == ship_col:
    print "Congratulations! You sunk my battleship!"
else:
    if (guess_row < 0 or guess_row > 4) or (guess_col < 0 or guess_col > 4):
        print "Oops, that's not even in the ocean."
    elif(board[guess_row][guess_col] == "X"):
        print "You guessed that one already."
    else:
        print "You missed my battleship!"
    board[guess_row][guess_col] = "X"
    # Print (turn + 1) here!
    print_board(board)
\end{lstlisting}

\subsection{A Real Win}

Almost there! We can play Battleship!, but you’ll notice that when you win, if you haven’t already guessed 4 times, the program asks you to enter another guess. What we’d rather have happen is for the program to end—it’s no fun guessing if you know you’ve already sunk the Battleship!

We can use the command break to get out of a for loop.
\subsubsection{Instructions}

Add a break under the win condition to end the loop after a win.
\begin{lstlisting}
from random import randint

board = []

for x in range(5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print "Let's play Battleship!"
print_board(board)

def random_row(board):
    return random.randint(0, len(board) - 1)

def random_col(board):
    return random.randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
print ship_row
print ship_col

# Everything from here on should go in your for loop!
# Be sure to indent four spaces!
guess_row = input("Guess Row:")
guess_col = input("Guess Col:")

if guess_row == ship_row and guess_col == ship_col:
    print "Congratulations! You sunk my battleship!"
else:
    if (guess_row < 0 or guess_row > 4) or (guess_col < 0 or guess_col > 4):
        print "Oops, that's not even in the ocean."
    elif(board[guess_row][guess_col] == "X"):
        print "You guessed that one already."
    else:
        print "You missed my battleship!"
    board[guess_row][guess_col] = "X"
    # Print (turn + 1) here!
    print_board(board)
\end{lstlisting}

\subsection{To Your Battle Stations!}

Congratulations! You have a fully functional Battleship game! Play it a couple of times and get your friends to try it out, too. (Don’t forget to go back and remove the debugging output that gives away the location of the battleship!)

You may want to take some time to clean up and document your code as well.
\subsubsection{Instructions}

When you are done playing Battleship! and are ready to move on.
\begin{lstlisting}
from random import randint

board = []

for x in range(5):
    board.append(["O"] * 5)

def print_board(board):
    for row in board:
        print " ".join(row)

print "Let's play Battleship!"
print_board(board)

def random_row(board):
    return random.randint(0, len(board) - 1)

def random_col(board):
    return random.randint(0, len(board[0]) - 1)

ship_row = random_row(board)
ship_col = random_col(board)
print ship_row
print ship_col

# Everything from here on should go in your for loop!
# Be sure to indent four spaces!
guess_row = input("Guess Row:")
guess_col = input("Guess Col:")

if guess_row == ship_row and guess_col == ship_col:
    print "Congratulations! You sunk my battleship!"
else:
    if (guess_row < 0 or guess_row > 4) or (guess_col < 0 or guess_col > 4):
        print "Oops, that's not even in the ocean."
    elif(board[guess_row][guess_col] == "X"):
        print "You guessed that one already."
    else:
        print "You missed my battleship!"
    board[guess_row][guess_col] = "X"
    # Print (turn + 1) here!
    print_board(board)
\end{lstlisting}

\subsection{Extra Credit}

You can also add on to your Battleship! program to make it more complex and fun to play. Here are some ideas for enhancements—maybe you can think of some more!
\begin{enumerate}
\item    Make multiple battleships: you'll need to be careful because you need to make sure that you don’t place battleships on top of each other on the game board. You'll also want to make sure that you balance the size of the board with the number of ships so the game is still challenging and fun to play.

\item    Make battleships of different sizes: this is trickier than it sounds. All the parts of the battleship need to be vertically or horizontally touching and you’ll need to make sure you don’t accidentally place part of a ship off the side of the board.

\item    Make your game a two-player game.
\end{enumerate}
Some of these options will be easier after we cover loops in the next lesson. Think about coming back to Battleship! after a few more lessons and see what other changes you can make!

\chapter{Loops}
Loops allow you to quickly iterate over information in Python. In this lesson, we'll cover two types of loop: 'while' and 'for'.

\section{While Loops}
Let's go over the basics of 'while' loops.
\subsection{While you're here}

The while loop is similar to an if statement: it executes the code inside of it if some condition is true. The difference is that the while loop will continue to execute as long as the condition is true. In other words, instead of executing if something is true, it executes while that thing is true.

Line 6 decides when the loop will be executed. So, "as long as count is less than 5," the loop will continue to execute. Line 8 increases count by 1. This happens over and over until count equals 5.
\subsubsection{Instructions}

Change the loop so it counts up to 9 (inclusive).

Be careful not to change or remove the count += 1 bit—if Python has no way to increase count, your loop could go on forever and become an infinite loop!
\begin{lstlisting}
count = 0

if count < 5:
    print "Hello, I am an if statement and count is", count
    
while count < 5:
    print "Hello, I am a while and count is", count
    count += 1
\end{lstlisting}

\subsection{Condition}

The condition is the expression that decides whether the loop is going to be executed or not. There are 5 steps to this program:
\begin{itemize}
\item    The loop\_condition variable is set to True

\item    The while loop checks to see if loop\_condition is True. It is, so the loop is entered.

\item    The print statement is executed.

\item    The variable loop\_condition is set to False.

\item    The while loop again checks to see if loop\_condition is True. It is not, so the loop is not executed a second time.
\end{itemize}
\subsubsection{Instructions}

See how the loop checks its condition, and when it stops executing? When you think you've got the hang of it.

\begin{lstlisting}
loop_condition = True

while loop_condition:
    print "I am a loop"
    loop_condition = False
\end{lstlisting}

\subsection{While you're at it}

Inside a while loop, you can do anything you could do elsewhere, including arithmetic operations.
\subsubsection{Instructions}

Create a while loop that prints out all the numbers from 1 to 10 squared (1, 4, 9, 16, ... , 100), each on their own line. Remember to increment num or your browser could crash from the infinite loop!
\begin{lstlisting}
num = 1

while :# Fill in the condition (before the colon)
    # Print num squared
    # Increment num (make sure to do this!)
\end{lstlisting}

\subsection{Simple errors}

A common application of a while loop is to check user input to see if it is valid. For example, if you ask the user to enter y or n and they instead enter 7, then you should re-prompt them for input.
\subsubsection{Instructions}

Fill in the loop condition so the user will be prompted for a choice over and over until they enter either 'y' or 'n'.
\begin{lstlisting}
choice = raw_input('Enjoying the course? (y/n)')

while :# Fill in the condition (before the colon)
    choice = raw_input("Sorry, I didn't catch that. Enter again: ")


\end{lstlisting}
\subsection{Infinite loops}

An infinite loop is a loop that never exits. This can happen for a few reasons:
\begin{itemize}
\item    The loop condition cannot possibly be false (e.g. while 1 != 2)

\item    The logic of the loop prevents the loop condition from becoming false.
\end{itemize}
Example:
\begin{lstlisting}
count = 10
while count > 0:
    count += 1 # Instead of count -= 1
\end{lstlisting}
\subsubsection{Instructions}

The loop in the editor has two problems: it's missing a colon (a syntax error) and count is never incremented (logical error). The latter will result in an infinite loop, so be sure to fix both before running!
\begin{lstlisting}
count = 0

while count < 10 # Add a colon
    print count
    # Increment count
\end{lstlisting}

\subsection{Break}

The break is a one-line statement that means "exit the current loop." An alternate way to make our counting loop exit and stop executing is with the break statement.
\begin{itemize}
\item    First, create a while with a condition that is always true. The simplest way is shown.

\item    Using an if statement, you define the stopping condition. Inside the if, you write break, meaning "exit the loop."

\item The difference here is that this loop is guaranteed to run at least once.
\end{itemize}

\subsubsection{Instructions}
See what the break does? Feel free to mess around with it (but make sure you don't cause an infinite loop)! Click Save and Submit Code when you're ready to continue.

\begin{lstlisting}
count = 0

while True:
    print count
    count += 1
    if count >= 10:
        break
\end{lstlisting}

\subsection{While / else}

Something completely different about Python is the while/else construction. while/else is similar to if/else, but there is a difference: the else block will execute anytime the loop condition is evaluated to False. This means that it will execute if the loop is never entered or if the loop exits normally. If the loop exits as the result of a break, the else will not be executed.

In this example, the loop will break if a 5 is generated, and the else will not execute. Otherwise, after 3 numbers are generated, the loop condition will become false and the else will execute.
\subsubsection{Instructions}

Click Save and Submit Code to see while/else in action!
\begin{lstlisting}
import random

print "Lucky Numbers! 3 numbers will be generated."
print "If one of them is a '5', you lose!"

count = 0
while count < 3:
    num = random.randint(1, 6)
    print num
    count += 1
    if num == 5:
        print "Sorry, you lose!"
        break
else:
    print "You win!"
\end{lstlisting}

\subsection{Your own while / else}

Now you should be able to make a game similar to the one in the last exercise. The current code generates a random number in the range 1 - 9 (remember, the upper bound is exclusive).

Allow the user to guess what the number is three times. If they guess correctly, print 'You win!' and break. If they do not guess correctly, have the else execute at the end of the loop to print 'You lose.'

Use guess = int(raw\_input("Enter a guess:")) to get a number from the user and store it as an integer. (Remember, raw\_input turns user input into a string, so we use int() to make it a number again.)
\subsubsection{Instructions}

Allow the user three guesses and then react using the while/else structure as described above.
\begin{lstlisting}
from random import randrange

random_number = randrange(1, 10)

count = 0
# Start your game!
\end{lstlisting}

\section{For Loops}
'For' loop basics.
\subsection{For your health}

An alternative way to loop is the for loop. The syntax is as shown; this example means "for each number i in the range 0 - 9, print i".
\subsubsection{Instructions}

Make the loop print the numbers from 0 to 19 instead of 0 to 9.
\begin{lstlisting}
print "Counting..."

for i in range(10):
    print i
    
\end{lstlisting}

\subsection{For your hobbies}

This kind of loop is useful when you want to do something a certain number of times, such as append something to the end of a list.
\subsubsection{Instructions}

Create a for loop that prompts the user for a hobby 3 times, then appends each one to hobbies.

\begin{lstlisting}
hobbies = []

# Add your code below!
\end{lstlisting}

\subsection{For your strings}

Using a for loop, you can print out each individual character in a string.

The example in the editor is almost plain English: "for each character c in thing, print c".
\subsubsection{Instructions}

Add a second for loop so that each character in word is printed one at a time.
\begin{lstlisting}
thing = "spam!"

for c in thing:
    print c

word = "eggs!"

# Your code here!

\end{lstlisting}

\subsection{For your A}

String manipulation is useful in for loops if you want to modify some content in a string. A for loop makes it possible to examine each character, one a time.
\subsubsection{Instructions}

Write a for loop to go through the characters of the string s and print them. However! If a character is an 'A' or an 'a', print a capital 'X' instead.

Note: You'll want to follow the thing you're printing with a comma (,) to prevent your output from including newlines. Check the Hint for more!
\begin{lstlisting}
s = "A bird in the hand..."

# Add your for loop

\end{lstlisting}

\subsection{For your lists}

Perhaps the most useful (and most common) use of for loops is to go through a list.

On each iteration, the variable num will be the next value in the list. So, the first time through, it will be 7, the second time it will be 9, then 12, 54, 99, and then the loop will exit when there are no more values in the list.
\subsubsection{Instructions}

Write a second for loop that goes through the numbers list and prints each element squared, each on its own line.

\begin{lstlisting}
numbers  = [7, 9, 12, 54, 99]

print "This list contains: "

for num in numbers:
    print num

# Add your loop below!
\end{lstlisting}

\section{Step Up Your 'For's}
You can use 'for' for multiple lists, counting in a list, and more. You can even pair 'for' with 'else'!

\chapter{Exam Statistics}

\chapter{Advanced Topics in Python}

\chapter{Introduction to Classes}

\chapter{File Input and Output}



\appendix
\renewcommand\chaptername{Appendix}
\chapter{Resources}
This chapter includes resources that are complimentary to the information presented in this book, and that are useful for further reading. Resources are divided by sections, based on their categories.


\end{document}
